[{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['204','0','232','30','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:23.701Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['203','0','231','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:23.707Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['202','0','230','24','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:23.716Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['201','0','229','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:23.733Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['200','0','228','68','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:23.750Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['199','0','227','28','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:23.766Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['198','0','226','70','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:23.782Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['197','0','225','4','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:23.800Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['196','0','224','5','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:23.816Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['195','0','223','41','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:23.849Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['194','0','222','41','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:23.884Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['193','0','221','41','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:23.900Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['192','0','220','37','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:23.932Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['191','0','219','13','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:23.950Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['190','0','218','17','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:23.967Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['189','0','217','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:24.000Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['188','0','216','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:24.033Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['187','0','215','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:24.066Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['186','0','214','4','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:24.100Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['185','0','213','67','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:24.167Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['184','0','212','67','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:24.248Z'},{src:'onDidChangeTextDocument',msg:'%s:%s to %s:%s in [%s] replaced with: %s`',prm:['144','0','215','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',''],time:'2024-09-08T07:45:24.261Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['184','0','212','54','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:24.292Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['144','0','144','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',''],time:'2024-09-08T07:45:24.297Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['139','0','167','41','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:24.297Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['138','0','166','49','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:24.357Z'},{src:'onDidChangeTextDocument',msg:'%s:%s to %s:%s in [%s] replaced with: %s`',prm:['144','0','144','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings"],time:'2024-09-08T07:45:26.904Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['144','0','215','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings"],time:'2024-09-08T07:45:26.914Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['188','0','216','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:26.914Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['187','0','215','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:27.318Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['186','0','214','4','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:27.349Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['184','0','212','67','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:27.366Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['182','0','210','53','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:27.383Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['181','0','209','66','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:27.416Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['178','0','206','49','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:27.433Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['171','0','199','31','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:27.449Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['167','0','195','4','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:27.466Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['164','0','192','43','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:27.483Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['161','0','189','39','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:27.499Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['157','0','185','169','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:27.516Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['154','0','182','67','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:27.533Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['151','0','179','39','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:27.551Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['148','0','176','28','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:27.566Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['145','0','173','61','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:27.584Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['144','0','172','26','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:27.666Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['143','0','171','38','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:27.700Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['142','0','170','36','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:27.733Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['141','0','169','45','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:27.799Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['140','0','168','4','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:27.849Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['139','0','167','21','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:27.866Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['138','0','166','79','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:27.883Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['137','0','165','4','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:27.899Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['135','0','163','28','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:27.916Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['133','0','161','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:27.949Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['131','0','159','78','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:27.965Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['130','0','158','127','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:27.983Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['128','0','156','78','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:28.016Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['127','0','155','4','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:28.033Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['125','0','153','32','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:28.050Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['123','0','151','105','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:28.065Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['122','0','150','82','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:28.082Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['120','0','148','41','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:28.098Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['119','0','147','105','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:28.266Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['142','0','142','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',''],time:'2024-09-08T07:45:29.121Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['141','4','142','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py','return selected_positive_warnings, selected_negative_warnings\n'],time:'2024-09-08T07:45:29.589Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['139','3','142','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'," print('Selected negative warning:', selected_negative_warnings)\n\n    return selected_positive_warnings, selected_negative_warnings\n"],time:'2024-09-08T07:45:29.602Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['136','1','142','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"       #print('Coin toss result: Negative selected')\n\n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n\n    return selected_positive_warnings, selected_negative_warnings\n"],time:'2024-09-08T07:45:29.635Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['135','0','142','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n\n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n\n    return selected_positive_warnings, selected_negative_warnings\n"],time:'2024-09-08T07:45:29.651Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['134','0','142','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"        selected_negative_warnings = [selected_warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n\n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n\n    return selected_positive_warnings, selected_negative_warnings\n"],time:'2024-09-08T07:45:29.668Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['132','0','142','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [selected_warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n\n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n\n    return selected_positive_warnings, selected_negative_warnings\n"],time:'2024-09-08T07:45:29.684Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['131','0','142','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [selected_warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n\n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n\n    return selected_positive_warnings, selected_negative_warnings\n"],time:'2024-09-08T07:45:29.701Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['130','0','142','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [selected_warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n\n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n\n    return selected_positive_warnings, selected_negative_warnings\n"],time:'2024-09-08T07:45:29.717Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['128','0','142','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [selected_warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n\n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n\n    return selected_positive_warnings, selected_negative_warnings\n"],time:'2024-09-08T07:45:29.733Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['127','0','142','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"        selected_positive_warnings = [selected_warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [selected_warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n\n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n\n    return selected_positive_warnings, selected_negative_warnings\n"],time:'2024-09-08T07:45:29.750Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['126','0','142','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"        # Select the shortest warning for positive\n        selected_positive_warnings = [selected_warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [selected_warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n\n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n\n    return selected_positive_warnings, selected_negative_warnings\n"],time:'2024-09-08T07:45:29.766Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['125','0','142','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [selected_warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [selected_warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n\n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n\n    return selected_positive_warnings, selected_negative_warnings\n"],time:'2024-09-08T07:45:29.799Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['124','0','142','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"\n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [selected_warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [selected_warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n\n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n\n    return selected_positive_warnings, selected_negative_warnings\n"],time:'2024-09-08T07:45:29.850Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['123','0','142','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"    coin_toss = random.choice(['positive', 'negative'])\n\n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [selected_warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [selected_warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n\n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n\n    return selected_positive_warnings, selected_negative_warnings\n"],time:'2024-09-08T07:45:29.883Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['122','0','142','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n\n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [selected_warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [selected_warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n\n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n\n    return selected_positive_warnings, selected_negative_warnings\n"],time:'2024-09-08T07:45:29.900Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['121','0','142','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"\n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n\n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [selected_warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [selected_warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n\n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n\n    return selected_positive_warnings, selected_negative_warnings\n"],time:'2024-09-08T07:45:29.933Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['120','0','142','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"            selected_warnings[i] = tuple(selected_warnings[i])\n\n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n\n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [selected_warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [selected_warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n\n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n\n    return selected_positive_warnings, selected_negative_warnings\n"],time:'2024-09-08T07:45:29.967Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['119','0','142','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"            selected_warnings[i][3] = 'negative'\n            selected_warnings[i] = tuple(selected_warnings[i])\n\n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n\n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [selected_warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [selected_warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n\n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n\n    return selected_positive_warnings, selected_negative_warnings\n"],time:'2024-09-08T07:45:30.000Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['118','0','142','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'negative'\n            selected_warnings[i] = tuple(selected_warnings[i])\n\n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n\n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [selected_warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [selected_warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n\n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n\n    return selected_positive_warnings, selected_negative_warnings\n"],time:'2024-09-08T07:45:30.100Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['118','0','146','63','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:30.117Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['117','0','142','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"        else:\n            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'negative'\n            selected_warnings[i] = tuple(selected_warnings[i])\n\n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n\n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [selected_warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [selected_warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n\n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n\n    return selected_positive_warnings, selected_negative_warnings\n"],time:'2024-09-08T07:45:30.121Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['117','0','145','7','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:30.133Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['116','0','142','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"            selected_warnings[i] = tuple(selected_warnings[i])\n        else:\n            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'negative'\n            selected_warnings[i] = tuple(selected_warnings[i])\n\n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n\n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [selected_warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [selected_warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n\n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n\n    return selected_positive_warnings, selected_negative_warnings\n"],time:'2024-09-08T07:45:30.136Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['116','0','144','143','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:30.150Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['115','0','142','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"            selected_warnings[i][3] = 'positive'\n            selected_warnings[i] = tuple(selected_warnings[i])\n        else:\n            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'negative'\n            selected_warnings[i] = tuple(selected_warnings[i])\n\n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n\n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [selected_warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [selected_warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n\n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n\n    return selected_positive_warnings, selected_negative_warnings\n"],time:'2024-09-08T07:45:30.153Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['115','0','143','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:30.166Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['114','0','142','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'positive'\n            selected_warnings[i] = tuple(selected_warnings[i])\n        else:\n            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'negative'\n            selected_warnings[i] = tuple(selected_warnings[i])\n\n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n\n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [selected_warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [selected_warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n\n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n\n    return selected_positive_warnings, selected_negative_warnings\n"],time:'2024-09-08T07:45:30.171Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['114','0','142','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:30.200Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['113','0','142','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"        if selected_warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'positive'\n            selected_warnings[i] = tuple(selected_warnings[i])\n        else:\n            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'negative'\n            selected_warnings[i] = tuple(selected_warnings[i])\n\n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n\n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [selected_warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [selected_warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n\n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n\n    return selected_positive_warnings, selected_negative_warnings\n"],time:'2024-09-08T07:45:30.204Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['113','0','141','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:30.215Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['112','0','142','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"    for i in range(len(selected_warnings)):\n        if selected_warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'positive'\n            selected_warnings[i] = tuple(selected_warnings[i])\n        else:\n            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'negative'\n            selected_warnings[i] = tuple(selected_warnings[i])\n\n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n\n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [selected_warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [selected_warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n\n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n\n    return selected_positive_warnings, selected_negative_warnings\n"],time:'2024-09-08T07:45:30.218Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['112','0','140','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:30.232Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['111','0','142','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(selected_warnings)):\n        if selected_warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'positive'\n            selected_warnings[i] = tuple(selected_warnings[i])\n        else:\n            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'negative'\n            selected_warnings[i] = tuple(selected_warnings[i])\n\n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n\n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [selected_warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [selected_warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n\n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n\n    return selected_positive_warnings, selected_negative_warnings\n"],time:'2024-09-08T07:45:30.235Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['111','0','139','67','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:30.248Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['110','0','142','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(selected_warnings)):\n        if selected_warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'positive'\n            selected_warnings[i] = tuple(selected_warnings[i])\n        else:\n            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'negative'\n            selected_warnings[i] = tuple(selected_warnings[i])\n\n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n\n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [selected_warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [selected_warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n\n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n\n    return selected_positive_warnings, selected_negative_warnings\n"],time:'2024-09-08T07:45:30.251Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['110','0','138','67','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:30.266Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['109','0','142','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"    sorted_warnings_by_length = sorted(selected_warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(selected_warnings)):\n        if selected_warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'positive'\n            selected_warnings[i] = tuple(selected_warnings[i])\n        else:\n            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'negative'\n            selected_warnings[i] = tuple(selected_warnings[i])\n\n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n\n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [selected_warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [selected_warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n\n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n\n    return selected_positive_warnings, selected_negative_warnings\n"],time:'2024-09-08T07:45:30.269Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['109','0','137','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:30.283Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['108','0','142','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"    \n    sorted_warnings_by_length = sorted(selected_warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(selected_warnings)):\n        if selected_warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'positive'\n            selected_warnings[i] = tuple(selected_warnings[i])\n        else:\n            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'negative'\n            selected_warnings[i] = tuple(selected_warnings[i])\n\n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n\n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [selected_warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [selected_warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n\n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n\n    return selected_positive_warnings, selected_negative_warnings\n"],time:'2024-09-08T07:45:30.286Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['108','0','136','53','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:30.299Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['107','0','142','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"            selected_warnings = random.choice([heuristic_shorter_code_first(selected_warnings), heuristic_shared_function_calls(selected_warnings), heuristic_neighbor_classes(selected_warnings)])\n    \n    sorted_warnings_by_length = sorted(selected_warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(selected_warnings)):\n        if selected_warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'positive'\n            selected_warnings[i] = tuple(selected_warnings[i])\n        else:\n            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'negative'\n            selected_warnings[i] = tuple(selected_warnings[i])\n\n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n\n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [selected_warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [selected_warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n\n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n\n    return selected_positive_warnings, selected_negative_warnings\n"],time:'2024-09-08T07:45:30.303Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['107','0','135','66','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:30.333Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['106','0','142','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"            # choose a random heuristic\n            selected_warnings = random.choice([heuristic_shorter_code_first(selected_warnings), heuristic_shared_function_calls(selected_warnings), heuristic_neighbor_classes(selected_warnings)])\n    \n    sorted_warnings_by_length = sorted(selected_warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(selected_warnings)):\n        if selected_warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'positive'\n            selected_warnings[i] = tuple(selected_warnings[i])\n        else:\n            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'negative'\n            selected_warnings[i] = tuple(selected_warnings[i])\n\n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n\n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [selected_warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [selected_warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n\n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n\n    return selected_positive_warnings, selected_negative_warnings\n"],time:'2024-09-08T07:45:30.336Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['106','0','134','63','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:30.350Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['105','0','142','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"        elif heuristic == 4:\n            # choose a random heuristic\n            selected_warnings = random.choice([heuristic_shorter_code_first(selected_warnings), heuristic_shared_function_calls(selected_warnings), heuristic_neighbor_classes(selected_warnings)])\n    \n    sorted_warnings_by_length = sorted(selected_warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(selected_warnings)):\n        if selected_warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'positive'\n            selected_warnings[i] = tuple(selected_warnings[i])\n        else:\n            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'negative'\n            selected_warnings[i] = tuple(selected_warnings[i])\n\n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n\n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [selected_warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [selected_warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n\n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n\n    return selected_positive_warnings, selected_negative_warnings\n"],time:'2024-09-08T07:45:30.353Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['105','0','133','39','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:30.366Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['104','0','142','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"            selected_warnings = heuristic_neighbor_classes(selected_warnings)\n        elif heuristic == 4:\n            # choose a random heuristic\n            selected_warnings = random.choice([heuristic_shorter_code_first(selected_warnings), heuristic_shared_function_calls(selected_warnings), heuristic_neighbor_classes(selected_warnings)])\n    \n    sorted_warnings_by_length = sorted(selected_warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(selected_warnings)):\n        if selected_warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'positive'\n            selected_warnings[i] = tuple(selected_warnings[i])\n        else:\n            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'negative'\n            selected_warnings[i] = tuple(selected_warnings[i])\n\n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n\n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [selected_warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [selected_warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n\n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n\n    return selected_positive_warnings, selected_negative_warnings\n"],time:'2024-09-08T07:45:30.369Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['104','0','132','49','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:30.383Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['103','0','142','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"        elif heuristic == 3:\n            selected_warnings = heuristic_neighbor_classes(selected_warnings)\n        elif heuristic == 4:\n            # choose a random heuristic\n            selected_warnings = random.choice([heuristic_shorter_code_first(selected_warnings), heuristic_shared_function_calls(selected_warnings), heuristic_neighbor_classes(selected_warnings)])\n    \n    sorted_warnings_by_length = sorted(selected_warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(selected_warnings)):\n        if selected_warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'positive'\n            selected_warnings[i] = tuple(selected_warnings[i])\n        else:\n            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'negative'\n            selected_warnings[i] = tuple(selected_warnings[i])\n\n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n\n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [selected_warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [selected_warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n\n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n\n    return selected_positive_warnings, selected_negative_warnings\n"],time:'2024-09-08T07:45:30.386Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['103','0','131','9','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:30.399Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['102','0','142','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"            selected_warnings = heuristic_shared_function_calls(selected_warnings)\n        elif heuristic == 3:\n            selected_warnings = heuristic_neighbor_classes(selected_warnings)\n        elif heuristic == 4:\n            # choose a random heuristic\n            selected_warnings = random.choice([heuristic_shorter_code_first(selected_warnings), heuristic_shared_function_calls(selected_warnings), heuristic_neighbor_classes(selected_warnings)])\n    \n    sorted_warnings_by_length = sorted(selected_warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(selected_warnings)):\n        if selected_warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'positive'\n            selected_warnings[i] = tuple(selected_warnings[i])\n        else:\n            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'negative'\n            selected_warnings[i] = tuple(selected_warnings[i])\n\n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n\n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [selected_warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [selected_warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n\n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n\n    return selected_positive_warnings, selected_negative_warnings\n"],time:'2024-09-08T07:45:30.402Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['102','0','130','53','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:30.416Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['101','0','142','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"        elif heuristic == 2:\n            selected_warnings = heuristic_shared_function_calls(selected_warnings)\n        elif heuristic == 3:\n            selected_warnings = heuristic_neighbor_classes(selected_warnings)\n        elif heuristic == 4:\n            # choose a random heuristic\n            selected_warnings = random.choice([heuristic_shorter_code_first(selected_warnings), heuristic_shared_function_calls(selected_warnings), heuristic_neighbor_classes(selected_warnings)])\n    \n    sorted_warnings_by_length = sorted(selected_warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(selected_warnings)):\n        if selected_warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'positive'\n            selected_warnings[i] = tuple(selected_warnings[i])\n        else:\n            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'negative'\n            selected_warnings[i] = tuple(selected_warnings[i])\n\n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n\n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [selected_warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [selected_warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n\n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n\n    return selected_positive_warnings, selected_negative_warnings\n"],time:'2024-09-08T07:45:30.419Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['101','0','129','66','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:30.433Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['100','0','142','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"            selected_warnings = heuristic_shorter_code_first(selected_warnings)\n        elif heuristic == 2:\n            selected_warnings = heuristic_shared_function_calls(selected_warnings)\n        elif heuristic == 3:\n            selected_warnings = heuristic_neighbor_classes(selected_warnings)\n        elif heuristic == 4:\n            # choose a random heuristic\n            selected_warnings = random.choice([heuristic_shorter_code_first(selected_warnings), heuristic_shared_function_calls(selected_warnings), heuristic_neighbor_classes(selected_warnings)])\n    \n    sorted_warnings_by_length = sorted(selected_warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(selected_warnings)):\n        if selected_warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'positive'\n            selected_warnings[i] = tuple(selected_warnings[i])\n        else:\n            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'negative'\n            selected_warnings[i] = tuple(selected_warnings[i])\n\n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n\n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [selected_warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [selected_warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n\n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n\n    return selected_positive_warnings, selected_negative_warnings\n"],time:'2024-09-08T07:45:30.436Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['100','0','128','39','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:30.466Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['99','0','142','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"        if heuristic == 1:\n            selected_warnings = heuristic_shorter_code_first(selected_warnings)\n        elif heuristic == 2:\n            selected_warnings = heuristic_shared_function_calls(selected_warnings)\n        elif heuristic == 3:\n            selected_warnings = heuristic_neighbor_classes(selected_warnings)\n        elif heuristic == 4:\n            # choose a random heuristic\n            selected_warnings = random.choice([heuristic_shorter_code_first(selected_warnings), heuristic_shared_function_calls(selected_warnings), heuristic_neighbor_classes(selected_warnings)])\n    \n    sorted_warnings_by_length = sorted(selected_warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(selected_warnings)):\n        if selected_warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'positive'\n            selected_warnings[i] = tuple(selected_warnings[i])\n        else:\n            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'negative'\n            selected_warnings[i] = tuple(selected_warnings[i])\n\n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n\n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [selected_warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [selected_warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n\n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n\n    return selected_positive_warnings, selected_negative_warnings\n"],time:'2024-09-08T07:45:30.469Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['99','0','127','62','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:30.483Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['98','0','142','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            selected_warnings = heuristic_shorter_code_first(selected_warnings)\n        elif heuristic == 2:\n            selected_warnings = heuristic_shared_function_calls(selected_warnings)\n        elif heuristic == 3:\n            selected_warnings = heuristic_neighbor_classes(selected_warnings)\n        elif heuristic == 4:\n            # choose a random heuristic\n            selected_warnings = random.choice([heuristic_shorter_code_first(selected_warnings), heuristic_shared_function_calls(selected_warnings), heuristic_neighbor_classes(selected_warnings)])\n    \n    sorted_warnings_by_length = sorted(selected_warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(selected_warnings)):\n        if selected_warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'positive'\n            selected_warnings[i] = tuple(selected_warnings[i])\n        else:\n            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'negative'\n            selected_warnings[i] = tuple(selected_warnings[i])\n\n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n\n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [selected_warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [selected_warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n\n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n\n    return selected_positive_warnings, selected_negative_warnings\n"],time:'2024-09-08T07:45:30.486Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['98','0','126','50','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:30.500Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['97','0','142','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"    \n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            selected_warnings = heuristic_shorter_code_first(selected_warnings)\n        elif heuristic == 2:\n            selected_warnings = heuristic_shared_function_calls(selected_warnings)\n        elif heuristic == 3:\n            selected_warnings = heuristic_neighbor_classes(selected_warnings)\n        elif heuristic == 4:\n            # choose a random heuristic\n            selected_warnings = random.choice([heuristic_shorter_code_first(selected_warnings), heuristic_shared_function_calls(selected_warnings), heuristic_neighbor_classes(selected_warnings)])\n    \n    sorted_warnings_by_length = sorted(selected_warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(selected_warnings)):\n        if selected_warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'positive'\n            selected_warnings[i] = tuple(selected_warnings[i])\n        else:\n            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'negative'\n            selected_warnings[i] = tuple(selected_warnings[i])\n\n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n\n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [selected_warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [selected_warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n\n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n\n    return selected_positive_warnings, selected_negative_warnings\n"],time:'2024-09-08T07:45:30.502Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['97','0','125','31','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:30.516Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['96','0','142','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"        selected_warnings[i] = tuple(selected_warnings[i])\n    \n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            selected_warnings = heuristic_shorter_code_first(selected_warnings)\n        elif heuristic == 2:\n            selected_warnings = heuristic_shared_function_calls(selected_warnings)\n        elif heuristic == 3:\n            selected_warnings = heuristic_neighbor_classes(selected_warnings)\n        elif heuristic == 4:\n            # choose a random heuristic\n            selected_warnings = random.choice([heuristic_shorter_code_first(selected_warnings), heuristic_shared_function_calls(selected_warnings), heuristic_neighbor_classes(selected_warnings)])\n    \n    sorted_warnings_by_length = sorted(selected_warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(selected_warnings)):\n        if selected_warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'positive'\n            selected_warnings[i] = tuple(selected_warnings[i])\n        else:\n            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'negative'\n            selected_warnings[i] = tuple(selected_warnings[i])\n\n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n\n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [selected_warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [selected_warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n\n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n\n    return selected_positive_warnings, selected_negative_warnings\n"],time:'2024-09-08T07:45:30.520Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['96','0','124','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:30.533Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['95','0','142','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"        selected_warnings[i][2] = code_data.get(int(warning_id), {}).get('functionCalls', [])\n        selected_warnings[i] = tuple(selected_warnings[i])\n    \n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            selected_warnings = heuristic_shorter_code_first(selected_warnings)\n        elif heuristic == 2:\n            selected_warnings = heuristic_shared_function_calls(selected_warnings)\n        elif heuristic == 3:\n            selected_warnings = heuristic_neighbor_classes(selected_warnings)\n        elif heuristic == 4:\n            # choose a random heuristic\n            selected_warnings = random.choice([heuristic_shorter_code_first(selected_warnings), heuristic_shared_function_calls(selected_warnings), heuristic_neighbor_classes(selected_warnings)])\n    \n    sorted_warnings_by_length = sorted(selected_warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(selected_warnings)):\n        if selected_warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'positive'\n            selected_warnings[i] = tuple(selected_warnings[i])\n        else:\n            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'negative'\n            selected_warnings[i] = tuple(selected_warnings[i])\n\n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n\n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [selected_warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [selected_warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n\n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n\n    return selected_positive_warnings, selected_negative_warnings\n"],time:'2024-09-08T07:45:30.539Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['95','0','123','55','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:30.566Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['94','0','142','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"        selected_warnings[i][1] = code_data.get(int(warning_id), {}).get('linesOfCode', 0)\n        selected_warnings[i][2] = code_data.get(int(warning_id), {}).get('functionCalls', [])\n        selected_warnings[i] = tuple(selected_warnings[i])\n    \n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            selected_warnings = heuristic_shorter_code_first(selected_warnings)\n        elif heuristic == 2:\n            selected_warnings = heuristic_shared_function_calls(selected_warnings)\n        elif heuristic == 3:\n            selected_warnings = heuristic_neighbor_classes(selected_warnings)\n        elif heuristic == 4:\n            # choose a random heuristic\n            selected_warnings = random.choice([heuristic_shorter_code_first(selected_warnings), heuristic_shared_function_calls(selected_warnings), heuristic_neighbor_classes(selected_warnings)])\n    \n    sorted_warnings_by_length = sorted(selected_warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(selected_warnings)):\n        if selected_warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'positive'\n            selected_warnings[i] = tuple(selected_warnings[i])\n        else:\n            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'negative'\n            selected_warnings[i] = tuple(selected_warnings[i])\n\n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n\n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [selected_warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [selected_warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n\n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n\n    return selected_positive_warnings, selected_negative_warnings\n"],time:'2024-09-08T07:45:30.570Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['94','0','122','72','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:30.583Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['93','0','142','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"        selected_warnings[i] = list(warning)\n        selected_warnings[i][1] = code_data.get(int(warning_id), {}).get('linesOfCode', 0)\n        selected_warnings[i][2] = code_data.get(int(warning_id), {}).get('functionCalls', [])\n        selected_warnings[i] = tuple(selected_warnings[i])\n    \n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            selected_warnings = heuristic_shorter_code_first(selected_warnings)\n        elif heuristic == 2:\n            selected_warnings = heuristic_shared_function_calls(selected_warnings)\n        elif heuristic == 3:\n            selected_warnings = heuristic_neighbor_classes(selected_warnings)\n        elif heuristic == 4:\n            # choose a random heuristic\n            selected_warnings = random.choice([heuristic_shorter_code_first(selected_warnings), heuristic_shared_function_calls(selected_warnings), heuristic_neighbor_classes(selected_warnings)])\n    \n    sorted_warnings_by_length = sorted(selected_warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(selected_warnings)):\n        if selected_warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'positive'\n            selected_warnings[i] = tuple(selected_warnings[i])\n        else:\n            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'negative'\n            selected_warnings[i] = tuple(selected_warnings[i])\n\n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n\n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [selected_warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [selected_warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n\n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n\n    return selected_positive_warnings, selected_negative_warnings\n"],time:'2024-09-08T07:45:30.586Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['93','0','121','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:30.602Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['92','0','142','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"        warning_id = warning[0]\n        selected_warnings[i] = list(warning)\n        selected_warnings[i][1] = code_data.get(int(warning_id), {}).get('linesOfCode', 0)\n        selected_warnings[i][2] = code_data.get(int(warning_id), {}).get('functionCalls', [])\n        selected_warnings[i] = tuple(selected_warnings[i])\n    \n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            selected_warnings = heuristic_shorter_code_first(selected_warnings)\n        elif heuristic == 2:\n            selected_warnings = heuristic_shared_function_calls(selected_warnings)\n        elif heuristic == 3:\n            selected_warnings = heuristic_neighbor_classes(selected_warnings)\n        elif heuristic == 4:\n            # choose a random heuristic\n            selected_warnings = random.choice([heuristic_shorter_code_first(selected_warnings), heuristic_shared_function_calls(selected_warnings), heuristic_neighbor_classes(selected_warnings)])\n    \n    sorted_warnings_by_length = sorted(selected_warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(selected_warnings)):\n        if selected_warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'positive'\n            selected_warnings[i] = tuple(selected_warnings[i])\n        else:\n            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'negative'\n            selected_warnings[i] = tuple(selected_warnings[i])\n\n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n\n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [selected_warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [selected_warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n\n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n\n    return selected_positive_warnings, selected_negative_warnings\n"],time:'2024-09-08T07:45:30.607Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['92','0','120','62','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:30.623Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['91','0','142','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"    for i, warning in enumerate(selected_warnings):\n        warning_id = warning[0]\n        selected_warnings[i] = list(warning)\n        selected_warnings[i][1] = code_data.get(int(warning_id), {}).get('linesOfCode', 0)\n        selected_warnings[i][2] = code_data.get(int(warning_id), {}).get('functionCalls', [])\n        selected_warnings[i] = tuple(selected_warnings[i])\n    \n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            selected_warnings = heuristic_shorter_code_first(selected_warnings)\n        elif heuristic == 2:\n            selected_warnings = heuristic_shared_function_calls(selected_warnings)\n        elif heuristic == 3:\n            selected_warnings = heuristic_neighbor_classes(selected_warnings)\n        elif heuristic == 4:\n            # choose a random heuristic\n            selected_warnings = random.choice([heuristic_shorter_code_first(selected_warnings), heuristic_shared_function_calls(selected_warnings), heuristic_neighbor_classes(selected_warnings)])\n    \n    sorted_warnings_by_length = sorted(selected_warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(selected_warnings)):\n        if selected_warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'positive'\n            selected_warnings[i] = tuple(selected_warnings[i])\n        else:\n            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'negative'\n            selected_warnings[i] = tuple(selected_warnings[i])\n\n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n\n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [selected_warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [selected_warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n\n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n\n    return selected_positive_warnings, selected_negative_warnings\n"],time:'2024-09-08T07:45:30.630Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['91','0','119','48','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:30.650Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['90','0','142','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"    # sort by code length to identify shortest and longest warnings. selected_warnings do not contain the code length find it from warnings\n    for i, warning in enumerate(selected_warnings):\n        warning_id = warning[0]\n        selected_warnings[i] = list(warning)\n        selected_warnings[i][1] = code_data.get(int(warning_id), {}).get('linesOfCode', 0)\n        selected_warnings[i][2] = code_data.get(int(warning_id), {}).get('functionCalls', [])\n        selected_warnings[i] = tuple(selected_warnings[i])\n    \n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            selected_warnings = heuristic_shorter_code_first(selected_warnings)\n        elif heuristic == 2:\n            selected_warnings = heuristic_shared_function_calls(selected_warnings)\n        elif heuristic == 3:\n            selected_warnings = heuristic_neighbor_classes(selected_warnings)\n        elif heuristic == 4:\n            # choose a random heuristic\n            selected_warnings = random.choice([heuristic_shorter_code_first(selected_warnings), heuristic_shared_function_calls(selected_warnings), heuristic_neighbor_classes(selected_warnings)])\n    \n    sorted_warnings_by_length = sorted(selected_warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(selected_warnings)):\n        if selected_warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'positive'\n            selected_warnings[i] = tuple(selected_warnings[i])\n        else:\n            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'negative'\n            selected_warnings[i] = tuple(selected_warnings[i])\n\n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n\n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [selected_warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [selected_warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n\n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n\n    return selected_positive_warnings, selected_negative_warnings\n"],time:'2024-09-08T07:45:30.654Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['90','0','118','61','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:30.691Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['89','0','142','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"    selected_warnings = [(warning, 0, 0, 'uninspected') for warning in selected_warnings]\n    # sort by code length to identify shortest and longest warnings. selected_warnings do not contain the code length find it from warnings\n    for i, warning in enumerate(selected_warnings):\n        warning_id = warning[0]\n        selected_warnings[i] = list(warning)\n        selected_warnings[i][1] = code_data.get(int(warning_id), {}).get('linesOfCode', 0)\n        selected_warnings[i][2] = code_data.get(int(warning_id), {}).get('functionCalls', [])\n        selected_warnings[i] = tuple(selected_warnings[i])\n    \n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            selected_warnings = heuristic_shorter_code_first(selected_warnings)\n        elif heuristic == 2:\n            selected_warnings = heuristic_shared_function_calls(selected_warnings)\n        elif heuristic == 3:\n            selected_warnings = heuristic_neighbor_classes(selected_warnings)\n        elif heuristic == 4:\n            # choose a random heuristic\n            selected_warnings = random.choice([heuristic_shorter_code_first(selected_warnings), heuristic_shared_function_calls(selected_warnings), heuristic_neighbor_classes(selected_warnings)])\n    \n    sorted_warnings_by_length = sorted(selected_warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(selected_warnings)):\n        if selected_warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'positive'\n            selected_warnings[i] = tuple(selected_warnings[i])\n        else:\n            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'negative'\n            selected_warnings[i] = tuple(selected_warnings[i])\n\n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n\n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [selected_warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [selected_warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n\n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n\n    return selected_positive_warnings, selected_negative_warnings\n"],time:'2024-09-08T07:45:30.696Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['89','0','117','13','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:30.703Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['88','0','142','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"    # create the second dim for every item in selected_warnings\n    selected_warnings = [(warning, 0, 0, 'uninspected') for warning in selected_warnings]\n    # sort by code length to identify shortest and longest warnings. selected_warnings do not contain the code length find it from warnings\n    for i, warning in enumerate(selected_warnings):\n        warning_id = warning[0]\n        selected_warnings[i] = list(warning)\n        selected_warnings[i][1] = code_data.get(int(warning_id), {}).get('linesOfCode', 0)\n        selected_warnings[i][2] = code_data.get(int(warning_id), {}).get('functionCalls', [])\n        selected_warnings[i] = tuple(selected_warnings[i])\n    \n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            selected_warnings = heuristic_shorter_code_first(selected_warnings)\n        elif heuristic == 2:\n            selected_warnings = heuristic_shared_function_calls(selected_warnings)\n        elif heuristic == 3:\n            selected_warnings = heuristic_neighbor_classes(selected_warnings)\n        elif heuristic == 4:\n            # choose a random heuristic\n            selected_warnings = random.choice([heuristic_shorter_code_first(selected_warnings), heuristic_shared_function_calls(selected_warnings), heuristic_neighbor_classes(selected_warnings)])\n    \n    sorted_warnings_by_length = sorted(selected_warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(selected_warnings)):\n        if selected_warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'positive'\n            selected_warnings[i] = tuple(selected_warnings[i])\n        else:\n            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'negative'\n            selected_warnings[i] = tuple(selected_warnings[i])\n\n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n\n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [selected_warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [selected_warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n\n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n\n    return selected_positive_warnings, selected_negative_warnings\n"],time:'2024-09-08T07:45:30.720Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['88','0','116','62','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:30.737Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['87','0','142','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_pos_with_heuristic(selected_warnings, code_data, warnings_state, apply_heuristics=None):\n    # create the second dim for every item in selected_warnings\n    selected_warnings = [(warning, 0, 0, 'uninspected') for warning in selected_warnings]\n    # sort by code length to identify shortest and longest warnings. selected_warnings do not contain the code length find it from warnings\n    for i, warning in enumerate(selected_warnings):\n        warning_id = warning[0]\n        selected_warnings[i] = list(warning)\n        selected_warnings[i][1] = code_data.get(int(warning_id), {}).get('linesOfCode', 0)\n        selected_warnings[i][2] = code_data.get(int(warning_id), {}).get('functionCalls', [])\n        selected_warnings[i] = tuple(selected_warnings[i])\n    \n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            selected_warnings = heuristic_shorter_code_first(selected_warnings)\n        elif heuristic == 2:\n            selected_warnings = heuristic_shared_function_calls(selected_warnings)\n        elif heuristic == 3:\n            selected_warnings = heuristic_neighbor_classes(selected_warnings)\n        elif heuristic == 4:\n            # choose a random heuristic\n            selected_warnings = random.choice([heuristic_shorter_code_first(selected_warnings), heuristic_shared_function_calls(selected_warnings), heuristic_neighbor_classes(selected_warnings)])\n    \n    sorted_warnings_by_length = sorted(selected_warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(selected_warnings)):\n        if selected_warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'positive'\n            selected_warnings[i] = tuple(selected_warnings[i])\n        else:\n            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'negative'\n            selected_warnings[i] = tuple(selected_warnings[i])\n\n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n\n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [selected_warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [selected_warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n\n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n\n    return selected_positive_warnings, selected_negative_warnings\n"],time:'2024-09-08T07:45:30.741Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['88','0','142','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"    # create the second dim for every item in selected_warnings\n    selected_warnings = [(warning, 0, 0, 'uninspected') for warning in selected_warnings]\n    # sort by code length to identify shortest and longest warnings. selected_warnings do not contain the code length find it from warnings\n    for i, warning in enumerate(selected_warnings):\n        warning_id = warning[0]\n        selected_warnings[i] = list(warning)\n        selected_warnings[i][1] = code_data.get(int(warning_id), {}).get('linesOfCode', 0)\n        selected_warnings[i][2] = code_data.get(int(warning_id), {}).get('functionCalls', [])\n        selected_warnings[i] = tuple(selected_warnings[i])\n    \n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            selected_warnings = heuristic_shorter_code_first(selected_warnings)\n        elif heuristic == 2:\n            selected_warnings = heuristic_shared_function_calls(selected_warnings)\n        elif heuristic == 3:\n            selected_warnings = heuristic_neighbor_classes(selected_warnings)\n        elif heuristic == 4:\n            # choose a random heuristic\n            selected_warnings = random.choice([heuristic_shorter_code_first(selected_warnings), heuristic_shared_function_calls(selected_warnings), heuristic_neighbor_classes(selected_warnings)])\n    \n    sorted_warnings_by_length = sorted(selected_warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(selected_warnings)):\n        if selected_warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'positive'\n            selected_warnings[i] = tuple(selected_warnings[i])\n        else:\n            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'negative'\n            selected_warnings[i] = tuple(selected_warnings[i])\n\n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n\n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [selected_warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [selected_warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n\n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n\n    return selected_positive_warnings, selected_negative_warnings\n"],time:'2024-09-08T07:45:30.766Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['87','0','142','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_pos_with_heuristic(selected_warnings, code_data, warnings_state, apply_heuristics=None):\n    # create the second dim for every item in selected_warnings\n    selected_warnings = [(warning, 0, 0, 'uninspected') for warning in selected_warnings]\n    # sort by code length to identify shortest and longest warnings. selected_warnings do not contain the code length find it from warnings\n    for i, warning in enumerate(selected_warnings):\n        warning_id = warning[0]\n        selected_warnings[i] = list(warning)\n        selected_warnings[i][1] = code_data.get(int(warning_id), {}).get('linesOfCode', 0)\n        selected_warnings[i][2] = code_data.get(int(warning_id), {}).get('functionCalls', [])\n        selected_warnings[i] = tuple(selected_warnings[i])\n    \n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            selected_warnings = heuristic_shorter_code_first(selected_warnings)\n        elif heuristic == 2:\n            selected_warnings = heuristic_shared_function_calls(selected_warnings)\n        elif heuristic == 3:\n            selected_warnings = heuristic_neighbor_classes(selected_warnings)\n        elif heuristic == 4:\n            # choose a random heuristic\n            selected_warnings = random.choice([heuristic_shorter_code_first(selected_warnings), heuristic_shared_function_calls(selected_warnings), heuristic_neighbor_classes(selected_warnings)])\n    \n    sorted_warnings_by_length = sorted(selected_warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(selected_warnings)):\n        if selected_warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'positive'\n            selected_warnings[i] = tuple(selected_warnings[i])\n        else:\n            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'negative'\n            selected_warnings[i] = tuple(selected_warnings[i])\n\n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n\n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [selected_warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [selected_warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n\n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n\n    return selected_positive_warnings, selected_negative_warnings\n"],time:'2024-09-08T07:45:31.273Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['87','0','115','48','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:31.283Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['86','0','142','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"\ndef sample_pos_with_heuristic(selected_warnings, code_data, warnings_state, apply_heuristics=None):\n    # create the second dim for every item in selected_warnings\n    selected_warnings = [(warning, 0, 0, 'uninspected') for warning in selected_warnings]\n    # sort by code length to identify shortest and longest warnings. selected_warnings do not contain the code length find it from warnings\n    for i, warning in enumerate(selected_warnings):\n        warning_id = warning[0]\n        selected_warnings[i] = list(warning)\n        selected_warnings[i][1] = code_data.get(int(warning_id), {}).get('linesOfCode', 0)\n        selected_warnings[i][2] = code_data.get(int(warning_id), {}).get('functionCalls', [])\n        selected_warnings[i] = tuple(selected_warnings[i])\n    \n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            selected_warnings = heuristic_shorter_code_first(selected_warnings)\n        elif heuristic == 2:\n            selected_warnings = heuristic_shared_function_calls(selected_warnings)\n        elif heuristic == 3:\n            selected_warnings = heuristic_neighbor_classes(selected_warnings)\n        elif heuristic == 4:\n            # choose a random heuristic\n            selected_warnings = random.choice([heuristic_shorter_code_first(selected_warnings), heuristic_shared_function_calls(selected_warnings), heuristic_neighbor_classes(selected_warnings)])\n    \n    sorted_warnings_by_length = sorted(selected_warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(selected_warnings)):\n        if selected_warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'positive'\n            selected_warnings[i] = tuple(selected_warnings[i])\n        else:\n            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'negative'\n            selected_warnings[i] = tuple(selected_warnings[i])\n\n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n\n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [selected_warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [selected_warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n\n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n\n    return selected_positive_warnings, selected_negative_warnings\n"],time:'2024-09-08T07:45:31.288Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['86','0','114','61','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:31.304Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['85','0','142','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"    return correct_labels / len(ground_truth) * 100\n\ndef sample_pos_with_heuristic(selected_warnings, code_data, warnings_state, apply_heuristics=None):\n    # create the second dim for every item in selected_warnings\n    selected_warnings = [(warning, 0, 0, 'uninspected') for warning in selected_warnings]\n    # sort by code length to identify shortest and longest warnings. selected_warnings do not contain the code length find it from warnings\n    for i, warning in enumerate(selected_warnings):\n        warning_id = warning[0]\n        selected_warnings[i] = list(warning)\n        selected_warnings[i][1] = code_data.get(int(warning_id), {}).get('linesOfCode', 0)\n        selected_warnings[i][2] = code_data.get(int(warning_id), {}).get('functionCalls', [])\n        selected_warnings[i] = tuple(selected_warnings[i])\n    \n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            selected_warnings = heuristic_shorter_code_first(selected_warnings)\n        elif heuristic == 2:\n            selected_warnings = heuristic_shared_function_calls(selected_warnings)\n        elif heuristic == 3:\n            selected_warnings = heuristic_neighbor_classes(selected_warnings)\n        elif heuristic == 4:\n            # choose a random heuristic\n            selected_warnings = random.choice([heuristic_shorter_code_first(selected_warnings), heuristic_shared_function_calls(selected_warnings), heuristic_neighbor_classes(selected_warnings)])\n    \n    sorted_warnings_by_length = sorted(selected_warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(selected_warnings)):\n        if selected_warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'positive'\n            selected_warnings[i] = tuple(selected_warnings[i])\n        else:\n            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'negative'\n            selected_warnings[i] = tuple(selected_warnings[i])\n\n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n\n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [selected_warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [selected_warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n\n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n\n    return selected_positive_warnings, selected_negative_warnings\n"],time:'2024-09-08T07:45:31.309Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['85','0','113','97','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:31.333Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['84','0','142','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"    correct_labels = sum(1 for k, v in warnings_state.items() if v == ground_truth[k])\n    return correct_labels / len(ground_truth) * 100\n\ndef sample_pos_with_heuristic(selected_warnings, code_data, warnings_state, apply_heuristics=None):\n    # create the second dim for every item in selected_warnings\n    selected_warnings = [(warning, 0, 0, 'uninspected') for warning in selected_warnings]\n    # sort by code length to identify shortest and longest warnings. selected_warnings do not contain the code length find it from warnings\n    for i, warning in enumerate(selected_warnings):\n        warning_id = warning[0]\n        selected_warnings[i] = list(warning)\n        selected_warnings[i][1] = code_data.get(int(warning_id), {}).get('linesOfCode', 0)\n        selected_warnings[i][2] = code_data.get(int(warning_id), {}).get('functionCalls', [])\n        selected_warnings[i] = tuple(selected_warnings[i])\n    \n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            selected_warnings = heuristic_shorter_code_first(selected_warnings)\n        elif heuristic == 2:\n            selected_warnings = heuristic_shared_function_calls(selected_warnings)\n        elif heuristic == 3:\n            selected_warnings = heuristic_neighbor_classes(selected_warnings)\n        elif heuristic == 4:\n            # choose a random heuristic\n            selected_warnings = random.choice([heuristic_shorter_code_first(selected_warnings), heuristic_shared_function_calls(selected_warnings), heuristic_neighbor_classes(selected_warnings)])\n    \n    sorted_warnings_by_length = sorted(selected_warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(selected_warnings)):\n        if selected_warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'positive'\n            selected_warnings[i] = tuple(selected_warnings[i])\n        else:\n            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'negative'\n            selected_warnings[i] = tuple(selected_warnings[i])\n\n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n\n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [selected_warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [selected_warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n\n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n\n    return selected_positive_warnings, selected_negative_warnings\n"],time:'2024-09-08T07:45:31.337Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['84','0','112','43','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:31.349Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['83','0','142','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"    \"\"\"Calculate the accuracy by comparing the current state of warnings with the ground truth.\"\"\"\n    correct_labels = sum(1 for k, v in warnings_state.items() if v == ground_truth[k])\n    return correct_labels / len(ground_truth) * 100\n\ndef sample_pos_with_heuristic(selected_warnings, code_data, warnings_state, apply_heuristics=None):\n    # create the second dim for every item in selected_warnings\n    selected_warnings = [(warning, 0, 0, 'uninspected') for warning in selected_warnings]\n    # sort by code length to identify shortest and longest warnings. selected_warnings do not contain the code length find it from warnings\n    for i, warning in enumerate(selected_warnings):\n        warning_id = warning[0]\n        selected_warnings[i] = list(warning)\n        selected_warnings[i][1] = code_data.get(int(warning_id), {}).get('linesOfCode', 0)\n        selected_warnings[i][2] = code_data.get(int(warning_id), {}).get('functionCalls', [])\n        selected_warnings[i] = tuple(selected_warnings[i])\n    \n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            selected_warnings = heuristic_shorter_code_first(selected_warnings)\n        elif heuristic == 2:\n            selected_warnings = heuristic_shared_function_calls(selected_warnings)\n        elif heuristic == 3:\n            selected_warnings = heuristic_neighbor_classes(selected_warnings)\n        elif heuristic == 4:\n            # choose a random heuristic\n            selected_warnings = random.choice([heuristic_shorter_code_first(selected_warnings), heuristic_shared_function_calls(selected_warnings), heuristic_neighbor_classes(selected_warnings)])\n    \n    sorted_warnings_by_length = sorted(selected_warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(selected_warnings)):\n        if selected_warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'positive'\n            selected_warnings[i] = tuple(selected_warnings[i])\n        else:\n            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'negative'\n            selected_warnings[i] = tuple(selected_warnings[i])\n\n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n\n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [selected_warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [selected_warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n\n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n\n    return selected_positive_warnings, selected_negative_warnings\n"],time:'2024-09-08T07:45:31.353Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['83','0','111','169','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:31.383Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['82','0','142','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def calculate_accuracy(warnings_state, ground_truth):\n    \"\"\"Calculate the accuracy by comparing the current state of warnings with the ground truth.\"\"\"\n    correct_labels = sum(1 for k, v in warnings_state.items() if v == ground_truth[k])\n    return correct_labels / len(ground_truth) * 100\n\ndef sample_pos_with_heuristic(selected_warnings, code_data, warnings_state, apply_heuristics=None):\n    # create the second dim for every item in selected_warnings\n    selected_warnings = [(warning, 0, 0, 'uninspected') for warning in selected_warnings]\n    # sort by code length to identify shortest and longest warnings. selected_warnings do not contain the code length find it from warnings\n    for i, warning in enumerate(selected_warnings):\n        warning_id = warning[0]\n        selected_warnings[i] = list(warning)\n        selected_warnings[i][1] = code_data.get(int(warning_id), {}).get('linesOfCode', 0)\n        selected_warnings[i][2] = code_data.get(int(warning_id), {}).get('functionCalls', [])\n        selected_warnings[i] = tuple(selected_warnings[i])\n    \n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            selected_warnings = heuristic_shorter_code_first(selected_warnings)\n        elif heuristic == 2:\n            selected_warnings = heuristic_shared_function_calls(selected_warnings)\n        elif heuristic == 3:\n            selected_warnings = heuristic_neighbor_classes(selected_warnings)\n        elif heuristic == 4:\n            # choose a random heuristic\n            selected_warnings = random.choice([heuristic_shorter_code_first(selected_warnings), heuristic_shared_function_calls(selected_warnings), heuristic_neighbor_classes(selected_warnings)])\n    \n    sorted_warnings_by_length = sorted(selected_warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(selected_warnings)):\n        if selected_warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'positive'\n            selected_warnings[i] = tuple(selected_warnings[i])\n        else:\n            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'negative'\n            selected_warnings[i] = tuple(selected_warnings[i])\n\n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n\n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [selected_warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [selected_warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n\n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n\n    return selected_positive_warnings, selected_negative_warnings\n"],time:'2024-09-08T07:45:31.386Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['82','0','110','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:31.399Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['81','0','142','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"\ndef calculate_accuracy(warnings_state, ground_truth):\n    \"\"\"Calculate the accuracy by comparing the current state of warnings with the ground truth.\"\"\"\n    correct_labels = sum(1 for k, v in warnings_state.items() if v == ground_truth[k])\n    return correct_labels / len(ground_truth) * 100\n\ndef sample_pos_with_heuristic(selected_warnings, code_data, warnings_state, apply_heuristics=None):\n    # create the second dim for every item in selected_warnings\n    selected_warnings = [(warning, 0, 0, 'uninspected') for warning in selected_warnings]\n    # sort by code length to identify shortest and longest warnings. selected_warnings do not contain the code length find it from warnings\n    for i, warning in enumerate(selected_warnings):\n        warning_id = warning[0]\n        selected_warnings[i] = list(warning)\n        selected_warnings[i][1] = code_data.get(int(warning_id), {}).get('linesOfCode', 0)\n        selected_warnings[i][2] = code_data.get(int(warning_id), {}).get('functionCalls', [])\n        selected_warnings[i] = tuple(selected_warnings[i])\n    \n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            selected_warnings = heuristic_shorter_code_first(selected_warnings)\n        elif heuristic == 2:\n            selected_warnings = heuristic_shared_function_calls(selected_warnings)\n        elif heuristic == 3:\n            selected_warnings = heuristic_neighbor_classes(selected_warnings)\n        elif heuristic == 4:\n            # choose a random heuristic\n            selected_warnings = random.choice([heuristic_shorter_code_first(selected_warnings), heuristic_shared_function_calls(selected_warnings), heuristic_neighbor_classes(selected_warnings)])\n    \n    sorted_warnings_by_length = sorted(selected_warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(selected_warnings)):\n        if selected_warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'positive'\n            selected_warnings[i] = tuple(selected_warnings[i])\n        else:\n            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'negative'\n            selected_warnings[i] = tuple(selected_warnings[i])\n\n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n\n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [selected_warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [selected_warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n\n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n\n    return selected_positive_warnings, selected_negative_warnings\n"],time:'2024-09-08T07:45:31.402Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['81','0','109','77','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:31.415Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['80','0','142','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"    return {k: 'uninspected' for k in ground_truth.keys()}\n\ndef calculate_accuracy(warnings_state, ground_truth):\n    \"\"\"Calculate the accuracy by comparing the current state of warnings with the ground truth.\"\"\"\n    correct_labels = sum(1 for k, v in warnings_state.items() if v == ground_truth[k])\n    return correct_labels / len(ground_truth) * 100\n\ndef sample_pos_with_heuristic(selected_warnings, code_data, warnings_state, apply_heuristics=None):\n    # create the second dim for every item in selected_warnings\n    selected_warnings = [(warning, 0, 0, 'uninspected') for warning in selected_warnings]\n    # sort by code length to identify shortest and longest warnings. selected_warnings do not contain the code length find it from warnings\n    for i, warning in enumerate(selected_warnings):\n        warning_id = warning[0]\n        selected_warnings[i] = list(warning)\n        selected_warnings[i][1] = code_data.get(int(warning_id), {}).get('linesOfCode', 0)\n        selected_warnings[i][2] = code_data.get(int(warning_id), {}).get('functionCalls', [])\n        selected_warnings[i] = tuple(selected_warnings[i])\n    \n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            selected_warnings = heuristic_shorter_code_first(selected_warnings)\n        elif heuristic == 2:\n            selected_warnings = heuristic_shared_function_calls(selected_warnings)\n        elif heuristic == 3:\n            selected_warnings = heuristic_neighbor_classes(selected_warnings)\n        elif heuristic == 4:\n            # choose a random heuristic\n            selected_warnings = random.choice([heuristic_shorter_code_first(selected_warnings), heuristic_shared_function_calls(selected_warnings), heuristic_neighbor_classes(selected_warnings)])\n    \n    sorted_warnings_by_length = sorted(selected_warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(selected_warnings)):\n        if selected_warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'positive'\n            selected_warnings[i] = tuple(selected_warnings[i])\n        else:\n            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'negative'\n            selected_warnings[i] = tuple(selected_warnings[i])\n\n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n\n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [selected_warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [selected_warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n\n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n\n    return selected_positive_warnings, selected_negative_warnings\n"],time:'2024-09-08T07:45:31.421Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['80','0','108','4','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:31.449Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['79','0','142','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"    \"\"\"Initialize all warnings with the state 'uninspected'.\"\"\"\n    return {k: 'uninspected' for k in ground_truth.keys()}\n\ndef calculate_accuracy(warnings_state, ground_truth):\n    \"\"\"Calculate the accuracy by comparing the current state of warnings with the ground truth.\"\"\"\n    correct_labels = sum(1 for k, v in warnings_state.items() if v == ground_truth[k])\n    return correct_labels / len(ground_truth) * 100\n\ndef sample_pos_with_heuristic(selected_warnings, code_data, warnings_state, apply_heuristics=None):\n    # create the second dim for every item in selected_warnings\n    selected_warnings = [(warning, 0, 0, 'uninspected') for warning in selected_warnings]\n    # sort by code length to identify shortest and longest warnings. selected_warnings do not contain the code length find it from warnings\n    for i, warning in enumerate(selected_warnings):\n        warning_id = warning[0]\n        selected_warnings[i] = list(warning)\n        selected_warnings[i][1] = code_data.get(int(warning_id), {}).get('linesOfCode', 0)\n        selected_warnings[i][2] = code_data.get(int(warning_id), {}).get('functionCalls', [])\n        selected_warnings[i] = tuple(selected_warnings[i])\n    \n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            selected_warnings = heuristic_shorter_code_first(selected_warnings)\n        elif heuristic == 2:\n            selected_warnings = heuristic_shared_function_calls(selected_warnings)\n        elif heuristic == 3:\n            selected_warnings = heuristic_neighbor_classes(selected_warnings)\n        elif heuristic == 4:\n            # choose a random heuristic\n            selected_warnings = random.choice([heuristic_shorter_code_first(selected_warnings), heuristic_shared_function_calls(selected_warnings), heuristic_neighbor_classes(selected_warnings)])\n    \n    sorted_warnings_by_length = sorted(selected_warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(selected_warnings)):\n        if selected_warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'positive'\n            selected_warnings[i] = tuple(selected_warnings[i])\n        else:\n            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'negative'\n            selected_warnings[i] = tuple(selected_warnings[i])\n\n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n\n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [selected_warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [selected_warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n\n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n\n    return selected_positive_warnings, selected_negative_warnings\n"],time:'2024-09-08T07:45:31.453Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['79','0','107','195','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:31.465Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['78','0','142','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def initialize_warnings_state(ground_truth):\n    \"\"\"Initialize all warnings with the state 'uninspected'.\"\"\"\n    return {k: 'uninspected' for k in ground_truth.keys()}\n\ndef calculate_accuracy(warnings_state, ground_truth):\n    \"\"\"Calculate the accuracy by comparing the current state of warnings with the ground truth.\"\"\"\n    correct_labels = sum(1 for k, v in warnings_state.items() if v == ground_truth[k])\n    return correct_labels / len(ground_truth) * 100\n\ndef sample_pos_with_heuristic(selected_warnings, code_data, warnings_state, apply_heuristics=None):\n    # create the second dim for every item in selected_warnings\n    selected_warnings = [(warning, 0, 0, 'uninspected') for warning in selected_warnings]\n    # sort by code length to identify shortest and longest warnings. selected_warnings do not contain the code length find it from warnings\n    for i, warning in enumerate(selected_warnings):\n        warning_id = warning[0]\n        selected_warnings[i] = list(warning)\n        selected_warnings[i][1] = code_data.get(int(warning_id), {}).get('linesOfCode', 0)\n        selected_warnings[i][2] = code_data.get(int(warning_id), {}).get('functionCalls', [])\n        selected_warnings[i] = tuple(selected_warnings[i])\n    \n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            selected_warnings = heuristic_shorter_code_first(selected_warnings)\n        elif heuristic == 2:\n            selected_warnings = heuristic_shared_function_calls(selected_warnings)\n        elif heuristic == 3:\n            selected_warnings = heuristic_neighbor_classes(selected_warnings)\n        elif heuristic == 4:\n            # choose a random heuristic\n            selected_warnings = random.choice([heuristic_shorter_code_first(selected_warnings), heuristic_shared_function_calls(selected_warnings), heuristic_neighbor_classes(selected_warnings)])\n    \n    sorted_warnings_by_length = sorted(selected_warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(selected_warnings)):\n        if selected_warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'positive'\n            selected_warnings[i] = tuple(selected_warnings[i])\n        else:\n            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'negative'\n            selected_warnings[i] = tuple(selected_warnings[i])\n\n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n\n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [selected_warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [selected_warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n\n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n\n    return selected_positive_warnings, selected_negative_warnings\n"],time:'2024-09-08T07:45:31.468Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['78','0','106','39','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:31.482Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['77','0','142','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"\ndef initialize_warnings_state(ground_truth):\n    \"\"\"Initialize all warnings with the state 'uninspected'.\"\"\"\n    return {k: 'uninspected' for k in ground_truth.keys()}\n\ndef calculate_accuracy(warnings_state, ground_truth):\n    \"\"\"Calculate the accuracy by comparing the current state of warnings with the ground truth.\"\"\"\n    correct_labels = sum(1 for k, v in warnings_state.items() if v == ground_truth[k])\n    return correct_labels / len(ground_truth) * 100\n\ndef sample_pos_with_heuristic(selected_warnings, code_data, warnings_state, apply_heuristics=None):\n    # create the second dim for every item in selected_warnings\n    selected_warnings = [(warning, 0, 0, 'uninspected') for warning in selected_warnings]\n    # sort by code length to identify shortest and longest warnings. selected_warnings do not contain the code length find it from warnings\n    for i, warning in enumerate(selected_warnings):\n        warning_id = warning[0]\n        selected_warnings[i] = list(warning)\n        selected_warnings[i][1] = code_data.get(int(warning_id), {}).get('linesOfCode', 0)\n        selected_warnings[i][2] = code_data.get(int(warning_id), {}).get('functionCalls', [])\n        selected_warnings[i] = tuple(selected_warnings[i])\n    \n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            selected_warnings = heuristic_shorter_code_first(selected_warnings)\n        elif heuristic == 2:\n            selected_warnings = heuristic_shared_function_calls(selected_warnings)\n        elif heuristic == 3:\n            selected_warnings = heuristic_neighbor_classes(selected_warnings)\n        elif heuristic == 4:\n            # choose a random heuristic\n            selected_warnings = random.choice([heuristic_shorter_code_first(selected_warnings), heuristic_shared_function_calls(selected_warnings), heuristic_neighbor_classes(selected_warnings)])\n    \n    sorted_warnings_by_length = sorted(selected_warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(selected_warnings)):\n        if selected_warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'positive'\n            selected_warnings[i] = tuple(selected_warnings[i])\n        else:\n            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'negative'\n            selected_warnings[i] = tuple(selected_warnings[i])\n\n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n\n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [selected_warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [selected_warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n\n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n\n    return selected_positive_warnings, selected_negative_warnings\n"],time:'2024-09-08T07:45:31.485Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['77','0','105','28','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:31.516Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['76','0','142','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"    return sorted_warnings\n\ndef initialize_warnings_state(ground_truth):\n    \"\"\"Initialize all warnings with the state 'uninspected'.\"\"\"\n    return {k: 'uninspected' for k in ground_truth.keys()}\n\ndef calculate_accuracy(warnings_state, ground_truth):\n    \"\"\"Calculate the accuracy by comparing the current state of warnings with the ground truth.\"\"\"\n    correct_labels = sum(1 for k, v in warnings_state.items() if v == ground_truth[k])\n    return correct_labels / len(ground_truth) * 100\n\ndef sample_pos_with_heuristic(selected_warnings, code_data, warnings_state, apply_heuristics=None):\n    # create the second dim for every item in selected_warnings\n    selected_warnings = [(warning, 0, 0, 'uninspected') for warning in selected_warnings]\n    # sort by code length to identify shortest and longest warnings. selected_warnings do not contain the code length find it from warnings\n    for i, warning in enumerate(selected_warnings):\n        warning_id = warning[0]\n        selected_warnings[i] = list(warning)\n        selected_warnings[i][1] = code_data.get(int(warning_id), {}).get('linesOfCode', 0)\n        selected_warnings[i][2] = code_data.get(int(warning_id), {}).get('functionCalls', [])\n        selected_warnings[i] = tuple(selected_warnings[i])\n    \n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            selected_warnings = heuristic_shorter_code_first(selected_warnings)\n        elif heuristic == 2:\n            selected_warnings = heuristic_shared_function_calls(selected_warnings)\n        elif heuristic == 3:\n            selected_warnings = heuristic_neighbor_classes(selected_warnings)\n        elif heuristic == 4:\n            # choose a random heuristic\n            selected_warnings = random.choice([heuristic_shorter_code_first(selected_warnings), heuristic_shared_function_calls(selected_warnings), heuristic_neighbor_classes(selected_warnings)])\n    \n    sorted_warnings_by_length = sorted(selected_warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(selected_warnings)):\n        if selected_warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'positive'\n            selected_warnings[i] = tuple(selected_warnings[i])\n        else:\n            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'negative'\n            selected_warnings[i] = tuple(selected_warnings[i])\n\n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n\n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [selected_warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [selected_warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n\n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n\n    return selected_positive_warnings, selected_negative_warnings\n"],time:'2024-09-08T07:45:31.519Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['76','0','104','77','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:31.532Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['75','0','142','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"    \n    return sorted_warnings\n\ndef initialize_warnings_state(ground_truth):\n    \"\"\"Initialize all warnings with the state 'uninspected'.\"\"\"\n    return {k: 'uninspected' for k in ground_truth.keys()}\n\ndef calculate_accuracy(warnings_state, ground_truth):\n    \"\"\"Calculate the accuracy by comparing the current state of warnings with the ground truth.\"\"\"\n    correct_labels = sum(1 for k, v in warnings_state.items() if v == ground_truth[k])\n    return correct_labels / len(ground_truth) * 100\n\ndef sample_pos_with_heuristic(selected_warnings, code_data, warnings_state, apply_heuristics=None):\n    # create the second dim for every item in selected_warnings\n    selected_warnings = [(warning, 0, 0, 'uninspected') for warning in selected_warnings]\n    # sort by code length to identify shortest and longest warnings. selected_warnings do not contain the code length find it from warnings\n    for i, warning in enumerate(selected_warnings):\n        warning_id = warning[0]\n        selected_warnings[i] = list(warning)\n        selected_warnings[i][1] = code_data.get(int(warning_id), {}).get('linesOfCode', 0)\n        selected_warnings[i][2] = code_data.get(int(warning_id), {}).get('functionCalls', [])\n        selected_warnings[i] = tuple(selected_warnings[i])\n    \n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            selected_warnings = heuristic_shorter_code_first(selected_warnings)\n        elif heuristic == 2:\n            selected_warnings = heuristic_shared_function_calls(selected_warnings)\n        elif heuristic == 3:\n            selected_warnings = heuristic_neighbor_classes(selected_warnings)\n        elif heuristic == 4:\n            # choose a random heuristic\n            selected_warnings = random.choice([heuristic_shorter_code_first(selected_warnings), heuristic_shared_function_calls(selected_warnings), heuristic_neighbor_classes(selected_warnings)])\n    \n    sorted_warnings_by_length = sorted(selected_warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(selected_warnings)):\n        if selected_warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'positive'\n            selected_warnings[i] = tuple(selected_warnings[i])\n        else:\n            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'negative'\n            selected_warnings[i] = tuple(selected_warnings[i])\n\n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n\n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [selected_warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [selected_warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n\n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n\n    return selected_positive_warnings, selected_negative_warnings\n"],time:'2024-09-08T07:45:31.535Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['75','0','103','28','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:31.549Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['74','0','142','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"            processed_locs.add(loc)\n    \n    return sorted_warnings\n\ndef initialize_warnings_state(ground_truth):\n    \"\"\"Initialize all warnings with the state 'uninspected'.\"\"\"\n    return {k: 'uninspected' for k in ground_truth.keys()}\n\ndef calculate_accuracy(warnings_state, ground_truth):\n    \"\"\"Calculate the accuracy by comparing the current state of warnings with the ground truth.\"\"\"\n    correct_labels = sum(1 for k, v in warnings_state.items() if v == ground_truth[k])\n    return correct_labels / len(ground_truth) * 100\n\ndef sample_pos_with_heuristic(selected_warnings, code_data, warnings_state, apply_heuristics=None):\n    # create the second dim for every item in selected_warnings\n    selected_warnings = [(warning, 0, 0, 'uninspected') for warning in selected_warnings]\n    # sort by code length to identify shortest and longest warnings. selected_warnings do not contain the code length find it from warnings\n    for i, warning in enumerate(selected_warnings):\n        warning_id = warning[0]\n        selected_warnings[i] = list(warning)\n        selected_warnings[i][1] = code_data.get(int(warning_id), {}).get('linesOfCode', 0)\n        selected_warnings[i][2] = code_data.get(int(warning_id), {}).get('functionCalls', [])\n        selected_warnings[i] = tuple(selected_warnings[i])\n    \n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            selected_warnings = heuristic_shorter_code_first(selected_warnings)\n        elif heuristic == 2:\n            selected_warnings = heuristic_shared_function_calls(selected_warnings)\n        elif heuristic == 3:\n            selected_warnings = heuristic_neighbor_classes(selected_warnings)\n        elif heuristic == 4:\n            # choose a random heuristic\n            selected_warnings = random.choice([heuristic_shorter_code_first(selected_warnings), heuristic_shared_function_calls(selected_warnings), heuristic_neighbor_classes(selected_warnings)])\n    \n    sorted_warnings_by_length = sorted(selected_warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(selected_warnings)):\n        if selected_warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'positive'\n            selected_warnings[i] = tuple(selected_warnings[i])\n        else:\n            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'negative'\n            selected_warnings[i] = tuple(selected_warnings[i])\n\n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n\n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [selected_warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [selected_warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n\n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n\n    return selected_positive_warnings, selected_negative_warnings\n"],time:'2024-09-08T07:45:31.553Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['74','0','102','82','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:31.583Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['73','0','142','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"            sorted_warnings.extend(same_loc_warnings)\n            processed_locs.add(loc)\n    \n    return sorted_warnings\n\ndef initialize_warnings_state(ground_truth):\n    \"\"\"Initialize all warnings with the state 'uninspected'.\"\"\"\n    return {k: 'uninspected' for k in ground_truth.keys()}\n\ndef calculate_accuracy(warnings_state, ground_truth):\n    \"\"\"Calculate the accuracy by comparing the current state of warnings with the ground truth.\"\"\"\n    correct_labels = sum(1 for k, v in warnings_state.items() if v == ground_truth[k])\n    return correct_labels / len(ground_truth) * 100\n\ndef sample_pos_with_heuristic(selected_warnings, code_data, warnings_state, apply_heuristics=None):\n    # create the second dim for every item in selected_warnings\n    selected_warnings = [(warning, 0, 0, 'uninspected') for warning in selected_warnings]\n    # sort by code length to identify shortest and longest warnings. selected_warnings do not contain the code length find it from warnings\n    for i, warning in enumerate(selected_warnings):\n        warning_id = warning[0]\n        selected_warnings[i] = list(warning)\n        selected_warnings[i][1] = code_data.get(int(warning_id), {}).get('linesOfCode', 0)\n        selected_warnings[i][2] = code_data.get(int(warning_id), {}).get('functionCalls', [])\n        selected_warnings[i] = tuple(selected_warnings[i])\n    \n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            selected_warnings = heuristic_shorter_code_first(selected_warnings)\n        elif heuristic == 2:\n            selected_warnings = heuristic_shared_function_calls(selected_warnings)\n        elif heuristic == 3:\n            selected_warnings = heuristic_neighbor_classes(selected_warnings)\n        elif heuristic == 4:\n            # choose a random heuristic\n            selected_warnings = random.choice([heuristic_shorter_code_first(selected_warnings), heuristic_shared_function_calls(selected_warnings), heuristic_neighbor_classes(selected_warnings)])\n    \n    sorted_warnings_by_length = sorted(selected_warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(selected_warnings)):\n        if selected_warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'positive'\n            selected_warnings[i] = tuple(selected_warnings[i])\n        else:\n            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'negative'\n            selected_warnings[i] = tuple(selected_warnings[i])\n\n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n\n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [selected_warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [selected_warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n\n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n\n    return selected_positive_warnings, selected_negative_warnings\n"],time:'2024-09-08T07:45:31.586Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['73','0','101','28','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:31.599Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['72','0','142','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"            same_loc_warnings = [warnings[j] for j in range(i, len(warnings)) if containment.get(int(warnings[j][0])) == loc]\n            sorted_warnings.extend(same_loc_warnings)\n            processed_locs.add(loc)\n    \n    return sorted_warnings\n\ndef initialize_warnings_state(ground_truth):\n    \"\"\"Initialize all warnings with the state 'uninspected'.\"\"\"\n    return {k: 'uninspected' for k in ground_truth.keys()}\n\ndef calculate_accuracy(warnings_state, ground_truth):\n    \"\"\"Calculate the accuracy by comparing the current state of warnings with the ground truth.\"\"\"\n    correct_labels = sum(1 for k, v in warnings_state.items() if v == ground_truth[k])\n    return correct_labels / len(ground_truth) * 100\n\ndef sample_pos_with_heuristic(selected_warnings, code_data, warnings_state, apply_heuristics=None):\n    # create the second dim for every item in selected_warnings\n    selected_warnings = [(warning, 0, 0, 'uninspected') for warning in selected_warnings]\n    # sort by code length to identify shortest and longest warnings. selected_warnings do not contain the code length find it from warnings\n    for i, warning in enumerate(selected_warnings):\n        warning_id = warning[0]\n        selected_warnings[i] = list(warning)\n        selected_warnings[i][1] = code_data.get(int(warning_id), {}).get('linesOfCode', 0)\n        selected_warnings[i][2] = code_data.get(int(warning_id), {}).get('functionCalls', [])\n        selected_warnings[i] = tuple(selected_warnings[i])\n    \n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            selected_warnings = heuristic_shorter_code_first(selected_warnings)\n        elif heuristic == 2:\n            selected_warnings = heuristic_shared_function_calls(selected_warnings)\n        elif heuristic == 3:\n            selected_warnings = heuristic_neighbor_classes(selected_warnings)\n        elif heuristic == 4:\n            # choose a random heuristic\n            selected_warnings = random.choice([heuristic_shorter_code_first(selected_warnings), heuristic_shared_function_calls(selected_warnings), heuristic_neighbor_classes(selected_warnings)])\n    \n    sorted_warnings_by_length = sorted(selected_warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(selected_warnings)):\n        if selected_warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'positive'\n            selected_warnings[i] = tuple(selected_warnings[i])\n        else:\n            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'negative'\n            selected_warnings[i] = tuple(selected_warnings[i])\n\n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n\n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [selected_warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [selected_warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n\n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n\n    return selected_positive_warnings, selected_negative_warnings\n"],time:'2024-09-08T07:45:31.603Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['72','0','100','79','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:31.616Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['71','0','142','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"            # Find all warnings with the same location\n            same_loc_warnings = [warnings[j] for j in range(i, len(warnings)) if containment.get(int(warnings[j][0])) == loc]\n            sorted_warnings.extend(same_loc_warnings)\n            processed_locs.add(loc)\n    \n    return sorted_warnings\n\ndef initialize_warnings_state(ground_truth):\n    \"\"\"Initialize all warnings with the state 'uninspected'.\"\"\"\n    return {k: 'uninspected' for k in ground_truth.keys()}\n\ndef calculate_accuracy(warnings_state, ground_truth):\n    \"\"\"Calculate the accuracy by comparing the current state of warnings with the ground truth.\"\"\"\n    correct_labels = sum(1 for k, v in warnings_state.items() if v == ground_truth[k])\n    return correct_labels / len(ground_truth) * 100\n\ndef sample_pos_with_heuristic(selected_warnings, code_data, warnings_state, apply_heuristics=None):\n    # create the second dim for every item in selected_warnings\n    selected_warnings = [(warning, 0, 0, 'uninspected') for warning in selected_warnings]\n    # sort by code length to identify shortest and longest warnings. selected_warnings do not contain the code length find it from warnings\n    for i, warning in enumerate(selected_warnings):\n        warning_id = warning[0]\n        selected_warnings[i] = list(warning)\n        selected_warnings[i][1] = code_data.get(int(warning_id), {}).get('linesOfCode', 0)\n        selected_warnings[i][2] = code_data.get(int(warning_id), {}).get('functionCalls', [])\n        selected_warnings[i] = tuple(selected_warnings[i])\n    \n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            selected_warnings = heuristic_shorter_code_first(selected_warnings)\n        elif heuristic == 2:\n            selected_warnings = heuristic_shared_function_calls(selected_warnings)\n        elif heuristic == 3:\n            selected_warnings = heuristic_neighbor_classes(selected_warnings)\n        elif heuristic == 4:\n            # choose a random heuristic\n            selected_warnings = random.choice([heuristic_shorter_code_first(selected_warnings), heuristic_shared_function_calls(selected_warnings), heuristic_neighbor_classes(selected_warnings)])\n    \n    sorted_warnings_by_length = sorted(selected_warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(selected_warnings)):\n        if selected_warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'positive'\n            selected_warnings[i] = tuple(selected_warnings[i])\n        else:\n            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'negative'\n            selected_warnings[i] = tuple(selected_warnings[i])\n\n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n\n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [selected_warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [selected_warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n\n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n\n    return selected_positive_warnings, selected_negative_warnings\n"],time:'2024-09-08T07:45:31.619Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['71','0','99','26','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:31.650Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['70','0','142','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"        if loc not in processed_locs:\n            # Find all warnings with the same location\n            same_loc_warnings = [warnings[j] for j in range(i, len(warnings)) if containment.get(int(warnings[j][0])) == loc]\n            sorted_warnings.extend(same_loc_warnings)\n            processed_locs.add(loc)\n    \n    return sorted_warnings\n\ndef initialize_warnings_state(ground_truth):\n    \"\"\"Initialize all warnings with the state 'uninspected'.\"\"\"\n    return {k: 'uninspected' for k in ground_truth.keys()}\n\ndef calculate_accuracy(warnings_state, ground_truth):\n    \"\"\"Calculate the accuracy by comparing the current state of warnings with the ground truth.\"\"\"\n    correct_labels = sum(1 for k, v in warnings_state.items() if v == ground_truth[k])\n    return correct_labels / len(ground_truth) * 100\n\ndef sample_pos_with_heuristic(selected_warnings, code_data, warnings_state, apply_heuristics=None):\n    # create the second dim for every item in selected_warnings\n    selected_warnings = [(warning, 0, 0, 'uninspected') for warning in selected_warnings]\n    # sort by code length to identify shortest and longest warnings. selected_warnings do not contain the code length find it from warnings\n    for i, warning in enumerate(selected_warnings):\n        warning_id = warning[0]\n        selected_warnings[i] = list(warning)\n        selected_warnings[i][1] = code_data.get(int(warning_id), {}).get('linesOfCode', 0)\n        selected_warnings[i][2] = code_data.get(int(warning_id), {}).get('functionCalls', [])\n        selected_warnings[i] = tuple(selected_warnings[i])\n    \n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            selected_warnings = heuristic_shorter_code_first(selected_warnings)\n        elif heuristic == 2:\n            selected_warnings = heuristic_shared_function_calls(selected_warnings)\n        elif heuristic == 3:\n            selected_warnings = heuristic_neighbor_classes(selected_warnings)\n        elif heuristic == 4:\n            # choose a random heuristic\n            selected_warnings = random.choice([heuristic_shorter_code_first(selected_warnings), heuristic_shared_function_calls(selected_warnings), heuristic_neighbor_classes(selected_warnings)])\n    \n    sorted_warnings_by_length = sorted(selected_warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(selected_warnings)):\n        if selected_warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'positive'\n            selected_warnings[i] = tuple(selected_warnings[i])\n        else:\n            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'negative'\n            selected_warnings[i] = tuple(selected_warnings[i])\n\n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n\n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [selected_warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [selected_warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n\n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n\n    return selected_positive_warnings, selected_negative_warnings\n"],time:'2024-09-08T07:45:31.653Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['71','0','142','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"            # Find all warnings with the same location\n            same_loc_warnings = [warnings[j] for j in range(i, len(warnings)) if containment.get(int(warnings[j][0])) == loc]\n            sorted_warnings.extend(same_loc_warnings)\n            processed_locs.add(loc)\n    \n    return sorted_warnings\n\ndef initialize_warnings_state(ground_truth):\n    \"\"\"Initialize all warnings with the state 'uninspected'.\"\"\"\n    return {k: 'uninspected' for k in ground_truth.keys()}\n\ndef calculate_accuracy(warnings_state, ground_truth):\n    \"\"\"Calculate the accuracy by comparing the current state of warnings with the ground truth.\"\"\"\n    correct_labels = sum(1 for k, v in warnings_state.items() if v == ground_truth[k])\n    return correct_labels / len(ground_truth) * 100\n\ndef sample_pos_with_heuristic(selected_warnings, code_data, warnings_state, apply_heuristics=None):\n    # create the second dim for every item in selected_warnings\n    selected_warnings = [(warning, 0, 0, 'uninspected') for warning in selected_warnings]\n    # sort by code length to identify shortest and longest warnings. selected_warnings do not contain the code length find it from warnings\n    for i, warning in enumerate(selected_warnings):\n        warning_id = warning[0]\n        selected_warnings[i] = list(warning)\n        selected_warnings[i][1] = code_data.get(int(warning_id), {}).get('linesOfCode', 0)\n        selected_warnings[i][2] = code_data.get(int(warning_id), {}).get('functionCalls', [])\n        selected_warnings[i] = tuple(selected_warnings[i])\n    \n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            selected_warnings = heuristic_shorter_code_first(selected_warnings)\n        elif heuristic == 2:\n            selected_warnings = heuristic_shared_function_calls(selected_warnings)\n        elif heuristic == 3:\n            selected_warnings = heuristic_neighbor_classes(selected_warnings)\n        elif heuristic == 4:\n            # choose a random heuristic\n            selected_warnings = random.choice([heuristic_shorter_code_first(selected_warnings), heuristic_shared_function_calls(selected_warnings), heuristic_neighbor_classes(selected_warnings)])\n    \n    sorted_warnings_by_length = sorted(selected_warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(selected_warnings)):\n        if selected_warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'positive'\n            selected_warnings[i] = tuple(selected_warnings[i])\n        else:\n            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'negative'\n            selected_warnings[i] = tuple(selected_warnings[i])\n\n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n\n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [selected_warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [selected_warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n\n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n\n    return selected_positive_warnings, selected_negative_warnings\n"],time:'2024-09-08T07:45:31.667Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['73','0','142','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"            sorted_warnings.extend(same_loc_warnings)\n            processed_locs.add(loc)\n    \n    return sorted_warnings\n\ndef initialize_warnings_state(ground_truth):\n    \"\"\"Initialize all warnings with the state 'uninspected'.\"\"\"\n    return {k: 'uninspected' for k in ground_truth.keys()}\n\ndef calculate_accuracy(warnings_state, ground_truth):\n    \"\"\"Calculate the accuracy by comparing the current state of warnings with the ground truth.\"\"\"\n    correct_labels = sum(1 for k, v in warnings_state.items() if v == ground_truth[k])\n    return correct_labels / len(ground_truth) * 100\n\ndef sample_pos_with_heuristic(selected_warnings, code_data, warnings_state, apply_heuristics=None):\n    # create the second dim for every item in selected_warnings\n    selected_warnings = [(warning, 0, 0, 'uninspected') for warning in selected_warnings]\n    # sort by code length to identify shortest and longest warnings. selected_warnings do not contain the code length find it from warnings\n    for i, warning in enumerate(selected_warnings):\n        warning_id = warning[0]\n        selected_warnings[i] = list(warning)\n        selected_warnings[i][1] = code_data.get(int(warning_id), {}).get('linesOfCode', 0)\n        selected_warnings[i][2] = code_data.get(int(warning_id), {}).get('functionCalls', [])\n        selected_warnings[i] = tuple(selected_warnings[i])\n    \n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            selected_warnings = heuristic_shorter_code_first(selected_warnings)\n        elif heuristic == 2:\n            selected_warnings = heuristic_shared_function_calls(selected_warnings)\n        elif heuristic == 3:\n            selected_warnings = heuristic_neighbor_classes(selected_warnings)\n        elif heuristic == 4:\n            # choose a random heuristic\n            selected_warnings = random.choice([heuristic_shorter_code_first(selected_warnings), heuristic_shared_function_calls(selected_warnings), heuristic_neighbor_classes(selected_warnings)])\n    \n    sorted_warnings_by_length = sorted(selected_warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(selected_warnings)):\n        if selected_warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'positive'\n            selected_warnings[i] = tuple(selected_warnings[i])\n        else:\n            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'negative'\n            selected_warnings[i] = tuple(selected_warnings[i])\n\n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n\n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [selected_warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [selected_warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n\n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n\n    return selected_positive_warnings, selected_negative_warnings\n"],time:'2024-09-08T07:45:31.685Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['74','0','142','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"            processed_locs.add(loc)\n    \n    return sorted_warnings\n\ndef initialize_warnings_state(ground_truth):\n    \"\"\"Initialize all warnings with the state 'uninspected'.\"\"\"\n    return {k: 'uninspected' for k in ground_truth.keys()}\n\ndef calculate_accuracy(warnings_state, ground_truth):\n    \"\"\"Calculate the accuracy by comparing the current state of warnings with the ground truth.\"\"\"\n    correct_labels = sum(1 for k, v in warnings_state.items() if v == ground_truth[k])\n    return correct_labels / len(ground_truth) * 100\n\ndef sample_pos_with_heuristic(selected_warnings, code_data, warnings_state, apply_heuristics=None):\n    # create the second dim for every item in selected_warnings\n    selected_warnings = [(warning, 0, 0, 'uninspected') for warning in selected_warnings]\n    # sort by code length to identify shortest and longest warnings. selected_warnings do not contain the code length find it from warnings\n    for i, warning in enumerate(selected_warnings):\n        warning_id = warning[0]\n        selected_warnings[i] = list(warning)\n        selected_warnings[i][1] = code_data.get(int(warning_id), {}).get('linesOfCode', 0)\n        selected_warnings[i][2] = code_data.get(int(warning_id), {}).get('functionCalls', [])\n        selected_warnings[i] = tuple(selected_warnings[i])\n    \n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            selected_warnings = heuristic_shorter_code_first(selected_warnings)\n        elif heuristic == 2:\n            selected_warnings = heuristic_shared_function_calls(selected_warnings)\n        elif heuristic == 3:\n            selected_warnings = heuristic_neighbor_classes(selected_warnings)\n        elif heuristic == 4:\n            # choose a random heuristic\n            selected_warnings = random.choice([heuristic_shorter_code_first(selected_warnings), heuristic_shared_function_calls(selected_warnings), heuristic_neighbor_classes(selected_warnings)])\n    \n    sorted_warnings_by_length = sorted(selected_warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(selected_warnings)):\n        if selected_warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'positive'\n            selected_warnings[i] = tuple(selected_warnings[i])\n        else:\n            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'negative'\n            selected_warnings[i] = tuple(selected_warnings[i])\n\n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n\n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [selected_warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [selected_warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n\n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n\n    return selected_positive_warnings, selected_negative_warnings\n"],time:'2024-09-08T07:45:31.699Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['75','0','142','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"    \n    return sorted_warnings\n\ndef initialize_warnings_state(ground_truth):\n    \"\"\"Initialize all warnings with the state 'uninspected'.\"\"\"\n    return {k: 'uninspected' for k in ground_truth.keys()}\n\ndef calculate_accuracy(warnings_state, ground_truth):\n    \"\"\"Calculate the accuracy by comparing the current state of warnings with the ground truth.\"\"\"\n    correct_labels = sum(1 for k, v in warnings_state.items() if v == ground_truth[k])\n    return correct_labels / len(ground_truth) * 100\n\ndef sample_pos_with_heuristic(selected_warnings, code_data, warnings_state, apply_heuristics=None):\n    # create the second dim for every item in selected_warnings\n    selected_warnings = [(warning, 0, 0, 'uninspected') for warning in selected_warnings]\n    # sort by code length to identify shortest and longest warnings. selected_warnings do not contain the code length find it from warnings\n    for i, warning in enumerate(selected_warnings):\n        warning_id = warning[0]\n        selected_warnings[i] = list(warning)\n        selected_warnings[i][1] = code_data.get(int(warning_id), {}).get('linesOfCode', 0)\n        selected_warnings[i][2] = code_data.get(int(warning_id), {}).get('functionCalls', [])\n        selected_warnings[i] = tuple(selected_warnings[i])\n    \n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            selected_warnings = heuristic_shorter_code_first(selected_warnings)\n        elif heuristic == 2:\n            selected_warnings = heuristic_shared_function_calls(selected_warnings)\n        elif heuristic == 3:\n            selected_warnings = heuristic_neighbor_classes(selected_warnings)\n        elif heuristic == 4:\n            # choose a random heuristic\n            selected_warnings = random.choice([heuristic_shorter_code_first(selected_warnings), heuristic_shared_function_calls(selected_warnings), heuristic_neighbor_classes(selected_warnings)])\n    \n    sorted_warnings_by_length = sorted(selected_warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(selected_warnings)):\n        if selected_warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'positive'\n            selected_warnings[i] = tuple(selected_warnings[i])\n        else:\n            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'negative'\n            selected_warnings[i] = tuple(selected_warnings[i])\n\n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n\n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [selected_warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [selected_warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n\n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n\n    return selected_positive_warnings, selected_negative_warnings\n"],time:'2024-09-08T07:45:31.716Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['76','0','142','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"    return sorted_warnings\n\ndef initialize_warnings_state(ground_truth):\n    \"\"\"Initialize all warnings with the state 'uninspected'.\"\"\"\n    return {k: 'uninspected' for k in ground_truth.keys()}\n\ndef calculate_accuracy(warnings_state, ground_truth):\n    \"\"\"Calculate the accuracy by comparing the current state of warnings with the ground truth.\"\"\"\n    correct_labels = sum(1 for k, v in warnings_state.items() if v == ground_truth[k])\n    return correct_labels / len(ground_truth) * 100\n\ndef sample_pos_with_heuristic(selected_warnings, code_data, warnings_state, apply_heuristics=None):\n    # create the second dim for every item in selected_warnings\n    selected_warnings = [(warning, 0, 0, 'uninspected') for warning in selected_warnings]\n    # sort by code length to identify shortest and longest warnings. selected_warnings do not contain the code length find it from warnings\n    for i, warning in enumerate(selected_warnings):\n        warning_id = warning[0]\n        selected_warnings[i] = list(warning)\n        selected_warnings[i][1] = code_data.get(int(warning_id), {}).get('linesOfCode', 0)\n        selected_warnings[i][2] = code_data.get(int(warning_id), {}).get('functionCalls', [])\n        selected_warnings[i] = tuple(selected_warnings[i])\n    \n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            selected_warnings = heuristic_shorter_code_first(selected_warnings)\n        elif heuristic == 2:\n            selected_warnings = heuristic_shared_function_calls(selected_warnings)\n        elif heuristic == 3:\n            selected_warnings = heuristic_neighbor_classes(selected_warnings)\n        elif heuristic == 4:\n            # choose a random heuristic\n            selected_warnings = random.choice([heuristic_shorter_code_first(selected_warnings), heuristic_shared_function_calls(selected_warnings), heuristic_neighbor_classes(selected_warnings)])\n    \n    sorted_warnings_by_length = sorted(selected_warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(selected_warnings)):\n        if selected_warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'positive'\n            selected_warnings[i] = tuple(selected_warnings[i])\n        else:\n            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'negative'\n            selected_warnings[i] = tuple(selected_warnings[i])\n\n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n\n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [selected_warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [selected_warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n\n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n\n    return selected_positive_warnings, selected_negative_warnings\n"],time:'2024-09-08T07:45:31.733Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['77','0','142','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"\ndef initialize_warnings_state(ground_truth):\n    \"\"\"Initialize all warnings with the state 'uninspected'.\"\"\"\n    return {k: 'uninspected' for k in ground_truth.keys()}\n\ndef calculate_accuracy(warnings_state, ground_truth):\n    \"\"\"Calculate the accuracy by comparing the current state of warnings with the ground truth.\"\"\"\n    correct_labels = sum(1 for k, v in warnings_state.items() if v == ground_truth[k])\n    return correct_labels / len(ground_truth) * 100\n\ndef sample_pos_with_heuristic(selected_warnings, code_data, warnings_state, apply_heuristics=None):\n    # create the second dim for every item in selected_warnings\n    selected_warnings = [(warning, 0, 0, 'uninspected') for warning in selected_warnings]\n    # sort by code length to identify shortest and longest warnings. selected_warnings do not contain the code length find it from warnings\n    for i, warning in enumerate(selected_warnings):\n        warning_id = warning[0]\n        selected_warnings[i] = list(warning)\n        selected_warnings[i][1] = code_data.get(int(warning_id), {}).get('linesOfCode', 0)\n        selected_warnings[i][2] = code_data.get(int(warning_id), {}).get('functionCalls', [])\n        selected_warnings[i] = tuple(selected_warnings[i])\n    \n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            selected_warnings = heuristic_shorter_code_first(selected_warnings)\n        elif heuristic == 2:\n            selected_warnings = heuristic_shared_function_calls(selected_warnings)\n        elif heuristic == 3:\n            selected_warnings = heuristic_neighbor_classes(selected_warnings)\n        elif heuristic == 4:\n            # choose a random heuristic\n            selected_warnings = random.choice([heuristic_shorter_code_first(selected_warnings), heuristic_shared_function_calls(selected_warnings), heuristic_neighbor_classes(selected_warnings)])\n    \n    sorted_warnings_by_length = sorted(selected_warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(selected_warnings)):\n        if selected_warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'positive'\n            selected_warnings[i] = tuple(selected_warnings[i])\n        else:\n            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'negative'\n            selected_warnings[i] = tuple(selected_warnings[i])\n\n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n\n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [selected_warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [selected_warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n\n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n\n    return selected_positive_warnings, selected_negative_warnings\n"],time:'2024-09-08T07:45:31.750Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['78','0','142','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def initialize_warnings_state(ground_truth):\n    \"\"\"Initialize all warnings with the state 'uninspected'.\"\"\"\n    return {k: 'uninspected' for k in ground_truth.keys()}\n\ndef calculate_accuracy(warnings_state, ground_truth):\n    \"\"\"Calculate the accuracy by comparing the current state of warnings with the ground truth.\"\"\"\n    correct_labels = sum(1 for k, v in warnings_state.items() if v == ground_truth[k])\n    return correct_labels / len(ground_truth) * 100\n\ndef sample_pos_with_heuristic(selected_warnings, code_data, warnings_state, apply_heuristics=None):\n    # create the second dim for every item in selected_warnings\n    selected_warnings = [(warning, 0, 0, 'uninspected') for warning in selected_warnings]\n    # sort by code length to identify shortest and longest warnings. selected_warnings do not contain the code length find it from warnings\n    for i, warning in enumerate(selected_warnings):\n        warning_id = warning[0]\n        selected_warnings[i] = list(warning)\n        selected_warnings[i][1] = code_data.get(int(warning_id), {}).get('linesOfCode', 0)\n        selected_warnings[i][2] = code_data.get(int(warning_id), {}).get('functionCalls', [])\n        selected_warnings[i] = tuple(selected_warnings[i])\n    \n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            selected_warnings = heuristic_shorter_code_first(selected_warnings)\n        elif heuristic == 2:\n            selected_warnings = heuristic_shared_function_calls(selected_warnings)\n        elif heuristic == 3:\n            selected_warnings = heuristic_neighbor_classes(selected_warnings)\n        elif heuristic == 4:\n            # choose a random heuristic\n            selected_warnings = random.choice([heuristic_shorter_code_first(selected_warnings), heuristic_shared_function_calls(selected_warnings), heuristic_neighbor_classes(selected_warnings)])\n    \n    sorted_warnings_by_length = sorted(selected_warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(selected_warnings)):\n        if selected_warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'positive'\n            selected_warnings[i] = tuple(selected_warnings[i])\n        else:\n            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'negative'\n            selected_warnings[i] = tuple(selected_warnings[i])\n\n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n\n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [selected_warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [selected_warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n\n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n\n    return selected_positive_warnings, selected_negative_warnings\n"],time:'2024-09-08T07:45:31.784Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['79','0','142','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"    \"\"\"Initialize all warnings with the state 'uninspected'.\"\"\"\n    return {k: 'uninspected' for k in ground_truth.keys()}\n\ndef calculate_accuracy(warnings_state, ground_truth):\n    \"\"\"Calculate the accuracy by comparing the current state of warnings with the ground truth.\"\"\"\n    correct_labels = sum(1 for k, v in warnings_state.items() if v == ground_truth[k])\n    return correct_labels / len(ground_truth) * 100\n\ndef sample_pos_with_heuristic(selected_warnings, code_data, warnings_state, apply_heuristics=None):\n    # create the second dim for every item in selected_warnings\n    selected_warnings = [(warning, 0, 0, 'uninspected') for warning in selected_warnings]\n    # sort by code length to identify shortest and longest warnings. selected_warnings do not contain the code length find it from warnings\n    for i, warning in enumerate(selected_warnings):\n        warning_id = warning[0]\n        selected_warnings[i] = list(warning)\n        selected_warnings[i][1] = code_data.get(int(warning_id), {}).get('linesOfCode', 0)\n        selected_warnings[i][2] = code_data.get(int(warning_id), {}).get('functionCalls', [])\n        selected_warnings[i] = tuple(selected_warnings[i])\n    \n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            selected_warnings = heuristic_shorter_code_first(selected_warnings)\n        elif heuristic == 2:\n            selected_warnings = heuristic_shared_function_calls(selected_warnings)\n        elif heuristic == 3:\n            selected_warnings = heuristic_neighbor_classes(selected_warnings)\n        elif heuristic == 4:\n            # choose a random heuristic\n            selected_warnings = random.choice([heuristic_shorter_code_first(selected_warnings), heuristic_shared_function_calls(selected_warnings), heuristic_neighbor_classes(selected_warnings)])\n    \n    sorted_warnings_by_length = sorted(selected_warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(selected_warnings)):\n        if selected_warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'positive'\n            selected_warnings[i] = tuple(selected_warnings[i])\n        else:\n            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'negative'\n            selected_warnings[i] = tuple(selected_warnings[i])\n\n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n\n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [selected_warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [selected_warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n\n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n\n    return selected_positive_warnings, selected_negative_warnings\n"],time:'2024-09-08T07:45:31.833Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['80','0','142','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"    return {k: 'uninspected' for k in ground_truth.keys()}\n\ndef calculate_accuracy(warnings_state, ground_truth):\n    \"\"\"Calculate the accuracy by comparing the current state of warnings with the ground truth.\"\"\"\n    correct_labels = sum(1 for k, v in warnings_state.items() if v == ground_truth[k])\n    return correct_labels / len(ground_truth) * 100\n\ndef sample_pos_with_heuristic(selected_warnings, code_data, warnings_state, apply_heuristics=None):\n    # create the second dim for every item in selected_warnings\n    selected_warnings = [(warning, 0, 0, 'uninspected') for warning in selected_warnings]\n    # sort by code length to identify shortest and longest warnings. selected_warnings do not contain the code length find it from warnings\n    for i, warning in enumerate(selected_warnings):\n        warning_id = warning[0]\n        selected_warnings[i] = list(warning)\n        selected_warnings[i][1] = code_data.get(int(warning_id), {}).get('linesOfCode', 0)\n        selected_warnings[i][2] = code_data.get(int(warning_id), {}).get('functionCalls', [])\n        selected_warnings[i] = tuple(selected_warnings[i])\n    \n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            selected_warnings = heuristic_shorter_code_first(selected_warnings)\n        elif heuristic == 2:\n            selected_warnings = heuristic_shared_function_calls(selected_warnings)\n        elif heuristic == 3:\n            selected_warnings = heuristic_neighbor_classes(selected_warnings)\n        elif heuristic == 4:\n            # choose a random heuristic\n            selected_warnings = random.choice([heuristic_shorter_code_first(selected_warnings), heuristic_shared_function_calls(selected_warnings), heuristic_neighbor_classes(selected_warnings)])\n    \n    sorted_warnings_by_length = sorted(selected_warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(selected_warnings)):\n        if selected_warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'positive'\n            selected_warnings[i] = tuple(selected_warnings[i])\n        else:\n            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'negative'\n            selected_warnings[i] = tuple(selected_warnings[i])\n\n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n\n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [selected_warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [selected_warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n\n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n\n    return selected_positive_warnings, selected_negative_warnings\n"],time:'2024-09-08T07:45:31.851Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['81','0','142','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"\ndef calculate_accuracy(warnings_state, ground_truth):\n    \"\"\"Calculate the accuracy by comparing the current state of warnings with the ground truth.\"\"\"\n    correct_labels = sum(1 for k, v in warnings_state.items() if v == ground_truth[k])\n    return correct_labels / len(ground_truth) * 100\n\ndef sample_pos_with_heuristic(selected_warnings, code_data, warnings_state, apply_heuristics=None):\n    # create the second dim for every item in selected_warnings\n    selected_warnings = [(warning, 0, 0, 'uninspected') for warning in selected_warnings]\n    # sort by code length to identify shortest and longest warnings. selected_warnings do not contain the code length find it from warnings\n    for i, warning in enumerate(selected_warnings):\n        warning_id = warning[0]\n        selected_warnings[i] = list(warning)\n        selected_warnings[i][1] = code_data.get(int(warning_id), {}).get('linesOfCode', 0)\n        selected_warnings[i][2] = code_data.get(int(warning_id), {}).get('functionCalls', [])\n        selected_warnings[i] = tuple(selected_warnings[i])\n    \n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            selected_warnings = heuristic_shorter_code_first(selected_warnings)\n        elif heuristic == 2:\n            selected_warnings = heuristic_shared_function_calls(selected_warnings)\n        elif heuristic == 3:\n            selected_warnings = heuristic_neighbor_classes(selected_warnings)\n        elif heuristic == 4:\n            # choose a random heuristic\n            selected_warnings = random.choice([heuristic_shorter_code_first(selected_warnings), heuristic_shared_function_calls(selected_warnings), heuristic_neighbor_classes(selected_warnings)])\n    \n    sorted_warnings_by_length = sorted(selected_warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(selected_warnings)):\n        if selected_warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'positive'\n            selected_warnings[i] = tuple(selected_warnings[i])\n        else:\n            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'negative'\n            selected_warnings[i] = tuple(selected_warnings[i])\n\n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n\n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [selected_warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [selected_warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n\n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n\n    return selected_positive_warnings, selected_negative_warnings\n"],time:'2024-09-08T07:45:31.883Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['82','0','142','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def calculate_accuracy(warnings_state, ground_truth):\n    \"\"\"Calculate the accuracy by comparing the current state of warnings with the ground truth.\"\"\"\n    correct_labels = sum(1 for k, v in warnings_state.items() if v == ground_truth[k])\n    return correct_labels / len(ground_truth) * 100\n\ndef sample_pos_with_heuristic(selected_warnings, code_data, warnings_state, apply_heuristics=None):\n    # create the second dim for every item in selected_warnings\n    selected_warnings = [(warning, 0, 0, 'uninspected') for warning in selected_warnings]\n    # sort by code length to identify shortest and longest warnings. selected_warnings do not contain the code length find it from warnings\n    for i, warning in enumerate(selected_warnings):\n        warning_id = warning[0]\n        selected_warnings[i] = list(warning)\n        selected_warnings[i][1] = code_data.get(int(warning_id), {}).get('linesOfCode', 0)\n        selected_warnings[i][2] = code_data.get(int(warning_id), {}).get('functionCalls', [])\n        selected_warnings[i] = tuple(selected_warnings[i])\n    \n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            selected_warnings = heuristic_shorter_code_first(selected_warnings)\n        elif heuristic == 2:\n            selected_warnings = heuristic_shared_function_calls(selected_warnings)\n        elif heuristic == 3:\n            selected_warnings = heuristic_neighbor_classes(selected_warnings)\n        elif heuristic == 4:\n            # choose a random heuristic\n            selected_warnings = random.choice([heuristic_shorter_code_first(selected_warnings), heuristic_shared_function_calls(selected_warnings), heuristic_neighbor_classes(selected_warnings)])\n    \n    sorted_warnings_by_length = sorted(selected_warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(selected_warnings)):\n        if selected_warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'positive'\n            selected_warnings[i] = tuple(selected_warnings[i])\n        else:\n            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'negative'\n            selected_warnings[i] = tuple(selected_warnings[i])\n\n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n\n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [selected_warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [selected_warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n\n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n\n    return selected_positive_warnings, selected_negative_warnings\n"],time:'2024-09-08T07:45:31.900Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['83','0','142','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"    \"\"\"Calculate the accuracy by comparing the current state of warnings with the ground truth.\"\"\"\n    correct_labels = sum(1 for k, v in warnings_state.items() if v == ground_truth[k])\n    return correct_labels / len(ground_truth) * 100\n\ndef sample_pos_with_heuristic(selected_warnings, code_data, warnings_state, apply_heuristics=None):\n    # create the second dim for every item in selected_warnings\n    selected_warnings = [(warning, 0, 0, 'uninspected') for warning in selected_warnings]\n    # sort by code length to identify shortest and longest warnings. selected_warnings do not contain the code length find it from warnings\n    for i, warning in enumerate(selected_warnings):\n        warning_id = warning[0]\n        selected_warnings[i] = list(warning)\n        selected_warnings[i][1] = code_data.get(int(warning_id), {}).get('linesOfCode', 0)\n        selected_warnings[i][2] = code_data.get(int(warning_id), {}).get('functionCalls', [])\n        selected_warnings[i] = tuple(selected_warnings[i])\n    \n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            selected_warnings = heuristic_shorter_code_first(selected_warnings)\n        elif heuristic == 2:\n            selected_warnings = heuristic_shared_function_calls(selected_warnings)\n        elif heuristic == 3:\n            selected_warnings = heuristic_neighbor_classes(selected_warnings)\n        elif heuristic == 4:\n            # choose a random heuristic\n            selected_warnings = random.choice([heuristic_shorter_code_first(selected_warnings), heuristic_shared_function_calls(selected_warnings), heuristic_neighbor_classes(selected_warnings)])\n    \n    sorted_warnings_by_length = sorted(selected_warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(selected_warnings)):\n        if selected_warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'positive'\n            selected_warnings[i] = tuple(selected_warnings[i])\n        else:\n            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'negative'\n            selected_warnings[i] = tuple(selected_warnings[i])\n\n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n\n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [selected_warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [selected_warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n\n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n\n    return selected_positive_warnings, selected_negative_warnings\n"],time:'2024-09-08T07:45:31.917Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['84','0','142','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"    correct_labels = sum(1 for k, v in warnings_state.items() if v == ground_truth[k])\n    return correct_labels / len(ground_truth) * 100\n\ndef sample_pos_with_heuristic(selected_warnings, code_data, warnings_state, apply_heuristics=None):\n    # create the second dim for every item in selected_warnings\n    selected_warnings = [(warning, 0, 0, 'uninspected') for warning in selected_warnings]\n    # sort by code length to identify shortest and longest warnings. selected_warnings do not contain the code length find it from warnings\n    for i, warning in enumerate(selected_warnings):\n        warning_id = warning[0]\n        selected_warnings[i] = list(warning)\n        selected_warnings[i][1] = code_data.get(int(warning_id), {}).get('linesOfCode', 0)\n        selected_warnings[i][2] = code_data.get(int(warning_id), {}).get('functionCalls', [])\n        selected_warnings[i] = tuple(selected_warnings[i])\n    \n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            selected_warnings = heuristic_shorter_code_first(selected_warnings)\n        elif heuristic == 2:\n            selected_warnings = heuristic_shared_function_calls(selected_warnings)\n        elif heuristic == 3:\n            selected_warnings = heuristic_neighbor_classes(selected_warnings)\n        elif heuristic == 4:\n            # choose a random heuristic\n            selected_warnings = random.choice([heuristic_shorter_code_first(selected_warnings), heuristic_shared_function_calls(selected_warnings), heuristic_neighbor_classes(selected_warnings)])\n    \n    sorted_warnings_by_length = sorted(selected_warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(selected_warnings)):\n        if selected_warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'positive'\n            selected_warnings[i] = tuple(selected_warnings[i])\n        else:\n            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'negative'\n            selected_warnings[i] = tuple(selected_warnings[i])\n\n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n\n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [selected_warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [selected_warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n\n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n\n    return selected_positive_warnings, selected_negative_warnings\n"],time:'2024-09-08T07:45:31.933Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['86','0','142','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"\ndef sample_pos_with_heuristic(selected_warnings, code_data, warnings_state, apply_heuristics=None):\n    # create the second dim for every item in selected_warnings\n    selected_warnings = [(warning, 0, 0, 'uninspected') for warning in selected_warnings]\n    # sort by code length to identify shortest and longest warnings. selected_warnings do not contain the code length find it from warnings\n    for i, warning in enumerate(selected_warnings):\n        warning_id = warning[0]\n        selected_warnings[i] = list(warning)\n        selected_warnings[i][1] = code_data.get(int(warning_id), {}).get('linesOfCode', 0)\n        selected_warnings[i][2] = code_data.get(int(warning_id), {}).get('functionCalls', [])\n        selected_warnings[i] = tuple(selected_warnings[i])\n    \n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            selected_warnings = heuristic_shorter_code_first(selected_warnings)\n        elif heuristic == 2:\n            selected_warnings = heuristic_shared_function_calls(selected_warnings)\n        elif heuristic == 3:\n            selected_warnings = heuristic_neighbor_classes(selected_warnings)\n        elif heuristic == 4:\n            # choose a random heuristic\n            selected_warnings = random.choice([heuristic_shorter_code_first(selected_warnings), heuristic_shared_function_calls(selected_warnings), heuristic_neighbor_classes(selected_warnings)])\n    \n    sorted_warnings_by_length = sorted(selected_warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(selected_warnings)):\n        if selected_warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'positive'\n            selected_warnings[i] = tuple(selected_warnings[i])\n        else:\n            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'negative'\n            selected_warnings[i] = tuple(selected_warnings[i])\n\n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n\n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [selected_warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [selected_warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n\n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n\n    return selected_positive_warnings, selected_negative_warnings\n"],time:'2024-09-08T07:45:32.033Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['87','0','142','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_pos_with_heuristic(selected_warnings, code_data, warnings_state, apply_heuristics=None):\n    # create the second dim for every item in selected_warnings\n    selected_warnings = [(warning, 0, 0, 'uninspected') for warning in selected_warnings]\n    # sort by code length to identify shortest and longest warnings. selected_warnings do not contain the code length find it from warnings\n    for i, warning in enumerate(selected_warnings):\n        warning_id = warning[0]\n        selected_warnings[i] = list(warning)\n        selected_warnings[i][1] = code_data.get(int(warning_id), {}).get('linesOfCode', 0)\n        selected_warnings[i][2] = code_data.get(int(warning_id), {}).get('functionCalls', [])\n        selected_warnings[i] = tuple(selected_warnings[i])\n    \n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            selected_warnings = heuristic_shorter_code_first(selected_warnings)\n        elif heuristic == 2:\n            selected_warnings = heuristic_shared_function_calls(selected_warnings)\n        elif heuristic == 3:\n            selected_warnings = heuristic_neighbor_classes(selected_warnings)\n        elif heuristic == 4:\n            # choose a random heuristic\n            selected_warnings = random.choice([heuristic_shorter_code_first(selected_warnings), heuristic_shared_function_calls(selected_warnings), heuristic_neighbor_classes(selected_warnings)])\n    \n    sorted_warnings_by_length = sorted(selected_warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(selected_warnings)):\n        if selected_warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'positive'\n            selected_warnings[i] = tuple(selected_warnings[i])\n        else:\n            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'negative'\n            selected_warnings[i] = tuple(selected_warnings[i])\n\n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n\n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [selected_warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [selected_warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n\n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n\n    return selected_positive_warnings, selected_negative_warnings\n"],time:'2024-09-08T07:45:32.083Z'},{src:'onDidChangeTextDocument',msg:'%s:%s to %s:%s in [%s] replaced with: %s`',prm:['87','0','142','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',''],time:'2024-09-08T07:45:32.741Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['71','0','99','74','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:32.747Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['87','0','87','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',''],time:'2024-09-08T07:45:32.757Z'},{src:'onDidChangeTextDocument',msg:'%s:%s to %s:%s in [%s] replaced with: %s`',prm:['86','0','87','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',''],time:'2024-09-08T07:45:32.884Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['71','0','99','4','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:32.885Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['86','0','86','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',''],time:'2024-09-08T07:45:32.888Z'},{src:'onDidChangeTextDocument',msg:'%s:%s to %s:%s in [%s] replaced with: %s`',prm:['85','51','86','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',''],time:'2024-09-08T07:45:33.222Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['71','0','99','78','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:33.226Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['85','51','85','51','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',''],time:'2024-09-08T07:45:33.229Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['87','0','87','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',''],time:'2024-09-08T07:45:35.855Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['87','0','87','1','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py','d'],time:'2024-09-08T07:45:36.090Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['87','0','88','7','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py','def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    """'],time:'2024-09-08T07:45:36.115Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['87','0','89','14','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py','def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    """\n    Apply spec'],time:'2024-09-08T07:45:36.142Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['87','0','91','20','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py','def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    """\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review th'],time:'2024-09-08T07:45:36.153Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['87','0','93','28','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py','def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    """\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor'],time:'2024-09-08T07:45:36.172Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['87','0','96','32','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py','def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    """\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    """\n    if apply_heuristics is None:'],time:'2024-09-08T07:45:36.184Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['87','0','97','41','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py','def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    """\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    """\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # D'],time:'2024-09-08T07:45:36.200Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['87','0','99','45','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py','def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    """\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    """\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their'],time:'2024-09-08T07:45:36.217Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['87','0','100','16','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py','def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    """\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    """\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = ['],time:'2024-09-08T07:45:36.234Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['73','0','101','127','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:36.250Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['87','0','102','78','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'"],time:'2024-09-08T07:45:36.255Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['75','0','103','5','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:36.267Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['87','0','104','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n"],time:'2024-09-08T07:45:36.271Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['77','0','105','37','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:36.283Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['87','0','106','28','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)"],time:'2024-09-08T07:45:36.288Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['83','0','111','4','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:36.300Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['87','0','112','45','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order"],time:'2024-09-08T07:45:36.307Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['88','0','116','61','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:36.316Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['87','0','117','28','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:"],time:'2024-09-08T07:45:36.324Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['94','0','122','39','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:36.334Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['87','0','123','172','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])"],time:'2024-09-08T07:45:36.340Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['101','0','129','34','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:36.356Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['87','0','130','88','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:"],time:'2024-09-08T07:45:36.362Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['105','0','133','44','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:36.369Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['87','0','134','13','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:"],time:'2024-09-08T07:45:36.374Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['109','0','137','48','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:36.384Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['87','0','138','4','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    "],time:'2024-09-08T07:45:36.397Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['122','0','150','39','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:36.421Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['87','0','151','54','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]"],time:'2024-09-08T07:45:36.432Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['129','0','157','4','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:36.445Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['87','0','158','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings"],time:'2024-09-08T07:45:36.452Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['135','0','163','37','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:36.465Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['87','0','164','41','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings\n\n\ndef run_clingo():\n    files = [\n        f'lp/simulation_labels.lp',  \n        'lp/background.lp',              "],time:'2024-09-08T07:45:36.471Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['145','0','173','24','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:36.494Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['87','0','174','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings\n\n\ndef run_clingo():\n    files = [\n        f'lp/simulation_labels.lp',  \n        'lp/background.lp',              \n        'lp/frozen_rules.lp',            \n        'lp/rules2.lp'                   \n    ]\n    \n    command = ['clingo'] + files + ['--outf=2'] + ['--time-limit=30'] \n    print(' '.join(command))\n    result = subprocess.run(command, capture_output=True, text=True)\n\n    return result.stdout\n"],time:'2024-09-08T07:45:36.503Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['150','0','178','29','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:36.511Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['87','0','179','20','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings\n\n\ndef run_clingo():\n    files = [\n        f'lp/simulation_labels.lp',  \n        'lp/background.lp',              \n        'lp/frozen_rules.lp',            \n        'lp/rules2.lp'                   \n    ]\n    \n    command = ['clingo'] + files + ['--outf=2'] + ['--time-limit=30'] \n    print(' '.join(command))\n    result = subprocess.run(command, capture_output=True, text=True)\n\n    return result.stdout\n\ndef parse_clingo_output(data):\n    # Load the data using json.loads if 'data' is a string,\n    # otherwise assume it's already a dictionary\n    if isinstance(data, str):\n        #print(data)"],time:'2024-09-08T07:45:36.517Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['157','0','185','107','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:36.532Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['87','0','186','29','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings\n\n\ndef run_clingo():\n    files = [\n        f'lp/simulation_labels.lp',  \n        'lp/background.lp',              \n        'lp/frozen_rules.lp',            \n        'lp/rules2.lp'                   \n    ]\n    \n    command = ['clingo'] + files + ['--outf=2'] + ['--time-limit=30'] \n    print(' '.join(command))\n    result = subprocess.run(command, capture_output=True, text=True)\n\n    return result.stdout\n\ndef parse_clingo_output(data):\n    # Load the data using json.loads if 'data' is a string,\n    # otherwise assume it's already a dictionary\n    if isinstance(data, str):\n        #print(data)\n        data = json.loads(data.replace(\"'\", '\"'))\n    # Navigate through the JSON structure\n    # Assuming 'Call' is always present and has at least one element\n    calls = data.get(\"Call\", [])\n    if calls:\n        # Assuming 'Witnesses' is always present in the last element of 'Call' and has at least one element\n        last_call = calls[-1]"],time:'2024-09-08T07:45:36.536Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['163','0','191','69','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:36.550Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['87','0','192','48','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings\n\n\ndef run_clingo():\n    files = [\n        f'lp/simulation_labels.lp',  \n        'lp/background.lp',              \n        'lp/frozen_rules.lp',            \n        'lp/rules2.lp'                   \n    ]\n    \n    command = ['clingo'] + files + ['--outf=2'] + ['--time-limit=30'] \n    print(' '.join(command))\n    result = subprocess.run(command, capture_output=True, text=True)\n\n    return result.stdout\n\ndef parse_clingo_output(data):\n    # Load the data using json.loads if 'data' is a string,\n    # otherwise assume it's already a dictionary\n    if isinstance(data, str):\n        #print(data)\n        data = json.loads(data.replace(\"'\", '\"'))\n    # Navigate through the JSON structure\n    # Assuming 'Call' is always present and has at least one element\n    calls = data.get(\"Call\", [])\n    if calls:\n        # Assuming 'Witnesses' is always present in the last element of 'Call' and has at least one element\n        last_call = calls[-1]\n        witnesses = last_call.get(\"Witnesses\", [])\n        if witnesses:\n            # Get the last 'Witnesses' entry\n            last_witness = witnesses[-1]\n            # Return the 'Value' list from the last 'Witnesses' entry\n            return last_witness.get(\"Value\", [])"],time:'2024-09-08T07:45:36.555Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['168','0','196','61','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:36.567Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['87','0','197','47','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings\n\n\ndef run_clingo():\n    files = [\n        f'lp/simulation_labels.lp',  \n        'lp/background.lp',              \n        'lp/frozen_rules.lp',            \n        'lp/rules2.lp'                   \n    ]\n    \n    command = ['clingo'] + files + ['--outf=2'] + ['--time-limit=30'] \n    print(' '.join(command))\n    result = subprocess.run(command, capture_output=True, text=True)\n\n    return result.stdout\n\ndef parse_clingo_output(data):\n    # Load the data using json.loads if 'data' is a string,\n    # otherwise assume it's already a dictionary\n    if isinstance(data, str):\n        #print(data)\n        data = json.loads(data.replace(\"'\", '\"'))\n    # Navigate through the JSON structure\n    # Assuming 'Call' is always present and has at least one element\n    calls = data.get(\"Call\", [])\n    if calls:\n        # Assuming 'Witnesses' is always present in the last element of 'Call' and has at least one element\n        last_call = calls[-1]\n        witnesses = last_call.get(\"Witnesses\", [])\n        if witnesses:\n            # Get the last 'Witnesses' entry\n            last_witness = witnesses[-1]\n            # Return the 'Value' list from the last 'Witnesses' entry\n            return last_witness.get(\"Value\", [])\n    return []\n\ndef extract_summary_rules(clingo_output):\n    # a summary rule is one prefixed by rule_contains(number)\n    summary_rules_by_prefix = defaultdict(list)"],time:'2024-09-08T07:45:36.571Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['172','0','200','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:36.579Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['87','0','201','69','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings\n\n\ndef run_clingo():\n    files = [\n        f'lp/simulation_labels.lp',  \n        'lp/background.lp',              \n        'lp/frozen_rules.lp',            \n        'lp/rules2.lp'                   \n    ]\n    \n    command = ['clingo'] + files + ['--outf=2'] + ['--time-limit=30'] \n    print(' '.join(command))\n    result = subprocess.run(command, capture_output=True, text=True)\n\n    return result.stdout\n\ndef parse_clingo_output(data):\n    # Load the data using json.loads if 'data' is a string,\n    # otherwise assume it's already a dictionary\n    if isinstance(data, str):\n        #print(data)\n        data = json.loads(data.replace(\"'\", '\"'))\n    # Navigate through the JSON structure\n    # Assuming 'Call' is always present and has at least one element\n    calls = data.get(\"Call\", [])\n    if calls:\n        # Assuming 'Witnesses' is always present in the last element of 'Call' and has at least one element\n        last_call = calls[-1]\n        witnesses = last_call.get(\"Witnesses\", [])\n        if witnesses:\n            # Get the last 'Witnesses' entry\n            last_witness = witnesses[-1]\n            # Return the 'Value' list from the last 'Witnesses' entry\n            return last_witness.get(\"Value\", [])\n    return []\n\ndef extract_summary_rules(clingo_output):\n    # a summary rule is one prefixed by rule_contains(number)\n    summary_rules_by_prefix = defaultdict(list)\n    for line in clingo_output:\n        if line.startswith('rule_contains'):\n\n            number_str = line.split('(')[0].split('rule_contains')[1]"],time:'2024-09-08T07:45:36.583Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['174','0','202','67','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:36.588Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['87','0','203','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings\n\n\ndef run_clingo():\n    files = [\n        f'lp/simulation_labels.lp',  \n        'lp/background.lp',              \n        'lp/frozen_rules.lp',            \n        'lp/rules2.lp'                   \n    ]\n    \n    command = ['clingo'] + files + ['--outf=2'] + ['--time-limit=30'] \n    print(' '.join(command))\n    result = subprocess.run(command, capture_output=True, text=True)\n\n    return result.stdout\n\ndef parse_clingo_output(data):\n    # Load the data using json.loads if 'data' is a string,\n    # otherwise assume it's already a dictionary\n    if isinstance(data, str):\n        #print(data)\n        data = json.loads(data.replace(\"'\", '\"'))\n    # Navigate through the JSON structure\n    # Assuming 'Call' is always present and has at least one element\n    calls = data.get(\"Call\", [])\n    if calls:\n        # Assuming 'Witnesses' is always present in the last element of 'Call' and has at least one element\n        last_call = calls[-1]\n        witnesses = last_call.get(\"Witnesses\", [])\n        if witnesses:\n            # Get the last 'Witnesses' entry\n            last_witness = witnesses[-1]\n            # Return the 'Value' list from the last 'Witnesses' entry\n            return last_witness.get(\"Value\", [])\n    return []\n\ndef extract_summary_rules(clingo_output):\n    # a summary rule is one prefixed by rule_contains(number)\n    summary_rules_by_prefix = defaultdict(list)\n    for line in clingo_output:\n        if line.startswith('rule_contains'):\n\n            number_str = line.split('(')[0].split('rule_contains')[1]\n            number = int(number_str) if number_str.isdigit() else 0\n"],time:'2024-09-08T07:45:36.591Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['178','0','206','34','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:36.600Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['87','0','207','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings\n\n\ndef run_clingo():\n    files = [\n        f'lp/simulation_labels.lp',  \n        'lp/background.lp',              \n        'lp/frozen_rules.lp',            \n        'lp/rules2.lp'                   \n    ]\n    \n    command = ['clingo'] + files + ['--outf=2'] + ['--time-limit=30'] \n    print(' '.join(command))\n    result = subprocess.run(command, capture_output=True, text=True)\n\n    return result.stdout\n\ndef parse_clingo_output(data):\n    # Load the data using json.loads if 'data' is a string,\n    # otherwise assume it's already a dictionary\n    if isinstance(data, str):\n        #print(data)\n        data = json.loads(data.replace(\"'\", '\"'))\n    # Navigate through the JSON structure\n    # Assuming 'Call' is always present and has at least one element\n    calls = data.get(\"Call\", [])\n    if calls:\n        # Assuming 'Witnesses' is always present in the last element of 'Call' and has at least one element\n        last_call = calls[-1]\n        witnesses = last_call.get(\"Witnesses\", [])\n        if witnesses:\n            # Get the last 'Witnesses' entry\n            last_witness = witnesses[-1]\n            # Return the 'Value' list from the last 'Witnesses' entry\n            return last_witness.get(\"Value\", [])\n    return []\n\ndef extract_summary_rules(clingo_output):\n    # a summary rule is one prefixed by rule_contains(number)\n    summary_rules_by_prefix = defaultdict(list)\n    for line in clingo_output:\n        if line.startswith('rule_contains'):\n\n            number_str = line.split('(')[0].split('rule_contains')[1]\n            number = int(number_str) if number_str.isdigit() else 0\n\n            rule = line.split('(')[1].split(')')[0]\n            summary_rules_by_prefix[number].append(rule)\n    return summary_rules_by_prefix\n"],time:'2024-09-08T07:45:36.604Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['180','0','208','67','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:36.616Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['87','0','209','47','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings\n\n\ndef run_clingo():\n    files = [\n        f'lp/simulation_labels.lp',  \n        'lp/background.lp',              \n        'lp/frozen_rules.lp',            \n        'lp/rules2.lp'                   \n    ]\n    \n    command = ['clingo'] + files + ['--outf=2'] + ['--time-limit=30'] \n    print(' '.join(command))\n    result = subprocess.run(command, capture_output=True, text=True)\n\n    return result.stdout\n\ndef parse_clingo_output(data):\n    # Load the data using json.loads if 'data' is a string,\n    # otherwise assume it's already a dictionary\n    if isinstance(data, str):\n        #print(data)\n        data = json.loads(data.replace(\"'\", '\"'))\n    # Navigate through the JSON structure\n    # Assuming 'Call' is always present and has at least one element\n    calls = data.get(\"Call\", [])\n    if calls:\n        # Assuming 'Witnesses' is always present in the last element of 'Call' and has at least one element\n        last_call = calls[-1]\n        witnesses = last_call.get(\"Witnesses\", [])\n        if witnesses:\n            # Get the last 'Witnesses' entry\n            last_witness = witnesses[-1]\n            # Return the 'Value' list from the last 'Witnesses' entry\n            return last_witness.get(\"Value\", [])\n    return []\n\ndef extract_summary_rules(clingo_output):\n    # a summary rule is one prefixed by rule_contains(number)\n    summary_rules_by_prefix = defaultdict(list)\n    for line in clingo_output:\n        if line.startswith('rule_contains'):\n\n            number_str = line.split('(')[0].split('rule_contains')[1]\n            number = int(number_str) if number_str.isdigit() else 0\n\n            rule = line.split('(')[1].split(')')[0]\n            summary_rules_by_prefix[number].append(rule)\n    return summary_rules_by_prefix\n\ndef calculate_rule_percentage(clingo_output, positive_predictions):\n    summary_rules_by_prefix = defaultdict(list)"],time:'2024-09-08T07:45:36.620Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['182','0','210','25','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:36.633Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['87','0','211','30','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings\n\n\ndef run_clingo():\n    files = [\n        f'lp/simulation_labels.lp',  \n        'lp/background.lp',              \n        'lp/frozen_rules.lp',            \n        'lp/rules2.lp'                   \n    ]\n    \n    command = ['clingo'] + files + ['--outf=2'] + ['--time-limit=30'] \n    print(' '.join(command))\n    result = subprocess.run(command, capture_output=True, text=True)\n\n    return result.stdout\n\ndef parse_clingo_output(data):\n    # Load the data using json.loads if 'data' is a string,\n    # otherwise assume it's already a dictionary\n    if isinstance(data, str):\n        #print(data)\n        data = json.loads(data.replace(\"'\", '\"'))\n    # Navigate through the JSON structure\n    # Assuming 'Call' is always present and has at least one element\n    calls = data.get(\"Call\", [])\n    if calls:\n        # Assuming 'Witnesses' is always present in the last element of 'Call' and has at least one element\n        last_call = calls[-1]\n        witnesses = last_call.get(\"Witnesses\", [])\n        if witnesses:\n            # Get the last 'Witnesses' entry\n            last_witness = witnesses[-1]\n            # Return the 'Value' list from the last 'Witnesses' entry\n            return last_witness.get(\"Value\", [])\n    return []\n\ndef extract_summary_rules(clingo_output):\n    # a summary rule is one prefixed by rule_contains(number)\n    summary_rules_by_prefix = defaultdict(list)\n    for line in clingo_output:\n        if line.startswith('rule_contains'):\n\n            number_str = line.split('(')[0].split('rule_contains')[1]\n            number = int(number_str) if number_str.isdigit() else 0\n\n            rule = line.split('(')[1].split(')')[0]\n            summary_rules_by_prefix[number].append(rule)\n    return summary_rules_by_prefix\n\ndef calculate_rule_percentage(clingo_output, positive_predictions):\n    summary_rules_by_prefix = defaultdict(list)\n    rule_percentages = {}\n    for line in clingo_output:"],time:'2024-09-08T07:45:36.636Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['87','0','210','25','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings\n\n\ndef run_clingo():\n    files = [\n        f'lp/simulation_labels.lp',  \n        'lp/background.lp',              \n        'lp/frozen_rules.lp',            \n        'lp/rules2.lp'                   \n    ]\n    \n    command = ['clingo'] + files + ['--outf=2'] + ['--time-limit=30'] \n    print(' '.join(command))\n    result = subprocess.run(command, capture_output=True, text=True)\n\n    return result.stdout\n\ndef parse_clingo_output(data):\n    # Load the data using json.loads if 'data' is a string,\n    # otherwise assume it's already a dictionary\n    if isinstance(data, str):\n        #print(data)\n        data = json.loads(data.replace(\"'\", '\"'))\n    # Navigate through the JSON structure\n    # Assuming 'Call' is always present and has at least one element\n    calls = data.get(\"Call\", [])\n    if calls:\n        # Assuming 'Witnesses' is always present in the last element of 'Call' and has at least one element\n        last_call = calls[-1]\n        witnesses = last_call.get(\"Witnesses\", [])\n        if witnesses:\n            # Get the last 'Witnesses' entry\n            last_witness = witnesses[-1]\n            # Return the 'Value' list from the last 'Witnesses' entry\n            return last_witness.get(\"Value\", [])\n    return []\n\ndef extract_summary_rules(clingo_output):\n    # a summary rule is one prefixed by rule_contains(number)\n    summary_rules_by_prefix = defaultdict(list)\n    for line in clingo_output:\n        if line.startswith('rule_contains'):\n\n            number_str = line.split('(')[0].split('rule_contains')[1]\n            number = int(number_str) if number_str.isdigit() else 0\n\n            rule = line.split('(')[1].split(')')[0]\n            summary_rules_by_prefix[number].append(rule)\n    return summary_rules_by_prefix\n\ndef calculate_rule_percentage(clingo_output, positive_predictions):\n    summary_rules_by_prefix = defaultdict(list)\n    rule_percentages = {}"],time:'2024-09-08T07:45:36.650Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['87','0','208','53','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings\n\n\ndef run_clingo():\n    files = [\n        f'lp/simulation_labels.lp',  \n        'lp/background.lp',              \n        'lp/frozen_rules.lp',            \n        'lp/rules2.lp'                   \n    ]\n    \n    command = ['clingo'] + files + ['--outf=2'] + ['--time-limit=30'] \n    print(' '.join(command))\n    result = subprocess.run(command, capture_output=True, text=True)\n\n    return result.stdout\n\ndef parse_clingo_output(data):\n    # Load the data using json.loads if 'data' is a string,\n    # otherwise assume it's already a dictionary\n    if isinstance(data, str):\n        #print(data)\n        data = json.loads(data.replace(\"'\", '\"'))\n    # Navigate through the JSON structure\n    # Assuming 'Call' is always present and has at least one element\n    calls = data.get(\"Call\", [])\n    if calls:\n        # Assuming 'Witnesses' is always present in the last element of 'Call' and has at least one element\n        last_call = calls[-1]\n        witnesses = last_call.get(\"Witnesses\", [])\n        if witnesses:\n            # Get the last 'Witnesses' entry\n            last_witness = witnesses[-1]\n            # Return the 'Value' list from the last 'Witnesses' entry\n            return last_witness.get(\"Value\", [])\n    return []\n\ndef extract_summary_rules(clingo_output):\n    # a summary rule is one prefixed by rule_contains(number)\n    summary_rules_by_prefix = defaultdict(list)\n    for line in clingo_output:\n        if line.startswith('rule_contains'):\n\n            number_str = line.split('(')[0].split('rule_contains')[1]\n            number = int(number_str) if number_str.isdigit() else 0\n\n            rule = line.split('(')[1].split(')')[0]\n            summary_rules_by_prefix[number].append(rule)\n    return summary_rules_by_prefix\n\ndef calculate_rule_percentage(clingo_output, positive"],time:'2024-09-08T07:45:36.667Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['87','0','206','34','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings\n\n\ndef run_clingo():\n    files = [\n        f'lp/simulation_labels.lp',  \n        'lp/background.lp',              \n        'lp/frozen_rules.lp',            \n        'lp/rules2.lp'                   \n    ]\n    \n    command = ['clingo'] + files + ['--outf=2'] + ['--time-limit=30'] \n    print(' '.join(command))\n    result = subprocess.run(command, capture_output=True, text=True)\n\n    return result.stdout\n\ndef parse_clingo_output(data):\n    # Load the data using json.loads if 'data' is a string,\n    # otherwise assume it's already a dictionary\n    if isinstance(data, str):\n        #print(data)\n        data = json.loads(data.replace(\"'\", '\"'))\n    # Navigate through the JSON structure\n    # Assuming 'Call' is always present and has at least one element\n    calls = data.get(\"Call\", [])\n    if calls:\n        # Assuming 'Witnesses' is always present in the last element of 'Call' and has at least one element\n        last_call = calls[-1]\n        witnesses = last_call.get(\"Witnesses\", [])\n        if witnesses:\n            # Get the last 'Witnesses' entry\n            last_witness = witnesses[-1]\n            # Return the 'Value' list from the last 'Witnesses' entry\n            return last_witness.get(\"Value\", [])\n    return []\n\ndef extract_summary_rules(clingo_output):\n    # a summary rule is one prefixed by rule_contains(number)\n    summary_rules_by_prefix = defaultdict(list)\n    for line in clingo_output:\n        if line.startswith('rule_contains'):\n\n            number_str = line.split('(')[0].split('rule_contains')[1]\n            number = int(number_str) if number_str.isdigit() else 0\n\n            rule = line.split('(')[1].split(')')[0]\n            summary_rules_by_prefix[number].append(rule)\n    return summary_rules_by_prefix"],time:'2024-09-08T07:45:36.683Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['87','0','204','51','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings\n\n\ndef run_clingo():\n    files = [\n        f'lp/simulation_labels.lp',  \n        'lp/background.lp',              \n        'lp/frozen_rules.lp',            \n        'lp/rules2.lp'                   \n    ]\n    \n    command = ['clingo'] + files + ['--outf=2'] + ['--time-limit=30'] \n    print(' '.join(command))\n    result = subprocess.run(command, capture_output=True, text=True)\n\n    return result.stdout\n\ndef parse_clingo_output(data):\n    # Load the data using json.loads if 'data' is a string,\n    # otherwise assume it's already a dictionary\n    if isinstance(data, str):\n        #print(data)\n        data = json.loads(data.replace(\"'\", '\"'))\n    # Navigate through the JSON structure\n    # Assuming 'Call' is always present and has at least one element\n    calls = data.get(\"Call\", [])\n    if calls:\n        # Assuming 'Witnesses' is always present in the last element of 'Call' and has at least one element\n        last_call = calls[-1]\n        witnesses = last_call.get(\"Witnesses\", [])\n        if witnesses:\n            # Get the last 'Witnesses' entry\n            last_witness = witnesses[-1]\n            # Return the 'Value' list from the last 'Witnesses' entry\n            return last_witness.get(\"Value\", [])\n    return []\n\ndef extract_summary_rules(clingo_output):\n    # a summary rule is one prefixed by rule_contains(number)\n    summary_rules_by_prefix = defaultdict(list)\n    for line in clingo_output:\n        if line.startswith('rule_contains'):\n\n            number_str = line.split('(')[0].split('rule_contains')[1]\n            number = int(number_str) if number_str.isdigit() else 0\n\n            rule = line.split('(')[1].split(')')[0]"],time:'2024-09-08T07:45:36.700Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['87','0','201','53','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings\n\n\ndef run_clingo():\n    files = [\n        f'lp/simulation_labels.lp',  \n        'lp/background.lp',              \n        'lp/frozen_rules.lp',            \n        'lp/rules2.lp'                   \n    ]\n    \n    command = ['clingo'] + files + ['--outf=2'] + ['--time-limit=30'] \n    print(' '.join(command))\n    result = subprocess.run(command, capture_output=True, text=True)\n\n    return result.stdout\n\ndef parse_clingo_output(data):\n    # Load the data using json.loads if 'data' is a string,\n    # otherwise assume it's already a dictionary\n    if isinstance(data, str):\n        #print(data)\n        data = json.loads(data.replace(\"'\", '\"'))\n    # Navigate through the JSON structure\n    # Assuming 'Call' is always present and has at least one element\n    calls = data.get(\"Call\", [])\n    if calls:\n        # Assuming 'Witnesses' is always present in the last element of 'Call' and has at least one element\n        last_call = calls[-1]\n        witnesses = last_call.get(\"Witnesses\", [])\n        if witnesses:\n            # Get the last 'Witnesses' entry\n            last_witness = witnesses[-1]\n            # Return the 'Value' list from the last 'Witnesses' entry\n            return last_witness.get(\"Value\", [])\n    return []\n\ndef extract_summary_rules(clingo_output):\n    # a summary rule is one prefixed by rule_contains(number)\n    summary_rules_by_prefix = defaultdict(list)\n    for line in clingo_output:\n        if line.startswith('rule_contains'):\n\n            number_str = line.split('(')[0].split('ru"],time:'2024-09-08T07:45:36.717Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['87','0','198','30','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings\n\n\ndef run_clingo():\n    files = [\n        f'lp/simulation_labels.lp',  \n        'lp/background.lp',              \n        'lp/frozen_rules.lp',            \n        'lp/rules2.lp'                   \n    ]\n    \n    command = ['clingo'] + files + ['--outf=2'] + ['--time-limit=30'] \n    print(' '.join(command))\n    result = subprocess.run(command, capture_output=True, text=True)\n\n    return result.stdout\n\ndef parse_clingo_output(data):\n    # Load the data using json.loads if 'data' is a string,\n    # otherwise assume it's already a dictionary\n    if isinstance(data, str):\n        #print(data)\n        data = json.loads(data.replace(\"'\", '\"'))\n    # Navigate through the JSON structure\n    # Assuming 'Call' is always present and has at least one element\n    calls = data.get(\"Call\", [])\n    if calls:\n        # Assuming 'Witnesses' is always present in the last element of 'Call' and has at least one element\n        last_call = calls[-1]\n        witnesses = last_call.get(\"Witnesses\", [])\n        if witnesses:\n            # Get the last 'Witnesses' entry\n            last_witness = witnesses[-1]\n            # Return the 'Value' list from the last 'Witnesses' entry\n            return last_witness.get(\"Value\", [])\n    return []\n\ndef extract_summary_rules(clingo_output):\n    # a summary rule is one prefixed by rule_contains(number)\n    summary_rules_by_prefix = defaultdict(list)\n    for line in clingo_output:"],time:'2024-09-08T07:45:36.734Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['87','0','197','47','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings\n\n\ndef run_clingo():\n    files = [\n        f'lp/simulation_labels.lp',  \n        'lp/background.lp',              \n        'lp/frozen_rules.lp',            \n        'lp/rules2.lp'                   \n    ]\n    \n    command = ['clingo'] + files + ['--outf=2'] + ['--time-limit=30'] \n    print(' '.join(command))\n    result = subprocess.run(command, capture_output=True, text=True)\n\n    return result.stdout\n\ndef parse_clingo_output(data):\n    # Load the data using json.loads if 'data' is a string,\n    # otherwise assume it's already a dictionary\n    if isinstance(data, str):\n        #print(data)\n        data = json.loads(data.replace(\"'\", '\"'))\n    # Navigate through the JSON structure\n    # Assuming 'Call' is always present and has at least one element\n    calls = data.get(\"Call\", [])\n    if calls:\n        # Assuming 'Witnesses' is always present in the last element of 'Call' and has at least one element\n        last_call = calls[-1]\n        witnesses = last_call.get(\"Witnesses\", [])\n        if witnesses:\n            # Get the last 'Witnesses' entry\n            last_witness = witnesses[-1]\n            # Return the 'Value' list from the last 'Witnesses' entry\n            return last_witness.get(\"Value\", [])\n    return []\n\ndef extract_summary_rules(clingo_output):\n    # a summary rule is one prefixed by rule_contains(number)\n    summary_rules_by_prefix = defaultdict(list)"],time:'2024-09-08T07:45:36.750Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['87','0','196','54','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings\n\n\ndef run_clingo():\n    files = [\n        f'lp/simulation_labels.lp',  \n        'lp/background.lp',              \n        'lp/frozen_rules.lp',            \n        'lp/rules2.lp'                   \n    ]\n    \n    command = ['clingo'] + files + ['--outf=2'] + ['--time-limit=30'] \n    print(' '.join(command))\n    result = subprocess.run(command, capture_output=True, text=True)\n\n    return result.stdout\n\ndef parse_clingo_output(data):\n    # Load the data using json.loads if 'data' is a string,\n    # otherwise assume it's already a dictionary\n    if isinstance(data, str):\n        #print(data)\n        data = json.loads(data.replace(\"'\", '\"'))\n    # Navigate through the JSON structure\n    # Assuming 'Call' is always present and has at least one element\n    calls = data.get(\"Call\", [])\n    if calls:\n        # Assuming 'Witnesses' is always present in the last element of 'Call' and has at least one element\n        last_call = calls[-1]\n        witnesses = last_call.get(\"Witnesses\", [])\n        if witnesses:\n            # Get the last 'Witnesses' entry\n            last_witness = witnesses[-1]\n            # Return the 'Value' list from the last 'Witnesses' entry\n            return last_witness.get(\"Value\", [])\n    return []\n\ndef extract_summary_rules(clingo_output):\n    # a summary rule is one prefixed by rule_contains("],time:'2024-09-08T07:45:36.767Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['87','0','195','41','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings\n\n\ndef run_clingo():\n    files = [\n        f'lp/simulation_labels.lp',  \n        'lp/background.lp',              \n        'lp/frozen_rules.lp',            \n        'lp/rules2.lp'                   \n    ]\n    \n    command = ['clingo'] + files + ['--outf=2'] + ['--time-limit=30'] \n    print(' '.join(command))\n    result = subprocess.run(command, capture_output=True, text=True)\n\n    return result.stdout\n\ndef parse_clingo_output(data):\n    # Load the data using json.loads if 'data' is a string,\n    # otherwise assume it's already a dictionary\n    if isinstance(data, str):\n        #print(data)\n        data = json.loads(data.replace(\"'\", '\"'))\n    # Navigate through the JSON structure\n    # Assuming 'Call' is always present and has at least one element\n    calls = data.get(\"Call\", [])\n    if calls:\n        # Assuming 'Witnesses' is always present in the last element of 'Call' and has at least one element\n        last_call = calls[-1]\n        witnesses = last_call.get(\"Witnesses\", [])\n        if witnesses:\n            # Get the last 'Witnesses' entry\n            last_witness = witnesses[-1]\n            # Return the 'Value' list from the last 'Witnesses' entry\n            return last_witness.get(\"Value\", [])\n    return []\n\ndef extract_summary_rules(clingo_output):"],time:'2024-09-08T07:45:36.783Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['87','0','194','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings\n\n\ndef run_clingo():\n    files = [\n        f'lp/simulation_labels.lp',  \n        'lp/background.lp',              \n        'lp/frozen_rules.lp',            \n        'lp/rules2.lp'                   \n    ]\n    \n    command = ['clingo'] + files + ['--outf=2'] + ['--time-limit=30'] \n    print(' '.join(command))\n    result = subprocess.run(command, capture_output=True, text=True)\n\n    return result.stdout\n\ndef parse_clingo_output(data):\n    # Load the data using json.loads if 'data' is a string,\n    # otherwise assume it's already a dictionary\n    if isinstance(data, str):\n        #print(data)\n        data = json.loads(data.replace(\"'\", '\"'))\n    # Navigate through the JSON structure\n    # Assuming 'Call' is always present and has at least one element\n    calls = data.get(\"Call\", [])\n    if calls:\n        # Assuming 'Witnesses' is always present in the last element of 'Call' and has at least one element\n        last_call = calls[-1]\n        witnesses = last_call.get(\"Witnesses\", [])\n        if witnesses:\n            # Get the last 'Witnesses' entry\n            last_witness = witnesses[-1]\n            # Return the 'Value' list from the last 'Witnesses' entry\n            return last_witness.get(\"Value\", [])\n    return []\n"],time:'2024-09-08T07:45:36.933Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['87','0','193','13','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings\n\n\ndef run_clingo():\n    files = [\n        f'lp/simulation_labels.lp',  \n        'lp/background.lp',              \n        'lp/frozen_rules.lp',            \n        'lp/rules2.lp'                   \n    ]\n    \n    command = ['clingo'] + files + ['--outf=2'] + ['--time-limit=30'] \n    print(' '.join(command))\n    result = subprocess.run(command, capture_output=True, text=True)\n\n    return result.stdout\n\ndef parse_clingo_output(data):\n    # Load the data using json.loads if 'data' is a string,\n    # otherwise assume it's already a dictionary\n    if isinstance(data, str):\n        #print(data)\n        data = json.loads(data.replace(\"'\", '\"'))\n    # Navigate through the JSON structure\n    # Assuming 'Call' is always present and has at least one element\n    calls = data.get(\"Call\", [])\n    if calls:\n        # Assuming 'Witnesses' is always present in the last element of 'Call' and has at least one element\n        last_call = calls[-1]\n        witnesses = last_call.get(\"Witnesses\", [])\n        if witnesses:\n            # Get the last 'Witnesses' entry\n            last_witness = witnesses[-1]\n            # Return the 'Value' list from the last 'Witnesses' entry\n            return last_witness.get(\"Value\", [])\n    return []"],time:'2024-09-08T07:45:36.967Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['87','0','191','59','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings\n\n\ndef run_clingo():\n    files = [\n        f'lp/simulation_labels.lp',  \n        'lp/background.lp',              \n        'lp/frozen_rules.lp',            \n        'lp/rules2.lp'                   \n    ]\n    \n    command = ['clingo'] + files + ['--outf=2'] + ['--time-limit=30'] \n    print(' '.join(command))\n    result = subprocess.run(command, capture_output=True, text=True)\n\n    return result.stdout\n\ndef parse_clingo_output(data):\n    # Load the data using json.loads if 'data' is a string,\n    # otherwise assume it's already a dictionary\n    if isinstance(data, str):\n        #print(data)\n        data = json.loads(data.replace(\"'\", '\"'))\n    # Navigate through the JSON structure\n    # Assuming 'Call' is always present and has at least one element\n    calls = data.get(\"Call\", [])\n    if calls:\n        # Assuming 'Witnesses' is always present in the last element of 'Call' and has at least one element\n        last_call = calls[-1]\n        witnesses = last_call.get(\"Witnesses\", [])\n        if witnesses:\n            # Get the last 'Witnesses' entry\n            last_witness = witnesses[-1]\n            # Return the 'Value' list from the last 'Witnes"],time:'2024-09-08T07:45:36.983Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['87','0','190','40','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings\n\n\ndef run_clingo():\n    files = [\n        f'lp/simulation_labels.lp',  \n        'lp/background.lp',              \n        'lp/frozen_rules.lp',            \n        'lp/rules2.lp'                   \n    ]\n    \n    command = ['clingo'] + files + ['--outf=2'] + ['--time-limit=30'] \n    print(' '.join(command))\n    result = subprocess.run(command, capture_output=True, text=True)\n\n    return result.stdout\n\ndef parse_clingo_output(data):\n    # Load the data using json.loads if 'data' is a string,\n    # otherwise assume it's already a dictionary\n    if isinstance(data, str):\n        #print(data)\n        data = json.loads(data.replace(\"'\", '\"'))\n    # Navigate through the JSON structure\n    # Assuming 'Call' is always present and has at least one element\n    calls = data.get(\"Call\", [])\n    if calls:\n        # Assuming 'Witnesses' is always present in the last element of 'Call' and has at least one element\n        last_call = calls[-1]\n        witnesses = last_call.get(\"Witnesses\", [])\n        if witnesses:\n            # Get the last 'Witnesses' entry\n            last_witness = witnesses[-1]"],time:'2024-09-08T07:45:37.000Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['87','0','188','21','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings\n\n\ndef run_clingo():\n    files = [\n        f'lp/simulation_labels.lp',  \n        'lp/background.lp',              \n        'lp/frozen_rules.lp',            \n        'lp/rules2.lp'                   \n    ]\n    \n    command = ['clingo'] + files + ['--outf=2'] + ['--time-limit=30'] \n    print(' '.join(command))\n    result = subprocess.run(command, capture_output=True, text=True)\n\n    return result.stdout\n\ndef parse_clingo_output(data):\n    # Load the data using json.loads if 'data' is a string,\n    # otherwise assume it's already a dictionary\n    if isinstance(data, str):\n        #print(data)\n        data = json.loads(data.replace(\"'\", '\"'))\n    # Navigate through the JSON structure\n    # Assuming 'Call' is always present and has at least one element\n    calls = data.get(\"Call\", [])\n    if calls:\n        # Assuming 'Witnesses' is always present in the last element of 'Call' and has at least one element\n        last_call = calls[-1]\n        witnesses = last_call.get(\"Witnesses\", [])\n        if witnesses:"],time:'2024-09-08T07:45:37.033Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['87','0','189','44','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings\n\n\ndef run_clingo():\n    files = [\n        f'lp/simulation_labels.lp',  \n        'lp/background.lp',              \n        'lp/frozen_rules.lp',            \n        'lp/rules2.lp'                   \n    ]\n    \n    command = ['clingo'] + files + ['--outf=2'] + ['--time-limit=30'] \n    print(' '.join(command))\n    result = subprocess.run(command, capture_output=True, text=True)\n\n    return result.stdout\n\ndef parse_clingo_output(data):\n    # Load the data using json.loads if 'data' is a string,\n    # otherwise assume it's already a dictionary\n    if isinstance(data, str):\n        #print(data)\n        data = json.loads(data.replace(\"'\", '\"'))\n    # Navigate through the JSON structure\n    # Assuming 'Call' is always present and has at least one element\n    calls = data.get(\"Call\", [])\n    if calls:\n        # Assuming 'Witnesses' is always present in the last element of 'Call' and has at least one element\n        last_call = calls[-1]\n        witnesses = last_call.get(\"Witnesses\", [])\n        if witnesses:\n            # Get the last 'Witnesses' entry"],time:'2024-09-08T07:45:37.180Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['181','0','209','47','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:37.599Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['180','0','208','67','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:37.633Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['179','0','207','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:37.650Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['177','0','205','56','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:37.667Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['175','0','203','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:37.683Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['173','0','201','69','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:37.699Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['172','0','200','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:37.716Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['171','0','199','44','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:37.733Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['170','0','198','30','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:37.750Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['169','0','197','47','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:37.766Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['167','0','195','41','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:37.783Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['165','0','193','13','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:37.800Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['163','0','191','69','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:37.816Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['161','0','189','44','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:37.833Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['160','0','188','21','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:37.850Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['158','0','186','29','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:37.866Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['156','0','184','13','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:37.883Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['155','0','183','32','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:37.966Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['154','0','182','68','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:38.000Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['153','0','181','41','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:38.016Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['152','0','180','49','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:38.033Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['151','0','179','20','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:38.068Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['150','0','178','29','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:38.083Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['148','0','176','59','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:38.100Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['147','0','175','30','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:38.116Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['146','0','174','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:38.133Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['145','0','173','24','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:38.166Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['144','0','172','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:38.250Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['143','0','171','68','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:38.300Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['142','0','170','28','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:38.366Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['155','43','155','43','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',''],time:'2024-09-08T07:45:38.872Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['158','65','158','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',''],time:'2024-09-08T07:45:39.599Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['158','60','158','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py','nings'],time:'2024-09-08T07:45:39.787Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['158','55','158','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py','e_warnings'],time:'2024-09-08T07:45:39.803Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['157','4','158','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py','\n    return selected_positive_warnings, selected_negative_warnings'],time:'2024-09-08T07:45:39.818Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['155','41','158','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"elected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings"],time:'2024-09-08T07:45:39.834Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['153','34','158','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings"],time:'2024-09-08T07:45:39.852Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['152','28','158','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"ted_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings"],time:'2024-09-08T07:45:39.868Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['151','23','158','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"ve_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings"],time:'2024-09-08T07:45:39.884Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['150','18','158','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"ositive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings"],time:'2024-09-08T07:45:39.901Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['149','15','158','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"t the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings"],time:'2024-09-08T07:45:39.918Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['148','9','158','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings"],time:'2024-09-08T07:45:39.934Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['147','10','158','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"rint('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings"],time:'2024-09-08T07:45:39.950Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['147','8','158','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"#print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings"],time:'2024-09-08T07:45:39.967Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['146','7','158','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'," warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings"],time:'2024-09-08T07:45:39.983Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['145','5','158','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"   selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings"],time:'2024-09-08T07:45:40.000Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['145','4','158','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"    selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings"],time:'2024-09-08T07:45:40.016Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['145','3','158','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"     selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings"],time:'2024-09-08T07:45:40.033Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['144','3','158','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"     selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings"],time:'2024-09-08T07:45:40.050Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['144','2','158','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"      selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings"],time:'2024-09-08T07:45:40.067Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['144','1','158','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"       selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings"],time:'2024-09-08T07:45:40.083Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['143','1','158','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"       # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings"],time:'2024-09-08T07:45:40.100Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['143','0','158','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings"],time:'2024-09-08T07:45:40.117Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['142','0','158','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings"],time:'2024-09-08T07:45:40.150Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['141','0','158','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings"],time:'2024-09-08T07:45:40.217Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['141','0','169','70','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:40.233Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['140','0','158','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings"],time:'2024-09-08T07:45:40.236Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['140','0','168','4','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:40.249Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['139','0','158','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings"],time:'2024-09-08T07:45:40.253Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['139','0','167','5','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:40.266Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['138','0','158','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings"],time:'2024-09-08T07:45:40.269Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['138','0','166','41','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:40.282Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['137','0','158','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings"],time:'2024-09-08T07:45:40.285Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['136','0','164','41','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:40.299Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['135','0','158','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings"],time:'2024-09-08T07:45:40.303Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['134','0','162','13','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:40.316Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['133','0','158','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings"],time:'2024-09-08T07:45:40.320Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['132','0','160','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:40.333Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['131','0','158','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings"],time:'2024-09-08T07:45:40.336Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['130','0','158','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:40.349Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['130','0','158','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings"],time:'2024-09-08T07:45:40.352Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['129','0','157','4','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:40.366Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['128','0','158','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings"],time:'2024-09-08T07:45:40.369Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['127','0','155','67','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:40.383Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['126','0','158','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings"],time:'2024-09-08T07:45:40.387Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['125','0','153','53','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:40.399Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['124','0','158','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings"],time:'2024-09-08T07:45:40.404Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['123','0','151','54','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:40.416Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['122','0','158','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings"],time:'2024-09-08T07:45:40.420Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['121','0','149','49','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:40.433Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['120','0','158','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings"],time:'2024-09-08T07:45:40.437Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['120','0','148','9','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:40.450Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['119','0','158','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings"],time:'2024-09-08T07:45:40.453Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['118','0','146','66','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:40.465Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['117','0','158','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings"],time:'2024-09-08T07:45:40.470Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['116','0','144','53','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:40.483Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['115','0','158','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings"],time:'2024-09-08T07:45:40.486Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['114','0','142','31','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:40.499Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['113','0','158','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings"],time:'2024-09-08T07:45:40.503Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['112','0','140','55','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:40.516Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['112','0','158','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings"],time:'2024-09-08T07:45:40.519Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['111','0','139','72','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:40.533Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['110','0','158','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings"],time:'2024-09-08T07:45:40.536Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['109','0','137','48','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:40.550Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['109','0','158','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings"],time:'2024-09-08T07:45:40.553Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['108','0','158','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings"],time:'2024-09-08T07:45:40.573Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['108','0','136','39','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:40.586Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['107','0','158','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings"],time:'2024-09-08T07:45:40.590Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['109','0','158','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings"],time:'2024-09-08T07:45:40.600Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['111','0','158','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings"],time:'2024-09-08T07:45:40.617Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['113','0','158','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings"],time:'2024-09-08T07:45:40.634Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['115','0','158','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings"],time:'2024-09-08T07:45:40.650Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['116','0','158','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings"],time:'2024-09-08T07:45:40.667Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['117','0','158','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings"],time:'2024-09-08T07:45:40.701Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['118','0','158','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings"],time:'2024-09-08T07:45:40.934Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['119','0','158','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings"],time:'2024-09-08T07:45:40.950Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['120','0','158','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings"],time:'2024-09-08T07:45:40.967Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['121','0','158','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings"],time:'2024-09-08T07:45:41.017Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['120','0','158','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings"],time:'2024-09-08T07:45:41.429Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['119','0','158','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings"],time:'2024-09-08T07:45:41.500Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['118','0','158','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings"],time:'2024-09-08T07:45:41.550Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['117','0','158','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings"],time:'2024-09-08T07:45:41.601Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['116','0','158','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings"],time:'2024-09-08T07:45:41.650Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['115','0','158','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings"],time:'2024-09-08T07:45:41.683Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['114','0','158','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings"],time:'2024-09-08T07:45:41.767Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['113','0','158','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings"],time:'2024-09-08T07:45:41.833Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['112','0','158','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings"],time:'2024-09-08T07:45:42.000Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['111','0','158','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings"],time:'2024-09-08T07:45:42.134Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['110','0','158','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings"],time:'2024-09-08T07:45:42.217Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['109','0','158','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings"],time:'2024-09-08T07:45:42.317Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['108','0','158','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings"],time:'2024-09-08T07:45:42.417Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['107','0','158','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings"],time:'2024-09-08T07:45:42.717Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['107','0','135','43','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:42.733Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['106','0','158','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings"],time:'2024-09-08T07:45:42.738Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['106','0','134','13','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:42.750Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['105','0','158','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings"],time:'2024-09-08T07:45:42.753Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['105','0','133','44','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:42.783Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['104','0','158','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings"],time:'2024-09-08T07:45:42.786Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['104','0','132','39','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:42.815Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['103','0','158','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings"],time:'2024-09-08T07:45:42.818Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['103','0','131','43','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:42.832Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['102','0','158','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings"],time:'2024-09-08T07:45:42.852Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['102','0','130','88','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:42.865Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['101','0','158','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings"],time:'2024-09-08T07:45:42.869Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['101','0','129','34','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:42.899Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['100','0','158','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings"],time:'2024-09-08T07:45:42.902Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['100','0','128','169','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:42.915Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['99','0','158','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings"],time:'2024-09-08T07:45:42.918Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['99','0','127','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:42.932Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['98','0','158','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings"],time:'2024-09-08T07:45:42.935Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['98','0','126','68','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:42.965Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['97','0','158','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings"],time:'2024-09-08T07:45:42.968Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['97','0','125','67','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:42.982Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['96','0','158','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings"],time:'2024-09-08T07:45:42.985Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['96','0','124','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:42.998Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['95','0','158','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings"],time:'2024-09-08T07:45:43.001Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['95','0','123','172','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:43.015Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['94','0','158','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings"],time:'2024-09-08T07:45:43.018Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['94','0','122','39','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:43.032Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['93','0','158','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings"],time:'2024-09-08T07:45:43.038Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['93','0','121','28','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:43.066Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['92','0','158','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings"],time:'2024-09-08T07:45:43.069Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['92','0','120','72','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:43.083Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['91','0','158','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings"],time:'2024-09-08T07:45:43.086Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['91','0','119','28','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:43.116Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['90','0','158','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings"],time:'2024-09-08T07:45:43.119Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['90','0','118','64','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:43.150Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['89','0','158','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings"],time:'2024-09-08T07:45:43.152Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['89','0','117','28','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:43.166Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['90','0','158','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings"],time:'2024-09-08T07:45:43.183Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['89','0','158','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings"],time:'2024-09-08T07:45:43.584Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['88','0','158','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings"],time:'2024-09-08T07:45:43.608Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['88','0','116','61','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:43.616Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['87','0','158','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings"],time:'2024-09-08T07:45:43.621Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['87','0','115','26','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:43.650Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['86','0','158','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"\ndef sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings"],time:'2024-09-08T07:45:43.653Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['86','0','114','38','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:43.683Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['85','0','158','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"    return correct_labels / len(ground_truth) * 100\n\ndef sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings"],time:'2024-09-08T07:45:43.686Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['85','0','113','36','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:43.699Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['84','0','158','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"    correct_labels = sum(1 for k, v in warnings_state.items() if v == ground_truth[k])\n    return correct_labels / len(ground_truth) * 100\n\ndef sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings"],time:'2024-09-08T07:45:43.703Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['84','0','112','45','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:43.733Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['83','0','158','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"    \"\"\"Calculate the accuracy by comparing the current state of warnings with the ground truth.\"\"\"\n    correct_labels = sum(1 for k, v in warnings_state.items() if v == ground_truth[k])\n    return correct_labels / len(ground_truth) * 100\n\ndef sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings"],time:'2024-09-08T07:45:43.736Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['83','0','111','4','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:43.766Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['82','0','158','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def calculate_accuracy(warnings_state, ground_truth):\n    \"\"\"Calculate the accuracy by comparing the current state of warnings with the ground truth.\"\"\"\n    correct_labels = sum(1 for k, v in warnings_state.items() if v == ground_truth[k])\n    return correct_labels / len(ground_truth) * 100\n\ndef sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings"],time:'2024-09-08T07:45:43.770Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['82','0','110','21','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:43.783Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['81','0','158','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"\ndef calculate_accuracy(warnings_state, ground_truth):\n    \"\"\"Calculate the accuracy by comparing the current state of warnings with the ground truth.\"\"\"\n    correct_labels = sum(1 for k, v in warnings_state.items() if v == ground_truth[k])\n    return correct_labels / len(ground_truth) * 100\n\ndef sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings"],time:'2024-09-08T07:45:43.786Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['81','0','109','79','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:43.816Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['80','0','158','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"    return {k: 'uninspected' for k in ground_truth.keys()}\n\ndef calculate_accuracy(warnings_state, ground_truth):\n    \"\"\"Calculate the accuracy by comparing the current state of warnings with the ground truth.\"\"\"\n    correct_labels = sum(1 for k, v in warnings_state.items() if v == ground_truth[k])\n    return correct_labels / len(ground_truth) * 100\n\ndef sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings"],time:'2024-09-08T07:45:43.819Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['80','0','108','4','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:43.850Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['79','0','158','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"    \"\"\"Initialize all warnings with the state 'uninspected'.\"\"\"\n    return {k: 'uninspected' for k in ground_truth.keys()}\n\ndef calculate_accuracy(warnings_state, ground_truth):\n    \"\"\"Calculate the accuracy by comparing the current state of warnings with the ground truth.\"\"\"\n    correct_labels = sum(1 for k, v in warnings_state.items() if v == ground_truth[k])\n    return correct_labels / len(ground_truth) * 100\n\ndef sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings"],time:'2024-09-08T07:45:43.853Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['79','0','107','61','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:43.866Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['78','0','158','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def initialize_warnings_state(ground_truth):\n    \"\"\"Initialize all warnings with the state 'uninspected'.\"\"\"\n    return {k: 'uninspected' for k in ground_truth.keys()}\n\ndef calculate_accuracy(warnings_state, ground_truth):\n    \"\"\"Calculate the accuracy by comparing the current state of warnings with the ground truth.\"\"\"\n    correct_labels = sum(1 for k, v in warnings_state.items() if v == ground_truth[k])\n    return correct_labels / len(ground_truth) * 100\n\ndef sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings"],time:'2024-09-08T07:45:43.887Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['78','0','106','28','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:43.900Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['77','0','158','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"\ndef initialize_warnings_state(ground_truth):\n    \"\"\"Initialize all warnings with the state 'uninspected'.\"\"\"\n    return {k: 'uninspected' for k in ground_truth.keys()}\n\ndef calculate_accuracy(warnings_state, ground_truth):\n    \"\"\"Calculate the accuracy by comparing the current state of warnings with the ground truth.\"\"\"\n    correct_labels = sum(1 for k, v in warnings_state.items() if v == ground_truth[k])\n    return correct_labels / len(ground_truth) * 100\n\ndef sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings"],time:'2024-09-08T07:45:43.903Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['78','0','158','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def initialize_warnings_state(ground_truth):\n    \"\"\"Initialize all warnings with the state 'uninspected'.\"\"\"\n    return {k: 'uninspected' for k in ground_truth.keys()}\n\ndef calculate_accuracy(warnings_state, ground_truth):\n    \"\"\"Calculate the accuracy by comparing the current state of warnings with the ground truth.\"\"\"\n    correct_labels = sum(1 for k, v in warnings_state.items() if v == ground_truth[k])\n    return correct_labels / len(ground_truth) * 100\n\ndef sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings"],time:'2024-09-08T07:45:43.917Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['79','0','158','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"    \"\"\"Initialize all warnings with the state 'uninspected'.\"\"\"\n    return {k: 'uninspected' for k in ground_truth.keys()}\n\ndef calculate_accuracy(warnings_state, ground_truth):\n    \"\"\"Calculate the accuracy by comparing the current state of warnings with the ground truth.\"\"\"\n    correct_labels = sum(1 for k, v in warnings_state.items() if v == ground_truth[k])\n    return correct_labels / len(ground_truth) * 100\n\ndef sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings"],time:'2024-09-08T07:45:43.950Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['80','0','158','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"    return {k: 'uninspected' for k in ground_truth.keys()}\n\ndef calculate_accuracy(warnings_state, ground_truth):\n    \"\"\"Calculate the accuracy by comparing the current state of warnings with the ground truth.\"\"\"\n    correct_labels = sum(1 for k, v in warnings_state.items() if v == ground_truth[k])\n    return correct_labels / len(ground_truth) * 100\n\ndef sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings"],time:'2024-09-08T07:45:43.967Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['81','0','158','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"\ndef calculate_accuracy(warnings_state, ground_truth):\n    \"\"\"Calculate the accuracy by comparing the current state of warnings with the ground truth.\"\"\"\n    correct_labels = sum(1 for k, v in warnings_state.items() if v == ground_truth[k])\n    return correct_labels / len(ground_truth) * 100\n\ndef sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings"],time:'2024-09-08T07:45:43.983Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['82','0','158','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def calculate_accuracy(warnings_state, ground_truth):\n    \"\"\"Calculate the accuracy by comparing the current state of warnings with the ground truth.\"\"\"\n    correct_labels = sum(1 for k, v in warnings_state.items() if v == ground_truth[k])\n    return correct_labels / len(ground_truth) * 100\n\ndef sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings"],time:'2024-09-08T07:45:44.000Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['83','0','158','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"    \"\"\"Calculate the accuracy by comparing the current state of warnings with the ground truth.\"\"\"\n    correct_labels = sum(1 for k, v in warnings_state.items() if v == ground_truth[k])\n    return correct_labels / len(ground_truth) * 100\n\ndef sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings"],time:'2024-09-08T07:45:44.017Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['84','0','158','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"    correct_labels = sum(1 for k, v in warnings_state.items() if v == ground_truth[k])\n    return correct_labels / len(ground_truth) * 100\n\ndef sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings"],time:'2024-09-08T07:45:44.033Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['85','0','158','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"    return correct_labels / len(ground_truth) * 100\n\ndef sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings"],time:'2024-09-08T07:45:44.050Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['86','0','158','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"\ndef sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings"],time:'2024-09-08T07:45:44.082Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['87','0','158','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings"],time:'2024-09-08T07:45:44.100Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['88','0','158','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings"],time:'2024-09-08T07:45:44.133Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['87','0','158','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings"],time:'2024-09-08T07:45:44.534Z'},{src:'onDidChangeTextDocument',msg:'%s:%s to %s:%s in [%s] replaced with: %s`',prm:['87','0','158','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5, warning_ids=None):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - If warning_ids is provided, apply the heuristics to only those warnings.\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n\n    # Determine which warnings to operate on: either from ground_truth or passed warning_ids\n    if warning_ids:\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k in warning_ids if warnings_state.get(k) == 'uninspected'\n        ]\n    else:\n        # Get all uninspected warnings with their lines of code and function calls\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n        ]\n\n    # Shuffle the warnings and sample based on the sampling ratio\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected or none passed, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), \n                                      heuristic_shared_function_calls(warnings), \n                                      heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # Classify warnings as positive or negative based on their position in the sorted list\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings\n"],time:'2024-09-08T07:45:45.396Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['78','0','106','9','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:45.405Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['167','0','167','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',''],time:'2024-09-08T07:45:45.406Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['140','0','168','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:45.406Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['141','0','169','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:46.517Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['142','0','170','17','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:46.533Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['143','0','171','13','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:46.550Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['144','0','172','37','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:46.566Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['145','0','173','41','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:46.583Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['147','0','175','41','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:46.600Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['148','0','176','5','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:46.617Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['149','0','177','4','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:46.650Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['150','0','178','70','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:46.666Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['151','0','179','28','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:46.683Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['152','0','180','68','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:46.700Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['154','0','182','24','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:46.716Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['155','0','183','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:46.733Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['157','0','185','59','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:46.750Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['158','0','186','48','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:46.766Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['159','0','187','29','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:46.783Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['161','0','189','49','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:46.800Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['163','0','191','68','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:46.816Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['164','0','192','32','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:46.833Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['165','0','193','13','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:46.850Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['167','0','195','29','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:46.866Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['168','0','196','50','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:46.883Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['169','0','197','21','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:46.900Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['170','0','198','44','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:46.916Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['171','0','199','40','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:46.950Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['172','0','200','69','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:46.966Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['173','0','201','48','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:46.983Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['174','0','202','13','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:47.017Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['175','0','203','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:47.050Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['177','0','205','61','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:47.133Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['180','0','208','44','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:47.149Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['187','0','215','34','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:47.166Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['196','0','224','32','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:47.183Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['207','0','235','54','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:47.200Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['219','0','247','30','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:47.218Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['230','0','258','31','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:47.233Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['240','0','268','43','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:47.250Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['250','0','278','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:47.266Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['260','0','288','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:47.283Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['269','0','297','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:47.300Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['277','0','305','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:47.316Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['285','0','313','59','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:47.334Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['292','0','320','26','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:47.350Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['299','0','327','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:47.366Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['306','0','334','31','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:47.383Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['313','0','341','31','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:47.400Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['319','0','347','8','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:47.416Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['325','0','353','4','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:47.433Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['327','0','355','49','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:47.533Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['332','0','360','98','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:47.549Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['343','0','371','76','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:47.566Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['355','0','383','56','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:47.599Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['368','0','396','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:47.616Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['380','0','408','44','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:47.633Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['391','0','419','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:47.650Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['402','0','430','22','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:47.666Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['412','0','440','21','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:47.683Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['421','0','449','94','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:47.700Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['430','0','458','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:47.716Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['438','0','466','39','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:47.733Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['447','0','475','38','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:47.750Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['454','0','482','82','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:47.766Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['462','0','488','86','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:47.783Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['469','0','488','86','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:47.800Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['470','0','488','86','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:47.917Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['471','0','488','86','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:47.932Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['472','0','488','86','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:47.949Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['473','0','488','86','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:47.982Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['474','0','488','86','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:47.999Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['475','0','488','86','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:48.016Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['476','0','488','86','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:48.036Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['477','0','488','86','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:48.050Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['478','0','488','86','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:48.083Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['479','0','488','86','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:48.133Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['480','0','488','86','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:48.150Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['481','0','488','86','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:48.166Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['482','0','488','86','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:48.200Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['483','0','488','86','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:48.233Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['482','0','488','86','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:48.333Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['481','0','488','86','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:48.349Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['480','0','488','86','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:48.366Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['478','0','488','86','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:48.383Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['477','0','488','86','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:48.400Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['475','0','488','86','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:48.416Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['473','0','488','86','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:48.433Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['471','0','488','86','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:48.449Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['468','0','488','86','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:48.465Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['465','0','488','86','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:48.482Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['462','0','488','86','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:48.499Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['459','0','487','21','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:48.515Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['456','0','484','47','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:48.532Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['453','0','481','56','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:48.549Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['449','0','477','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:48.566Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['446','0','474','44','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:48.583Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['443','0','471','47','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:48.600Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['441','0','469','47','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:48.616Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['438','0','466','39','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:48.633Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['437','0','465','25','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:48.766Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['436','0','464','41','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:48.816Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['435','0','463','25','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:48.883Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['434','0','462','41','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:48.950Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['433','0','461','25','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:48.966Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['432','0','460','39','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:48.983Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['431','0','459','32','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:49.000Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['430','0','458','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:49.032Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['429','0','457','80','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:49.050Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['428','0','456','108','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:49.066Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['427','0','455','75','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:49.100Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['426','0','454','76','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:49.116Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['425','0','453','71','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:49.133Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['424','0','452','53','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:49.150Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['423','0','451','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:49.200Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['422','0','450','86','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:49.216Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['421','0','449','94','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:49.233Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['420','0','448','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:49.250Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['419','0','447','39','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:49.283Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['418','0','446','21','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:49.300Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['417','0','445','82','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:49.333Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['416','0','444','33','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:49.383Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['415','0','443','70','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:51.100Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['414','0','442','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:51.150Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['413','0','441','35','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:51.183Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['412','0','440','21','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:51.217Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['411','0','439','91','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:51.302Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['410','0','438','48','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:51.467Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['409','0','437','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:51.617Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['408','0','436','90','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:51.649Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['407','0','435','47','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:51.683Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['406','0','434','87','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:51.716Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['405','0','433','74','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:51.767Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['404','0','432','61','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:52.101Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['403','0','431','51','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:52.166Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['402','0','430','22','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:52.202Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['401','0','429','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:52.216Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['400','0','428','37','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:52.250Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['399','0','427','33','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:52.366Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['398','0','426','64','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:52.450Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['397','0','425','49','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:52.533Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['418','52','418','52','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',''],time:'2024-09-08T07:45:53.503Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['418','49','418','52','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"ve'"],time:'2024-09-08T07:45:53.683Z'}]
[{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['352','0','373','32','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:07.711Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['352','0','374','86','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:07.729Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['353','0','374','86','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:07.762Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['353','0','375','41','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:07.812Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['354','0','375','41','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:07.845Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['354','0','376','30','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:07.912Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['355','0','376','30','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:07.945Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['355','0','377','59','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:07.979Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['356','0','377','59','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:07.995Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['356','0','378','80','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:08.062Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['356','0','379','40','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:15.866Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['356','0','381','89','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:15.907Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['356','0','383','96','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:15.935Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['356','0','384','54','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:15.964Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['378','49','378','49','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',''],time:'2024-09-08T07:39:16.382Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['377','49','378','49','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py','ut(output)\n                        rule_numbers = list(extra'],time:'2024-09-08T07:39:16.402Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['0','0','443','86','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"# the idea is to try different combinations \n# IMPORTANT: prequisites for running this script : run `meteor` in the `meteor_app` directory \n# Run one of \n# e.g., WARNING_TYPE=apache_lucene-solr__NULL_ WARNING_JSON_NAME=spotbugs_warnings_apache_lucene-solr__NULL_ meteor  \n# e.g., WARNING_JSON_NAME=infer_warnings_alibaba_nacos_NULL_DEREFERENCE meteor \n# e.g,, WARNING_TYPE=RESOURCE_LEAK__presto WARNING_JSON_NAME=infer_warnings_prestodb_presto_RESOURCE_LEAK meteor \n# and generate the background.lp file \n\nimport random\nimport subprocess\nimport sys\nimport os\nfrom collections import defaultdict\nimport json\nimport time\nimport matplotlib.pyplot as plt\n\ndef read_ground_truth(ground_truth_file):\n    ground_truth = {}\n    with open(ground_truth_file) as f:\n        for line in f:\n            line = line.strip().split()\n            ground_truth[line[0]] = line[1]\n    return ground_truth\n\ndef write_labels_to_clingo_input(poss, negs):\n    with open('lp/simulation_labels.lp', 'w+') as f:\n        for p in poss:\n            f.write(f'pos({p}).\\n')\n        for n in negs:\n            f.write(f'neg({n}).\\n')\n\ndef read_containment(containment_file='lp/background.lp'):\n    containment = {}\n    last_checked_id = -1  # Initialize last_checked_id to keep track of the last ID we processed\n\n    with open(containment_file) as f:\n        for line in f:\n            line = line.strip().split()\n\n            # If line contains 'containment', extract the warning ID\n            if 'containment' in line[0]:\n                id = int(line[0].split('containment(')[1].split(',')[0])\n\n                # Only process the first occurrence of each ID\n                if id != last_checked_id:\n                    loc = line[1].split(\")\")[0]\n                    loc = loc.replace('__', '.').replace('_', '.')\n                    last_checked_id = id  # Update last_checked_id to prevent re-checking this ID\n                    containment[id] = loc  # Store the location for this ID\n    return containment\n\ndef heuristic_shorter_code_first(warnings):\n    \"\"\"Sort the warnings by lines of code (ascending).\"\"\"\n    return sorted(warnings, key=lambda x: x[1])\n\ndef heuristic_shared_function_calls(warnings):\n    \"\"\"Sort the warnings by the number of shared function calls (descending).\"\"\"\n    def shared_function_calls(warning, other_warnings):\n        return sum(len(set(warning[2]).intersection(set(other[2]))) for other in other_warnings)\n    #print(sorted(warnings, key=lambda x: shared_function_calls(x, warnings), reverse=True))\n    return sorted(warnings, key=lambda x: shared_function_calls(x, warnings), reverse=True)\n\ndef heuristic_neighbor_classes(warnings, containment):\n    \"\"\"Sort the warnings by neighbor classes (contained in the same package or directory).\"\"\"\n    sorted_warnings = []\n    processed_locs = set()\n    \n    for i in range(len(warnings)):\n        loc = containment.get(int(warnings[i][0]))\n        if loc not in processed_locs:\n            # Find all warnings with the same location\n            same_loc_warnings = [warnings[j] for j in range(i, len(warnings)) if containment.get(int(warnings[j][0])) == loc]\n            sorted_warnings.extend(same_loc_warnings)\n            processed_locs.add(loc)\n    \n    return sorted_warnings\n\ndef initialize_warnings_state(ground_truth):\n    \"\"\"Initialize all warnings with the state 'uninspected'.\"\"\"\n    return {k: 'uninspected' for k in ground_truth.keys()}\n\ndef calculate_accuracy(warnings_state, ground_truth):\n    \"\"\"Calculate the accuracy by comparing the current state of warnings with the ground truth.\"\"\"\n    correct_labels = sum(1 for k, v in warnings_state.items() if v == ground_truth[k])\n    return correct_labels / len(ground_truth) * 100\n\ndef sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings\n\n\ndef run_clingo():\n    files = [\n        f'lp/simulation_labels.lp',  \n        'lp/background.lp',              \n        'lp/frozen_rules.lp',            \n        'lp/rules2.lp'                   \n    ]\n    \n    command = ['clingo'] + files + ['--outf=2'] + ['--time-limit=30'] \n    print(' '.join(command))\n    result = subprocess.run(command, capture_output=True, text=True)\n\n    return result.stdout\n\ndef parse_clingo_output(data):\n    # Load the data using json.loads if 'data' is a string,\n    # otherwise assume it's already a dictionary\n    if isinstance(data, str):\n        #print(data)\n        data = json.loads(data)\n    # Navigate through the JSON structure\n    # Assuming 'Call' is always present and has at least one element\n    calls = data.get(\"Call\", [])\n    if calls:\n        # Assuming 'Witnesses' is always present in the last element of 'Call' and has at least one element\n        last_call = calls[-1]\n        witnesses = last_call.get(\"Witnesses\", [])\n        if witnesses:\n            # Get the last 'Witnesses' entry\n            last_witness = witnesses[-1]\n            # Return the 'Value' list from the last 'Witnesses' entry\n            return last_witness.get(\"Value\", [])\n    return []\n\ndef extract_summary_rules(clingo_output):\n    # a summary rule is one prefixed by rule_contains(number)\n    summary_rules_by_prefix = defaultdict(list)\n    for line in clingo_output:\n        if line.startswith('rule_contains'):\n\n            number_str = line.split('(')[0].split('rule_contains')[1]\n            number = int(number_str) if number_str.isdigit() else 0\n\n            rule = line.split('(')[1].split(')')[0]\n            summary_rules_by_prefix[number].append(rule)\n    return summary_rules_by_prefix\n\ndef calculate_rule_percentage(clingo_output, positive_predictions):\n    summary_rules_by_prefix = defaultdict(list)\n    rule_percentages = {}\n    for line in clingo_output:\n        if line.startswith('rule_predict_pos'):\n            number_str = line.split('(')[0].split('rule_predict_pos')[1]\n            if number_str == '':\n                number_str = '0'\n            number = int(number_str)\n            warning_number = line.split('(')[1].split(')')[0]\n            summary_rules_by_prefix[number].append(warning_number)\n    for rule_number, matched_warnings in summary_rules_by_prefix.items():\n        rule_percentages[rule_number] = len(set(matched_warnings) & set(positive_predictions)) / len(set(matched_warnings))\n    return rule_percentages\n\ndef number_of_rules_over_percentage(percentages, percentage_threshold=0.8):\n    return sum(1 for p in percentages.values() if p >= percentage_threshold)\n\ndef get_number_of_positive_predictions(clingo_output):\n    positive_predictions = set()\n    for line in clingo_output:\n        if line.startswith('rule_predict_pos'):\n            warning_number = line.split('(')[1].split(')')[0]\n            positive_predictions.add(warning_number)\n    return len(positive_predictions)\n\n\ndef get_positive_predictions(clingo_output, rule_numbers):\n    # rule_predict_pos<number>(<warning>)\n    positive_predictions = []\n    for line in clingo_output:\n        if line.startswith('rule_predict_pos'):\n            number_str = line.split('(')[0].split('rule_predict_pos')[1]\n            number = int(number_str) if number_str.isdigit() else 0\n            if number not in rule_numbers:\n                continue\n            # extract warning from parenthesis\n            warning = line.split('(')[1].split(')')[0]\n            if warning not in ground_truth:\n                continue\n            positive_predictions.append(warning)\n    return positive_predictions\n\ndef get_positive_predictions_of_rule(clingo_output, rule_number):\n    # rule_predict_pos<number>(<warning>)\n    positive_predictions = []\n    for line in clingo_output:\n        matches_rule = line.startswith(f'rule_predict_pos{rule_number}') if rule_number != 0 else line.startswith('rule_predict_pos')\n        if matches_rule:\n            # extract warning from parenthesis\n            warning = line.split('(')[1].split(')')[0]\n            if warning not in ground_truth:\n                continue\n            positive_predictions.append(warning)\n    return positive_predictions\n\n# Simulation driver code\n\n# Parameters for the simulation\nwarning_type = sys.argv[1]\nground_truth_file = sys.argv[2]\n\n# Read ground_truth data\nground_truth = read_ground_truth(ground_truth_file)\n\ngraph_id_to_warning = {}\nwith open('meteor_app/private/original_graphs/' + warning_type + '_graph_id_mapping.txt', 'r') as file:\n    for line in file:\n        graph_id = line.split(',')[1]\n        example_id = line.split(',')[2].split(' - ')[0]\n        graph_id_to_warning[graph_id] = example_id\n\n# Load code data from JSON\nwith open('meteor_app/private/original_graphs/' + warning_type + '_elementpositions.json', 'r') as file:\n    code_content_data = json.load(file)\n\ncode_data = {}\n\nfor graph_id_str, another_json_str in code_content_data.items():\n    warning_data = json.loads(another_json_str)\n\n    # Code length\n    raw_code = warning_data.get(\"rawCode\", \"\")\n    raw_code_length = len(raw_code.splitlines())\n    try:\n        warning_id = int(graph_id_to_warning[graph_id_str])\n    except:\n        continue\n\n    code_data[warning_id] = {}\n\n    code_data[warning_id]['linesOfCode'] = raw_code_length\n\n    # Find all code expressions that look like function calls\n    function_calls = [expression for expression in warning_data['expressionStart'].keys() if '()' in expression and '->' not in expression]\n\n    code_data[warning_id]['functionCalls'] = function_calls\n\n# Scenarios: 1 = Heuristic 1, 2 = Heuristic 2, 3 = Heuristic 3, 4 = All Heuristics\nscenarios = {\n    'Heuristic 1 Only': [1]\n    #'Heuristic 2 Only': [2],\n    #'Heuristic 3 Only': [3],\n    #'All Heuristics': [4]\n}\n\n# Store the accuracy, rule percentage, and conciseness results for each scenario\naccuracy_results = {key: {'p=0': [], 'p=0.5': [], 'p=1': []} for key in scenarios.keys()}\nrule_percentage_results = {key: {'p=0': [], 'p=0.5': [], 'p=1': []} for key in scenarios.keys()}\nconciseness_results = {key: {'p=0': [], 'p=0.5': [], 'p=1': []} for key in scenarios.keys()}\n\n\n# Run simulations for each scenario\nfor scenario_name, heuristics in scenarios.items():\n    rule_percentage = 0\n    conciseness = 0\n    accuracy = 0\n    for p_value in [1, 0.5, 0]:\n        print(f\"Running scenario: {scenario_name} with p={p_value}\")\n\n        warnings_state = initialize_warnings_state(ground_truth)\n        num_warnings = len(ground_truth)\n\n\n        # get the first warning\n        selected_pos, selected_neg = sample_labels_randomized_then_sorted(ground_truth, 1, 1, code_data, initialize_warnings_state(ground_truth), apply_heuristics=heuristics)\n        for pos in selected_pos:\n            warnings_state[pos] = 'positive'\n        for neg in selected_neg:\n            warnings_state[neg] = 'negative'\n        \n        pos_labels = [k for k, v in warnings_state.items() if v == 'positive']\n        neg_labels = [k for k, v in warnings_state.items() if v == 'negative']\n\n        write_labels_to_clingo_input(pos_labels, neg_labels)\n        output = run_clingo()\n    \n        # Run simulation for # of warnings iterations\n        for iteration in range(num_warnings - 1):\n            if all([v != 'uninspected' for v in warnings_state.values()]):\n                # fill in the rest of the warnings with the last accuracy, rule percentage, and conciseness\n                for i in range(iteration, num_warnings):\n                    accuracy_results[scenario_name][f'p={p_value}'].append(accuracy)\n                    rule_percentage_results[scenario_name][f'p={p_value}'].append(rule_percentage)\n                    conciseness_results[scenario_name][f'p={p_value}'].append(conciseness)\n                break\n            \n            print(f'Simulation Iteration {iteration} for {scenario_name} with p={p_value}')\n\n            if p_value == 1:\n                # Use the rules to select positive/negative warnings\n                if output:\n                    model = parse_clingo_output(output)\n                    rule_numbers = list(extract_summary_rules(model).keys())\n                    if rule_numbers:\n                        selected_pos = get_positive_predictions_of_rule(model, random.choice(rule_numbers))\n                        selected_neg = []  # Handle negative case similarly if needed\n\n                        # 0.1 probability to mark all matching warnings as positive/negative\n                        if random.random() > 0.05:\n                            selected_pos, selected_neg = sample_labels_randomized_then_sorted(ground_truth, 1, 1, code_data, warnings_state, apply_heuristics=heuristics)\n                        for pos in selected_pos:\n                            warnings_state[pos] = 'positive'\n                        for neg in selected_neg:\n                            warnings_state[neg] = 'negative'\n            elif p_value == 0.5:\n                # 50% chance to use the rules or the original heuristic-based sampling\n                if random.random() < 0.5:\n                    if output:\n                        model = parse_clingo_output(output)\n                        rule_numbers = list(extract_summary_rules(model).keys())\n                        if rule_numbers:\n                            selected_pos = get_positive_predictions_of_rule(model, random.choice(rule_numbers))\n                            selected_neg = []  # Handle negative case similarly if needed\n\n                            # 0.1 probability to mark all matching warnings as positive/negative\n                            if random.random() > 0.05:\n                                selected_pos, selected_neg = sample_labels_randomized_then_sorted(ground_truth, 1, 1, code_data, warnings_state, apply_heuristics=heuristics)\n                            for pos in selected_pos:\n                                warnings_state[pos] = 'positive'\n                            for neg in selected_neg:\n                                warnings_state[neg] = 'negative'                                \n                else:\n                    selected_pos, selected_neg = sample_labels_randomized_then_sorted(ground_truth, 1, 1, code_data, warnings_state, apply_heuristics=heuristics)\n            elif p_value == 0:\n                # p=0, just use the original heuristic-based sampling\n                selected_pos, selected_neg = sample_labels_randomized_then_sorted(ground_truth, 1, 1, code_data, warnings_state, apply_heuristics=heuristics)\n\n            # Write labels to Clingo input and run Clingo\n            pos_labels = [k for k, v in warnings_state.items() if v == 'positive']\n            neg_labels = [k for k, v in warnings_state.items() if v == 'negative']\n\n            write_labels_to_clingo_input(pos_labels, neg_labels)\n            output = run_clingo()\n\n            if output:\n                model = parse_clingo_output(output)\n                inferred_rules = extract_summary_rules(model)\n                percentages = calculate_rule_percentage(model, pos_labels)\n                num_rules_over_threshold = number_of_rules_over_percentage(percentages)\n                num_rules = len(inferred_rules)\n                number_of_positive_predictions = get_number_of_positive_predictions(model)\n\n                if num_rules_over_threshold > 0:\n                    conciseness = number_of_positive_predictions / num_rules_over_threshold\n                else:\n                    conciseness = 0\n\n                # Calculate the percentage of rules over the threshold\n                if num_rules > 0:\n                    rule_percentage = (num_rules_over_threshold / num_rules) * 100\n                else:\n                    rule_percentage = 0\n\n                rule_percentage_results[scenario_name][f'p={p_value}'].append(rule_percentage)\n                conciseness_results[scenario_name][f'p={p_value}'].append(conciseness)\n\n            # Calculate accuracy after each iteration\n            accuracy = calculate_accuracy(warnings_state, ground_truth)\n            accuracy_results[scenario_name][f'p={p_value}'].append(accuracy)\n            print(f'Accuracy after iteration {iteration}: {accuracy:.2f}%')\n            print(f'Percentage of rules over threshold after iteration {iteration}: {rule_percentage:.2f}%')\n            print(f'Conciseness after iteration {iteration}: {conciseness:.2f}')\n\n# Save the results to a csv file\nwith open(warning_type + '_simulation_results.csv', 'w') as f:\n    f.write('Scenario,Probability,Iteration,Accuracy,Rule Percentage,Conciseness\\n')\n    for scenario_name, p_results in accuracy_results.items():\n        for p_value, accuracy_list in p_results.items():\n            rule_percentage_list = rule_percentage_results[scenario_name][p_value]\n            conciseness_list = conciseness_results[scenario_name][p_value]\n            for i in range(len(accuracy_list)):\n                if i < len(rule_percentage_list) and i < len(conciseness_list):\n                    f.write(f'{scenario_name},{p_value},{i},{accuracy_list[i]},{rule_percentage_list[i]},{conciseness_list[i]}\\n')\n                else:\n                    f.write(f'{scenario_name},{p_value},{i},{accuracy_list[i]},0,0\\n')"],time:'2024-09-08T07:39:17.133Z'},{src:'onDidChangeTextDocument',msg:'%s:%s to %s:%s in [%s] replaced with: %s`',prm:['0','0','443','86','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"# the idea is to try different combinations \n# IMPORTANT: prequisites for running this script : run `meteor` in the `meteor_app` directory \n# Run one of \n# e.g., WARNING_TYPE=apache_lucene-solr__NULL_ WARNING_JSON_NAME=spotbugs_warnings_apache_lucene-solr__NULL_ meteor  \n# e.g., WARNING_JSON_NAME=infer_warnings_alibaba_nacos_NULL_DEREFERENCE meteor \n# e.g,, WARNING_TYPE=RESOURCE_LEAK__presto WARNING_JSON_NAME=infer_warnings_prestodb_presto_RESOURCE_LEAK meteor \n# and generate the background.lp file \n\nimport random\nimport subprocess\nimport sys\nimport os\nfrom collections import defaultdict\nimport json\nimport time\nimport matplotlib.pyplot as plt\n\ndef read_ground_truth(ground_truth_file):\n    ground_truth = {}\n    with open(ground_truth_file) as f:\n        for line in f:\n            line = line.strip().split()\n            ground_truth[line[0]] = line[1]\n    return ground_truth\n\ndef write_labels_to_clingo_input(poss, negs):\n    with open('lp/simulation_labels.lp', 'w+') as f:\n        for p in poss:\n            f.write(f'pos({p}).\\n')\n        for n in negs:\n            f.write(f'neg({n}).\\n')\n\ndef read_containment(containment_file='lp/background.lp'):\n    containment = {}\n    last_checked_id = -1  # Initialize last_checked_id to keep track of the last ID we processed\n\n    with open(containment_file) as f:\n        for line in f:\n            line = line.strip().split()\n\n            # If line contains 'containment', extract the warning ID\n            if 'containment' in line[0]:\n                id = int(line[0].split('containment(')[1].split(',')[0])\n\n                # Only process the first occurrence of each ID\n                if id != last_checked_id:\n                    loc = line[1].split(\")\")[0]\n                    loc = loc.replace('__', '.').replace('_', '.')\n                    last_checked_id = id  # Update last_checked_id to prevent re-checking this ID\n                    containment[id] = loc  # Store the location for this ID\n    return containment\n\ndef heuristic_shorter_code_first(warnings):\n    \"\"\"Sort the warnings by lines of code (ascending).\"\"\"\n    return sorted(warnings, key=lambda x: x[1])\n\ndef heuristic_shared_function_calls(warnings):\n    \"\"\"Sort the warnings by the number of shared function calls (descending).\"\"\"\n    def shared_function_calls(warning, other_warnings):\n        return sum(len(set(warning[2]).intersection(set(other[2]))) for other in other_warnings)\n    #print(sorted(warnings, key=lambda x: shared_function_calls(x, warnings), reverse=True))\n    return sorted(warnings, key=lambda x: shared_function_calls(x, warnings), reverse=True)\n\ndef heuristic_neighbor_classes(warnings, containment):\n    \"\"\"Sort the warnings by neighbor classes (contained in the same package or directory).\"\"\"\n    sorted_warnings = []\n    processed_locs = set()\n    \n    for i in range(len(warnings)):\n        loc = containment.get(int(warnings[i][0]))\n        if loc not in processed_locs:\n            # Find all warnings with the same location\n            same_loc_warnings = [warnings[j] for j in range(i, len(warnings)) if containment.get(int(warnings[j][0])) == loc]\n            sorted_warnings.extend(same_loc_warnings)\n            processed_locs.add(loc)\n    \n    return sorted_warnings\n\ndef initialize_warnings_state(ground_truth):\n    \"\"\"Initialize all warnings with the state 'uninspected'.\"\"\"\n    return {k: 'uninspected' for k in ground_truth.keys()}\n\ndef calculate_accuracy(warnings_state, ground_truth):\n    \"\"\"Calculate the accuracy by comparing the current state of warnings with the ground truth.\"\"\"\n    correct_labels = sum(1 for k, v in warnings_state.items() if v == ground_truth[k])\n    return correct_labels / len(ground_truth) * 100\n\ndef sample_pos_with_heuristic(selected_warnings, code_data, warnings_state, apply_heuristics=None):\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            selected_warnings = heuristic_shorter_code_first(selected_warnings)\n        elif heuristic == 2:\n            selected_warnings = heuristic_shared_function_calls(selected_warnings)\n        elif heuristic == 3:\n            selected_warnings = heuristic_neighbor_classes(selected_warnings)\n        elif heuristic == 4:\n            # choose a random heuristic\n            selected_warnings = random.choice([heuristic_shorter_code_first(selected_warnings), heuristic_shared_function_calls(selected_warnings), heuristic_neighbor_classes(selected_warnings)])\n    \n    # sort by code length to identify shortest and longest warnings. selected_warnings do not contain the code length find it from warnings\n    for warning in selected_warnings:\n        warning_id = warning[0]\n        warning[1] = code_data.get(int(warning_id), {}).get('linesOfCode', 0)\n    \n    sorted_warnings_by_length = sorted(selected_warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(selected_warnings)):\n        if selected_warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'positive'\n            selected_warnings[i] = tuple(selected_warnings[i])\n        else:\n            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'negative'\n            selected_warnings[i] = tuple(selected_warnings[i])\n\n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n\n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [selected_warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [selected_warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n\n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n\n    return selected_positive_warnings, selected_negative_warnings\n\n\ndef sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings\n\n\ndef run_clingo():\n    files = [\n        f'lp/simulation_labels.lp',  \n        'lp/background.lp',              \n        'lp/frozen_rules.lp',            \n        'lp/rules2.lp'                   \n    ]\n    \n    command = ['clingo'] + files + ['--outf=2'] + ['--time-limit=30'] \n    print(' '.join(command))\n    result = subprocess.run(command, capture_output=True, text=True)\n\n    return result.stdout\n\ndef parse_clingo_output(data):\n    # Load the data using json.loads if 'data' is a string,\n    # otherwise assume it's already a dictionary\n    if isinstance(data, str):\n        #print(data)\n        data = json.loads(data.replace(\"'\", '\"'))\n    # Navigate through the JSON structure\n    # Assuming 'Call' is always present and has at least one element\n    calls = data.get(\"Call\", [])\n    if calls:\n        # Assuming 'Witnesses' is always present in the last element of 'Call' and has at least one element\n        last_call = calls[-1]\n        witnesses = last_call.get(\"Witnesses\", [])\n        if witnesses:\n            # Get the last 'Witnesses' entry\n            last_witness = witnesses[-1]\n            # Return the 'Value' list from the last 'Witnesses' entry\n            return last_witness.get(\"Value\", [])\n    return []\n\ndef extract_summary_rules(clingo_output):\n    # a summary rule is one prefixed by rule_contains(number)\n    summary_rules_by_prefix = defaultdict(list)\n    for line in clingo_output:\n        if line.startswith('rule_contains'):\n\n            number_str = line.split('(')[0].split('rule_contains')[1]\n            number = int(number_str) if number_str.isdigit() else 0\n\n            rule = line.split('(')[1].split(')')[0]\n            summary_rules_by_prefix[number].append(rule)\n    return summary_rules_by_prefix\n\ndef calculate_rule_percentage(clingo_output, positive_predictions):\n    summary_rules_by_prefix = defaultdict(list)\n    rule_percentages = {}\n    for line in clingo_output:\n        if line.startswith('rule_predict_pos'):\n            number_str = line.split('(')[0].split('rule_predict_pos')[1]\n            if number_str == '':\n                number_str = '0'\n            number = int(number_str)\n            warning_number = line.split('(')[1].split(')')[0]\n            summary_rules_by_prefix[number].append(warning_number)\n    for rule_number, matched_warnings in summary_rules_by_prefix.items():\n        rule_percentages[rule_number] = len(set(matched_warnings) & set(positive_predictions)) / len(set(matched_warnings))\n    return rule_percentages\n\ndef number_of_rules_over_percentage(percentages, percentage_threshold=0.8):\n    return sum(1 for p in percentages.values() if p >= percentage_threshold)\n\ndef get_number_of_positive_predictions(clingo_output):\n    positive_predictions = set()\n    for line in clingo_output:\n        if line.startswith('rule_predict_pos'):\n            warning_number = line.split('(')[1].split(')')[0]\n            positive_predictions.add(warning_number)\n    return len(positive_predictions)\n\n\ndef get_positive_predictions(clingo_output, rule_numbers):\n    # rule_predict_pos<number>(<warning>)\n    positive_predictions = []\n    for line in clingo_output:\n        if line.startswith('rule_predict_pos'):\n            number_str = line.split('(')[0].split('rule_predict_pos')[1]\n            number = int(number_str) if number_str.isdigit() else 0\n            if number not in rule_numbers:\n                continue\n            # extract warning from parenthesis\n            warning = line.split('(')[1].split(')')[0]\n            if warning not in ground_truth:\n                continue\n            positive_predictions.append(warning)\n    return positive_predictions\n\ndef get_positive_predictions_of_rule(clingo_output, rule_number):\n    # rule_predict_pos<number>(<warning>)\n    positive_predictions = []\n    for line in clingo_output:\n        matches_rule = line.startswith(f'rule_predict_pos{rule_number}') if rule_number != 0 else line.startswith('rule_predict_pos')\n        if matches_rule:\n            # extract warning from parenthesis\n            warning = line.split('(')[1].split(')')[0]\n            if warning not in ground_truth:\n                continue\n            positive_predictions.append(warning)\n    return positive_predictions    \n\n# Simulation driver code\n\n# Parameters for the simulation\nwarning_type = sys.argv[1]\nground_truth_file = sys.argv[2]\n\n# Read ground_truth data\nground_truth = read_ground_truth(ground_truth_file)\n\ngraph_id_to_warning = {}\nwith open('meteor_app/private/original_graphs/' + warning_type + '_graph_id_mapping.txt', 'r') as file:\n    for line in file:\n        graph_id = line.split(',')[1]\n        example_id = line.split(',')[2].split(' - ')[0]\n        graph_id_to_warning[graph_id] = example_id\n\n# Load code data from JSON\nwith open('meteor_app/private/original_graphs/' + warning_type + '_elementpositions.json', 'r') as file:\n    code_content_data = json.load(file)\n\ncode_data = {}\n\nfor graph_id_str, another_json_str in code_content_data.items():\n    warning_data = json.loads(another_json_str)\n\n    # Code length\n    raw_code = warning_data.get(\"rawCode\", \"\")\n    raw_code_length = len(raw_code.splitlines())\n    try:\n        warning_id = int(graph_id_to_warning[graph_id_str])\n    except:\n        continue\n\n    code_data[warning_id] = {}\n\n    code_data[warning_id]['linesOfCode'] = raw_code_length\n\n    # Find all code expressions that look like function calls\n    function_calls = [expression for expression in warning_data['expressionStart'].keys() if '()' in expression and '->' not in expression]\n\n    code_data[warning_id]['functionCalls'] = function_calls\n\n# Scenarios: 1 = Heuristic 1, 2 = Heuristic 2, 3 = Heuristic 3, 4 = All Heuristics\nscenarios = {\n    #'Heuristic 1 Only': [1]\n    'Heuristic 2 Only': [2]\n    #'Heuristic 3 Only': [3],\n    #'All Heuristics': [4]\n}\n\n# Store the accuracy, rule percentage, and conciseness results for each scenario\naccuracy_results = {key: {'p=0': [], 'p=0.5': [], 'p=1': []} for key in scenarios.keys()}\nrule_percentage_results = {key: {'p=0': [], 'p=0.5': [], 'p=1': []} for key in scenarios.keys()}\nconciseness_results = {key: {'p=0': [], 'p=0.5': [], 'p=1': []} for key in scenarios.keys()}\n\n\n# Run simulations for each scenario\nfor scenario_name, heuristics in scenarios.items():\n    rule_percentage = 0\n    conciseness = 0\n    accuracy = 0\n    for p_value in [1, 0.5, 0]:\n        print(f\"Running scenario: {scenario_name} with p={p_value}\")\n\n        warnings_state = initialize_warnings_state(ground_truth)\n        num_warnings = len(ground_truth)\n\n\n        # get the first warning\n        selected_pos, selected_neg = sample_labels_randomized_then_sorted(ground_truth, 1, 1, code_data, initialize_warnings_state(ground_truth), apply_heuristics=heuristics)\n        for pos in selected_pos:\n            warnings_state[pos] = 'positive'\n        for neg in selected_neg:\n            warnings_state[neg] = 'negative'\n        \n        pos_labels = [k for k, v in warnings_state.items() if v == 'positive']\n        neg_labels = [k for k, v in warnings_state.items() if v == 'negative']\n\n        write_labels_to_clingo_input(pos_labels, neg_labels)\n        output = run_clingo()\n    \n        # Run simulation for # of warnings iterations\n        for iteration in range(num_warnings - 1):\n            if all([v != 'uninspected' for v in warnings_state.values()]):\n                # fill in the rest of the warnings with the last accuracy, rule percentage, and conciseness\n                for i in range(iteration, num_warnings):\n                    accuracy_results[scenario_name][f'p={p_value}'].append(accuracy)\n                    rule_percentage_results[scenario_name][f'p={p_value}'].append(rule_percentage)\n                    conciseness_results[scenario_name][f'p={p_value}'].append(conciseness)\n                break\n            \n            print(f'Simulation Iteration {iteration} for {scenario_name} with p={p_value}')\n\n            if p_value == 1:\n                # Use the rules to select positive/negative warnings\n                if output:\n                    model = parse_clingo_output(output)\n                    rule_numbers = list(extract_summary_rules(model).keys())\n                    if rule_numbers:\n                        selected_all_pos = get_positive_predictions_of_rule(model, random.choice(rule_numbers))\n                        selected_pos, selected_neg = sample_pos_with_heuristic(selected_all_pos, code_data, warnings_state, apply_heuristics=heuristics)\n\n                        # 0.1 probability to mark all matching warnings as positive/negative\n                        if random.random() <= 0.05 and iteration > num_warnings // 2:\n                            for pos in selected_all_pos:\n                                warnings_state[pos] = 'positive'\n\n            elif p_value == 0.5:\n                # 50% chance to use the rules or the original heuristic-based sampling\n                if random.random() < 0.5:\n                    if output:\n                        model = parse_clingo_output(output)\n                        rule_numbers = list(extract_summary_rules(model).keys())\n                        if rule_numbers:\n                            selected_all_pos = get_positive_predictions_of_rule(model, random.choice(rule_numbers))\n                            selected_pos, selected_neg = sample_pos_with_heuristic(selected_all_pos, code_data, warnings_state, apply_heuristics=heuristics)\n\n                            # 0.1 probability to mark all matching warnings as positive/negative\n                            if random.random() <= 0.05 and iteration > num_warnings // 2:\n                                for pos in selected_all_pos:\n                                    warnings_state[pos] = 'positive'\n                else:\n                    selected_pos, selected_neg = sample_labels_randomized_then_sorted(ground_truth, 1, 1, code_data, warnings_state, apply_heuristics=heuristics)\n            elif p_value == 0:\n                # p=0, just use the original heuristic-based sampling\n                selected_pos, selected_neg = sample_labels_randomized_then_sorted(ground_truth, 1, 1, code_data, warnings_state, apply_heuristics=heuristics)\n\n            # Write labels to Clingo input and run Clingo\n            pos_labels = [k for k, v in warnings_state.items() if v == 'positive']\n            neg_labels = [k for k, v in warnings_state.items() if v == 'negative']\n\n            write_labels_to_clingo_input(pos_labels, neg_labels)\n            output = run_clingo()\n\n            if output:\n                model = parse_clingo_output(output)\n                inferred_rules = extract_summary_rules(model)\n                percentages = calculate_rule_percentage(model, pos_labels)\n                num_rules_over_threshold = number_of_rules_over_percentage(percentages)\n                num_rules = len(inferred_rules)\n                number_of_positive_predictions = get_number_of_positive_predictions(model)\n\n                if num_rules_over_threshold > 0:\n                    conciseness = number_of_positive_predictions / num_rules_over_threshold\n                else:\n                    conciseness = 0\n\n                # Calculate the percentage of rules over the threshold\n                if num_rules > 0:\n                    rule_percentage = (num_rules_over_threshold / num_rules) * 100\n                else:\n                    rule_percentage = 0\n\n                rule_percentage_results[scenario_name][f'p={p_value}'].append(rule_percentage)\n                conciseness_results[scenario_name][f'p={p_value}'].append(conciseness)\n\n            # Calculate accuracy after each iteration\n            accuracy = calculate_accuracy(warnings_state, ground_truth)\n            accuracy_results[scenario_name][f'p={p_value}'].append(accuracy)\n            print(f'Accuracy after iteration {iteration}: {accuracy:.2f}%')\n            print(f'Percentage of rules over threshold after iteration {iteration}: {rule_percentage:.2f}%')\n            print(f'Conciseness after iteration {iteration}: {conciseness:.2f}')\n\n# Save the results to a csv file\nif scenario_name == 'Heuristic 1 Only':\n    scenario_name = 'h=1'\nelif scenario_name == 'Heuristic 2 Only':\n    scenario_name = 'h=2'\nelif scenario_name == 'Heuristic 3 Only':\n    scenario_name = 'h=3'\nelif scenario_name == 'All Heuristics':\n    scenario_name = 'h=4'\n\nif warning_type == 'apache_lucene-solr__NULL_':\n    warning_type = 'apache_lucene_' + scenario_name\nelif warning_type == 'NULL_DEREFERENCE__nacos':\n    warning_type = 'alibaba_nacos_' + scenario_name\nelif warning_type == 'RESOURCE_LEAK__presto':\n    warning_type = 'presto_' + scenario_name\nelif warning_type == 'dubbo_external':\n    warning_type = 'apache_dubbo_' + scenario_name\n\nwith open(warning_type + '.csv', 'w') as f:\n    f.write('Scenario,Probability,Iteration,Accuracy,Rule Percentage,Conciseness\\n')\n    for scenario_name, p_results in accuracy_results.items():\n        for p_value, accuracy_list in p_results.items():\n            rule_percentage_list = rule_percentage_results[scenario_name][p_value]\n            conciseness_list = conciseness_results[scenario_name][p_value]\n            for i in range(len(accuracy_list)):\n                if i < len(rule_percentage_list) and i < len(conciseness_list):\n                    f.write(f'{scenario_name},{p_value},{i},{accuracy_list[i]},{rule_percentage_list[i]},{conciseness_list[i]}\\n')\n                else:\n                    f.write(f'{scenario_name},{p_value},{i},{accuracy_list[i]},0,0\\n')"],time:'2024-09-08T07:39:17.468Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['356','0','384','31','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:17.526Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['508','86','508','86','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',''],time:'2024-09-08T07:39:17.529Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['481','0','508','86','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:17.529Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['482','0','508','86','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:18.586Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['483','0','508','86','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:18.608Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['484','0','508','86','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:18.608Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['485','0','508','86','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:18.645Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['486','0','508','86','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:18.728Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['487','0','508','86','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:18.895Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['488','0','508','86','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:18.995Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['487','0','508','86','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:19.195Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['486','0','508','86','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:19.345Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['485','0','508','86','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:19.445Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['484','0','508','86','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:19.528Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['483','0','508','86','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:19.595Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['481','0','508','86','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:20.378Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['478','0','506','130','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:20.411Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['474','0','502','82','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:20.429Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['468','0','496','50','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:20.444Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['465','0','493','45','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:20.461Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['462','0','490','51','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:20.483Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['457','0','485','25','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:20.495Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['452','0','480','39','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:20.511Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['446','0','474','76','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:20.528Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['434','0','462','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:20.545Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['429','0','457','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:20.562Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['423','0','451','51','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:20.579Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['418','0','446','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:20.595Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['413','0','441','157','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:20.612Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['408','0','436','68','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:20.628Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['404','0','432','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:20.644Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['403','0','431','156','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:20.724Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['402','0','430','115','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:20.778Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['401','0','429','40','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:20.828Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['400','0','428','80','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:20.845Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['399','0','427','59','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:20.862Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['398','0','426','30','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:20.878Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['396','0','424','86','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:20.895Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['392','0','420','56','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:20.912Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['388','0','416','152','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:20.928Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['384','0','412','55','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:20.945Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['379','0','407','91','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:20.962Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['366','0','394','60','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:20.978Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['360','0','388','32','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:20.995Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['354','0','382','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:21.012Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['348','0','376','16','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:21.028Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['342','0','370','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:21.045Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['337','0','365','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:21.062Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['332','0','360','28','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:21.079Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['327','0','355','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:21.095Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['322','0','350','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:21.112Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['318','0','346','11','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:21.129Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['314','0','342','46','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:21.145Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['310','0','338','64','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:21.162Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['308','0','336','14','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:21.227Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['305','0','333','104','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:21.245Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['297','0','325','24','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:21.262Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['291','0','319','26','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:21.278Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['282','0','310','54','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:21.295Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['272','0','300','48','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:21.312Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['262','0','290','30','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:21.328Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['253','0','281','47','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:21.345Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['244','0','272','123','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:21.362Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['235','0','263','30','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:21.377Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['227','0','255','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:21.395Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['220','0','248','61','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:21.412Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['212','0','240','21','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:21.429Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['205','0','233','41','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:21.445Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['199','0','227','30','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:21.462Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['193','0','221','70','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:21.478Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['187','0','215','37','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:21.495Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['181','0','209','4','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:21.512Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['176','0','204','66','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:21.528Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['171','0','199','53','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:21.545Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['166','0','194','31','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:21.562Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['162','0','190','4','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:21.578Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['158','0','186','13','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:21.595Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['157','0','185','44','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:21.662Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['156','0','184','39','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:21.678Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['154','0','182','88','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:21.695Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['151','0','179','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:21.711Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['148','0','176','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:21.728Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['144','0','172','72','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:21.745Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['141','0','169','28','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:21.761Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['136','0','164','45','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:21.778Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['130','0','158','28','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:21.795Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['125','0','153','127','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:21.811Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['119','0','147','7','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:21.828Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['113','0','141','63','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:21.845Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['108','0','136','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:21.862Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['102','0','130','66','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:21.878Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['97','0','125','53','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:21.895Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['92','0','120','31','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:21.912Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['88','0','116','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:21.928Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['84','0','112','13','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:21.945Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['80','0','108','97','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:21.962Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['76','0','104','77','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:21.978Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['75','0','103','4','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:22.095Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['74','0','102','77','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:22.145Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['73','0','101','31','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:22.178Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['72','0','100','37','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:22.212Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['71','0','99','139','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:22.262Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['70','0','98','4','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:22.345Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['69','0','97','195','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:22.428Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['68','0','96','39','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:22.495Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['67','0','95','28','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:23.762Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['66','0','94','77','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:23.845Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['67','0','95','28','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:23.962Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['68','0','96','39','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:23.978Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['69','0','97','195','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:23.995Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['70','0','98','4','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:24.012Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['71','0','99','139','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:24.028Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['72','0','100','37','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:24.045Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['73','0','101','31','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:24.062Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['75','0','103','4','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:24.078Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['76','0','104','77','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:24.095Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['77','0','105','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:24.112Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['79','0','107','43','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:24.128Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['80','0','108','97','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:24.145Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['81','0','109','61','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:24.162Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['83','0','111','62','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:24.194Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['84','0','112','13','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:24.212Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['85','0','113','61','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:24.228Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['86','0','114','48','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:24.245Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['87','0','115','62','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:24.295Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['88','0','116','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:24.328Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['89','0','117','72','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:24.362Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['90','0','118','55','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:24.395Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['89','0','117','72','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:24.528Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['88','0','116','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:24.578Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['87','0','115','62','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:24.612Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['86','0','114','48','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:24.628Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['85','0','113','61','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:24.678Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['84','0','112','13','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:24.779Z'},{src:'onDidChangeTextDocument',msg:'%s:%s to %s:%s in [%s] replaced with: %s`',prm:['0','0','508','86','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"# the idea is to try different combinations \n# IMPORTANT: prequisites for running this script : run `meteor` in the `meteor_app` directory \n# Run one of \n# e.g., WARNING_TYPE=apache_lucene-solr__NULL_ WARNING_JSON_NAME=spotbugs_warnings_apache_lucene-solr__NULL_ meteor  \n# e.g., WARNING_JSON_NAME=infer_warnings_alibaba_nacos_NULL_DEREFERENCE meteor \n# e.g,, WARNING_TYPE=RESOURCE_LEAK__presto WARNING_JSON_NAME=infer_warnings_prestodb_presto_RESOURCE_LEAK meteor \n# and generate the background.lp file \n\nimport random\nimport subprocess\nimport sys\nimport os\nfrom collections import defaultdict\nimport json\nimport time\nimport matplotlib.pyplot as plt\n\ndef read_ground_truth(ground_truth_file):\n    ground_truth = {}\n    with open(ground_truth_file) as f:\n        for line in f:\n            line = line.strip().split()\n            ground_truth[line[0]] = line[1]\n    return ground_truth\n\ndef write_labels_to_clingo_input(poss, negs):\n    with open('lp/simulation_labels.lp', 'w+') as f:\n        for p in poss:\n            f.write(f'pos({p}).\\n')\n        for n in negs:\n            f.write(f'neg({n}).\\n')\n\ndef read_containment(containment_file='lp/background.lp'):\n    containment = {}\n    last_checked_id = -1  # Initialize last_checked_id to keep track of the last ID we processed\n\n    with open(containment_file) as f:\n        for line in f:\n            line = line.strip().split()\n\n            # If line contains 'containment', extract the warning ID\n            if 'containment' in line[0]:\n                id = int(line[0].split('containment(')[1].split(',')[0])\n\n                # Only process the first occurrence of each ID\n                if id != last_checked_id:\n                    loc = line[1].split(\")\")[0]\n                    loc = loc.replace('__', '.').replace('_', '.')\n                    last_checked_id = id  # Update last_checked_id to prevent re-checking this ID\n                    containment[id] = loc  # Store the location for this ID\n    return containment\n\ndef heuristic_shorter_code_first(warnings):\n    \"\"\"Sort the warnings by lines of code (ascending).\"\"\"\n    return sorted(warnings, key=lambda x: x[1])\n\ndef heuristic_shared_function_calls(warnings):\n    \"\"\"Sort the warnings by the number of shared function calls (descending).\"\"\"\n    def shared_function_calls(warning, other_warnings):\n        return sum(len(set(warning[2]).intersection(set(other[2]))) for other in other_warnings)\n    #print(sorted(warnings, key=lambda x: shared_function_calls(x, warnings), reverse=True))\n    return sorted(warnings, key=lambda x: shared_function_calls(x, warnings), reverse=True)\n\ndef heuristic_neighbor_classes(warnings, containment):\n    \"\"\"Sort the warnings by neighbor classes (contained in the same package or directory).\"\"\"\n    sorted_warnings = []\n    processed_locs = set()\n    \n    for i in range(len(warnings)):\n        loc = containment.get(int(warnings[i][0]))\n        if loc not in processed_locs:\n            # Find all warnings with the same location\n            same_loc_warnings = [warnings[j] for j in range(i, len(warnings)) if containment.get(int(warnings[j][0])) == loc]\n            sorted_warnings.extend(same_loc_warnings)\n            processed_locs.add(loc)\n    \n    return sorted_warnings\n\ndef initialize_warnings_state(ground_truth):\n    \"\"\"Initialize all warnings with the state 'uninspected'.\"\"\"\n    return {k: 'uninspected' for k in ground_truth.keys()}\n\ndef calculate_accuracy(warnings_state, ground_truth):\n    \"\"\"Calculate the accuracy by comparing the current state of warnings with the ground truth.\"\"\"\n    correct_labels = sum(1 for k, v in warnings_state.items() if v == ground_truth[k])\n    return correct_labels / len(ground_truth) * 100\n\ndef sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings\n\n\ndef run_clingo():\n    files = [\n        f'lp/simulation_labels.lp',  \n        'lp/background.lp',              \n        'lp/frozen_rules.lp',            \n        'lp/rules2.lp'                   \n    ]\n    \n    command = ['clingo'] + files + ['--outf=2'] + ['--time-limit=30'] \n    print(' '.join(command))\n    result = subprocess.run(command, capture_output=True, text=True)\n\n    return result.stdout\n\ndef parse_clingo_output(data):\n    # Load the data using json.loads if 'data' is a string,\n    # otherwise assume it's already a dictionary\n    if isinstance(data, str):\n        #print(data)\n        data = json.loads(data)\n    # Navigate through the JSON structure\n    # Assuming 'Call' is always present and has at least one element\n    calls = data.get(\"Call\", [])\n    if calls:\n        # Assuming 'Witnesses' is always present in the last element of 'Call' and has at least one element\n        last_call = calls[-1]\n        witnesses = last_call.get(\"Witnesses\", [])\n        if witnesses:\n            # Get the last 'Witnesses' entry\n            last_witness = witnesses[-1]\n            # Return the 'Value' list from the last 'Witnesses' entry\n            return last_witness.get(\"Value\", [])\n    return []\n\ndef extract_summary_rules(clingo_output):\n    # a summary rule is one prefixed by rule_contains(number)\n    summary_rules_by_prefix = defaultdict(list)\n    for line in clingo_output:\n        if line.startswith('rule_contains'):\n\n            number_str = line.split('(')[0].split('rule_contains')[1]\n            number = int(number_str) if number_str.isdigit() else 0\n\n            rule = line.split('(')[1].split(')')[0]\n            summary_rules_by_prefix[number].append(rule)\n    return summary_rules_by_prefix\n\ndef calculate_rule_percentage(clingo_output, positive_predictions):\n    summary_rules_by_prefix = defaultdict(list)\n    rule_percentages = {}\n    for line in clingo_output:\n        if line.startswith('rule_predict_pos'):\n            number_str = line.split('(')[0].split('rule_predict_pos')[1]\n            if number_str == '':\n                number_str = '0'\n            number = int(number_str)\n            warning_number = line.split('(')[1].split(')')[0]\n            summary_rules_by_prefix[number].append(warning_number)\n    for rule_number, matched_warnings in summary_rules_by_prefix.items():\n        rule_percentages[rule_number] = len(set(matched_warnings) & set(positive_predictions)) / len(set(matched_warnings))\n    return rule_percentages\n\ndef number_of_rules_over_percentage(percentages, percentage_threshold=0.8):\n    return sum(1 for p in percentages.values() if p >= percentage_threshold)\n\ndef get_number_of_positive_predictions(clingo_output):\n    positive_predictions = set()\n    for line in clingo_output:\n        if line.startswith('rule_predict_pos'):\n            warning_number = line.split('(')[1].split(')')[0]\n            positive_predictions.add(warning_number)\n    return len(positive_predictions)\n\n\ndef get_positive_predictions(clingo_output, rule_numbers):\n    # rule_predict_pos<number>(<warning>)\n    positive_predictions = []\n    for line in clingo_output:\n        if line.startswith('rule_predict_pos'):\n            number_str = line.split('(')[0].split('rule_predict_pos')[1]\n            number = int(number_str) if number_str.isdigit() else 0\n            if number not in rule_numbers:\n                continue\n            # extract warning from parenthesis\n            warning = line.split('(')[1].split(')')[0]\n            if warning not in ground_truth:\n                continue\n            positive_predictions.append(warning)\n    return positive_predictions\n\ndef get_positive_predictions_of_rule(clingo_output, rule_number):\n    # rule_predict_pos<number>(<warning>)\n    positive_predictions = []\n    for line in clingo_output:\n        matches_rule = line.startswith(f'rule_predict_pos{rule_number}') if rule_number != 0 else line.startswith('rule_predict_pos')\n        if matches_rule:\n            # extract warning from parenthesis\n            warning = line.split('(')[1].split(')')[0]\n            if warning not in ground_truth:\n                continue\n            positive_predictions.append(warning)\n    return positive_predictions\n\n# Simulation driver code\n\n# Parameters for the simulation\nwarning_type = sys.argv[1]\nground_truth_file = sys.argv[2]\n\n# Read ground_truth data\nground_truth = read_ground_truth(ground_truth_file)\n\ngraph_id_to_warning = {}\nwith open('meteor_app/private/original_graphs/' + warning_type + '_graph_id_mapping.txt', 'r') as file:\n    for line in file:\n        graph_id = line.split(',')[1]\n        example_id = line.split(',')[2].split(' - ')[0]\n        graph_id_to_warning[graph_id] = example_id\n\n# Load code data from JSON\nwith open('meteor_app/private/original_graphs/' + warning_type + '_elementpositions.json', 'r') as file:\n    code_content_data = json.load(file)\n\ncode_data = {}\n\nfor graph_id_str, another_json_str in code_content_data.items():\n    warning_data = json.loads(another_json_str)\n\n    # Code length\n    raw_code = warning_data.get(\"rawCode\", \"\")\n    raw_code_length = len(raw_code.splitlines())\n    try:\n        warning_id = int(graph_id_to_warning[graph_id_str])\n    except:\n        continue\n\n    code_data[warning_id] = {}\n\n    code_data[warning_id]['linesOfCode'] = raw_code_length\n\n    # Find all code expressions that look like function calls\n    function_calls = [expression for expression in warning_data['expressionStart'].keys() if '()' in expression and '->' not in expression]\n\n    code_data[warning_id]['functionCalls'] = function_calls\n\n# Scenarios: 1 = Heuristic 1, 2 = Heuristic 2, 3 = Heuristic 3, 4 = All Heuristics\nscenarios = {\n    'Heuristic 1 Only': [1]\n    #'Heuristic 2 Only': [2],\n    #'Heuristic 3 Only': [3],\n    #'All Heuristics': [4]\n}\n\n# Store the accuracy, rule percentage, and conciseness results for each scenario\naccuracy_results = {key: {'p=0': [], 'p=0.5': [], 'p=1': []} for key in scenarios.keys()}\nrule_percentage_results = {key: {'p=0': [], 'p=0.5': [], 'p=1': []} for key in scenarios.keys()}\nconciseness_results = {key: {'p=0': [], 'p=0.5': [], 'p=1': []} for key in scenarios.keys()}\n\n\n# Run simulations for each scenario\nfor scenario_name, heuristics in scenarios.items():\n    rule_percentage = 0\n    conciseness = 0\n    accuracy = 0\n    for p_value in [1, 0.5, 0]:\n        print(f\"Running scenario: {scenario_name} with p={p_value}\")\n\n        warnings_state = initialize_warnings_state(ground_truth)\n        num_warnings = len(ground_truth)\n\n\n        # get the first warning\n        selected_pos, selected_neg = sample_labels_randomized_then_sorted(ground_truth, 1, 1, code_data, initialize_warnings_state(ground_truth), apply_heuristics=heuristics)\n        for pos in selected_pos:\n            warnings_state[pos] = 'positive'\n        for neg in selected_neg:\n            warnings_state[neg] = 'negative'\n        \n        pos_labels = [k for k, v in warnings_state.items() if v == 'positive']\n        neg_labels = [k for k, v in warnings_state.items() if v == 'negative']\n\n        write_labels_to_clingo_input(pos_labels, neg_labels)\n        output = run_clingo()\n    \n        # Run simulation for # of warnings iterations\n        for iteration in range(num_warnings - 1):\n            if all([v != 'uninspected' for v in warnings_state.values()]):\n                # fill in the rest of the warnings with the last accuracy, rule percentage, and conciseness\n                for i in range(iteration, num_warnings):\n                    accuracy_results[scenario_name][f'p={p_value}'].append(accuracy)\n                    rule_percentage_results[scenario_name][f'p={p_value}'].append(rule_percentage)\n                    conciseness_results[scenario_name][f'p={p_value}'].append(conciseness)\n                break\n            \n            print(f'Simulation Iteration {iteration} for {scenario_name} with p={p_value}')\n\n            if p_value == 1:\n                # Use the rules to select positive/negative warnings\n                if output:\n                    model = parse_clingo_output(output)\n                    rule_numbers = list(extract_summary_rules(model).keys())\n                    if rule_numbers:\n                        selected_pos = get_positive_predictions_of_rule(model, random.choice(rule_numbers))\n                        selected_neg = []  # Handle negative case similarly if needed\n\n                        # 0.1 probability to mark all matching warnings as positive/negative\n                        if random.random() > 0.05:\n                            selected_pos, selected_neg = sample_labels_randomized_then_sorted(ground_truth, 1, 1, code_data, warnings_state, apply_heuristics=heuristics)\n                        for pos in selected_pos:\n                            warnings_state[pos] = 'positive'\n                        for neg in selected_neg:\n                            warnings_state[neg] = 'negative'\n            elif p_value == 0.5:\n                # 50% chance to use the rules or the original heuristic-based sampling\n                if random.random() < 0.5:\n                    if output:\n                        model = parse_clingo_output(output)\n                        rule_numbers = list(extract_summary_rules(model).keys())\n                        if rule_numbers:\n                            selected_pos = get_positive_predictions_of_rule(model, random.choice(rule_numbers))\n                            selected_neg = []  # Handle negative case similarly if needed\n\n                            # 0.1 probability to mark all matching warnings as positive/negative\n                            if random.random() > 0.05:\n                                selected_pos, selected_neg = sample_labels_randomized_then_sorted(ground_truth, 1, 1, code_data, warnings_state, apply_heuristics=heuristics)\n                            for pos in selected_pos:\n                                warnings_state[pos] = 'positive'\n                            for neg in selected_neg:\n                                warnings_state[neg] = 'negative'                                \n                else:\n                    selected_pos, selected_neg = sample_labels_randomized_then_sorted(ground_truth, 1, 1, code_data, warnings_state, apply_heuristics=heuristics)\n            elif p_value == 0:\n                # p=0, just use the original heuristic-based sampling\n                selected_pos, selected_neg = sample_labels_randomized_then_sorted(ground_truth, 1, 1, code_data, warnings_state, apply_heuristics=heuristics)\n\n            # Write labels to Clingo input and run Clingo\n            pos_labels = [k for k, v in warnings_state.items() if v == 'positive']\n            neg_labels = [k for k, v in warnings_state.items() if v == 'negative']\n\n            write_labels_to_clingo_input(pos_labels, neg_labels)\n            output = run_clingo()\n\n            if output:\n                model = parse_clingo_output(output)\n                inferred_rules = extract_summary_rules(model)\n                percentages = calculate_rule_percentage(model, pos_labels)\n                num_rules_over_threshold = number_of_rules_over_percentage(percentages)\n                num_rules = len(inferred_rules)\n                number_of_positive_predictions = get_number_of_positive_predictions(model)\n\n                if num_rules_over_threshold > 0:\n                    conciseness = number_of_positive_predictions / num_rules_over_threshold\n                else:\n                    conciseness = 0\n\n                # Calculate the percentage of rules over the threshold\n                if num_rules > 0:\n                    rule_percentage = (num_rules_over_threshold / num_rules) * 100\n                else:\n                    rule_percentage = 0\n\n                rule_percentage_results[scenario_name][f'p={p_value}'].append(rule_percentage)\n                conciseness_results[scenario_name][f'p={p_value}'].append(conciseness)\n\n            # Calculate accuracy after each iteration\n            accuracy = calculate_accuracy(warnings_state, ground_truth)\n            accuracy_results[scenario_name][f'p={p_value}'].append(accuracy)\n            print(f'Accuracy after iteration {iteration}: {accuracy:.2f}%')\n            print(f'Percentage of rules over threshold after iteration {iteration}: {rule_percentage:.2f}%')\n            print(f'Conciseness after iteration {iteration}: {conciseness:.2f}')\n\n# Save the results to a csv file\nwith open(warning_type + '_simulation_results.csv', 'w') as f:\n    f.write('Scenario,Probability,Iteration,Accuracy,Rule Percentage,Conciseness\\n')\n    for scenario_name, p_results in accuracy_results.items():\n        for p_value, accuracy_list in p_results.items():\n            rule_percentage_list = rule_percentage_results[scenario_name][p_value]\n            conciseness_list = conciseness_results[scenario_name][p_value]\n            for i in range(len(accuracy_list)):\n                if i < len(rule_percentage_list) and i < len(conciseness_list):\n                    f.write(f'{scenario_name},{p_value},{i},{accuracy_list[i]},{rule_percentage_list[i]},{conciseness_list[i]}\\n')\n                else:\n                    f.write(f'{scenario_name},{p_value},{i},{accuracy_list[i]},0,0\\n')"],time:'2024-09-08T07:39:31.516Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['0','0','443','86','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"# the idea is to try different combinations \n# IMPORTANT: prequisites for running this script : run `meteor` in the `meteor_app` directory \n# Run one of \n# e.g., WARNING_TYPE=apache_lucene-solr__NULL_ WARNING_JSON_NAME=spotbugs_warnings_apache_lucene-solr__NULL_ meteor  \n# e.g., WARNING_JSON_NAME=infer_warnings_alibaba_nacos_NULL_DEREFERENCE meteor \n# e.g,, WARNING_TYPE=RESOURCE_LEAK__presto WARNING_JSON_NAME=infer_warnings_prestodb_presto_RESOURCE_LEAK meteor \n# and generate the background.lp file \n\nimport random\nimport subprocess\nimport sys\nimport os\nfrom collections import defaultdict\nimport json\nimport time\nimport matplotlib.pyplot as plt\n\ndef read_ground_truth(ground_truth_file):\n    ground_truth = {}\n    with open(ground_truth_file) as f:\n        for line in f:\n            line = line.strip().split()\n            ground_truth[line[0]] = line[1]\n    return ground_truth\n\ndef write_labels_to_clingo_input(poss, negs):\n    with open('lp/simulation_labels.lp', 'w+') as f:\n        for p in poss:\n            f.write(f'pos({p}).\\n')\n        for n in negs:\n            f.write(f'neg({n}).\\n')\n\ndef read_containment(containment_file='lp/background.lp'):\n    containment = {}\n    last_checked_id = -1  # Initialize last_checked_id to keep track of the last ID we processed\n\n    with open(containment_file) as f:\n        for line in f:\n            line = line.strip().split()\n\n            # If line contains 'containment', extract the warning ID\n            if 'containment' in line[0]:\n                id = int(line[0].split('containment(')[1].split(',')[0])\n\n                # Only process the first occurrence of each ID\n                if id != last_checked_id:\n                    loc = line[1].split(\")\")[0]\n                    loc = loc.replace('__', '.').replace('_', '.')\n                    last_checked_id = id  # Update last_checked_id to prevent re-checking this ID\n                    containment[id] = loc  # Store the location for this ID\n    return containment\n\ndef heuristic_shorter_code_first(warnings):\n    \"\"\"Sort the warnings by lines of code (ascending).\"\"\"\n    return sorted(warnings, key=lambda x: x[1])\n\ndef heuristic_shared_function_calls(warnings):\n    \"\"\"Sort the warnings by the number of shared function calls (descending).\"\"\"\n    def shared_function_calls(warning, other_warnings):\n        return sum(len(set(warning[2]).intersection(set(other[2]))) for other in other_warnings)\n    #print(sorted(warnings, key=lambda x: shared_function_calls(x, warnings), reverse=True))\n    return sorted(warnings, key=lambda x: shared_function_calls(x, warnings), reverse=True)\n\ndef heuristic_neighbor_classes(warnings, containment):\n    \"\"\"Sort the warnings by neighbor classes (contained in the same package or directory).\"\"\"\n    sorted_warnings = []\n    processed_locs = set()\n    \n    for i in range(len(warnings)):\n        loc = containment.get(int(warnings[i][0]))\n        if loc not in processed_locs:\n            # Find all warnings with the same location\n            same_loc_warnings = [warnings[j] for j in range(i, len(warnings)) if containment.get(int(warnings[j][0])) == loc]\n            sorted_warnings.extend(same_loc_warnings)\n            processed_locs.add(loc)\n    \n    return sorted_warnings\n\ndef initialize_warnings_state(ground_truth):\n    \"\"\"Initialize all warnings with the state 'uninspected'.\"\"\"\n    return {k: 'uninspected' for k in ground_truth.keys()}\n\ndef calculate_accuracy(warnings_state, ground_truth):\n    \"\"\"Calculate the accuracy by comparing the current state of warnings with the ground truth.\"\"\"\n    correct_labels = sum(1 for k, v in warnings_state.items() if v == ground_truth[k])\n    return correct_labels / len(ground_truth) * 100\n\ndef sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings\n\n\ndef run_clingo():\n    files = [\n        f'lp/simulation_labels.lp',  \n        'lp/background.lp',              \n        'lp/frozen_rules.lp',            \n        'lp/rules2.lp'                   \n    ]\n    \n    command = ['clingo'] + files + ['--outf=2'] + ['--time-limit=30'] \n    print(' '.join(command))\n    result = subprocess.run(command, capture_output=True, text=True)\n\n    return result.stdout\n\ndef parse_clingo_output(data):\n    # Load the data using json.loads if 'data' is a string,\n    # otherwise assume it's already a dictionary\n    if isinstance(data, str):\n        #print(data)\n        data = json.loads(data)\n    # Navigate through the JSON structure\n    # Assuming 'Call' is always present and has at least one element\n    calls = data.get(\"Call\", [])\n    if calls:\n        # Assuming 'Witnesses' is always present in the last element of 'Call' and has at least one element\n        last_call = calls[-1]\n        witnesses = last_call.get(\"Witnesses\", [])\n        if witnesses:\n            # Get the last 'Witnesses' entry\n            last_witness = witnesses[-1]\n            # Return the 'Value' list from the last 'Witnesses' entry\n            return last_witness.get(\"Value\", [])\n    return []\n\ndef extract_summary_rules(clingo_output):\n    # a summary rule is one prefixed by rule_contains(number)\n    summary_rules_by_prefix = defaultdict(list)\n    for line in clingo_output:\n        if line.startswith('rule_contains'):\n\n            number_str = line.split('(')[0].split('rule_contains')[1]\n            number = int(number_str) if number_str.isdigit() else 0\n\n            rule = line.split('(')[1].split(')')[0]\n            summary_rules_by_prefix[number].append(rule)\n    return summary_rules_by_prefix\n\ndef calculate_rule_percentage(clingo_output, positive_predictions):\n    summary_rules_by_prefix = defaultdict(list)\n    rule_percentages = {}\n    for line in clingo_output:\n        if line.startswith('rule_predict_pos'):\n            number_str = line.split('(')[0].split('rule_predict_pos')[1]\n            if number_str == '':\n                number_str = '0'\n            number = int(number_str)\n            warning_number = line.split('(')[1].split(')')[0]\n            summary_rules_by_prefix[number].append(warning_number)\n    for rule_number, matched_warnings in summary_rules_by_prefix.items():\n        rule_percentages[rule_number] = len(set(matched_warnings) & set(positive_predictions)) / len(set(matched_warnings))\n    return rule_percentages\n\ndef number_of_rules_over_percentage(percentages, percentage_threshold=0.8):\n    return sum(1 for p in percentages.values() if p >= percentage_threshold)\n\ndef get_number_of_positive_predictions(clingo_output):\n    positive_predictions = set()\n    for line in clingo_output:\n        if line.startswith('rule_predict_pos'):\n            warning_number = line.split('(')[1].split(')')[0]\n            positive_predictions.add(warning_number)\n    return len(positive_predictions)\n\n\ndef get_positive_predictions(clingo_output, rule_numbers):\n    # rule_predict_pos<number>(<warning>)\n    positive_predictions = []\n    for line in clingo_output:\n        if line.startswith('rule_predict_pos'):\n            number_str = line.split('(')[0].split('rule_predict_pos')[1]\n            number = int(number_str) if number_str.isdigit() else 0\n            if number not in rule_numbers:\n                continue\n            # extract warning from parenthesis\n            warning = line.split('(')[1].split(')')[0]\n            if warning not in ground_truth:\n                continue\n            positive_predictions.append(warning)\n    return positive_predictions\n\ndef get_positive_predictions_of_rule(clingo_output, rule_number):\n    # rule_predict_pos<number>(<warning>)\n    positive_predictions = []\n    for line in clingo_output:\n        matches_rule = line.startswith(f'rule_predict_pos{rule_number}') if rule_number != 0 else line.startswith('rule_predict_pos')\n        if matches_rule:\n            # extract warning from parenthesis\n            warning = line.split('(')[1].split(')')[0]\n            if warning not in ground_truth:\n                continue\n            positive_predictions.append(warning)\n    return positive_predictions\n\n# Simulation driver code\n\n# Parameters for the simulation\nwarning_type = sys.argv[1]\nground_truth_file = sys.argv[2]\n\n# Read ground_truth data\nground_truth = read_ground_truth(ground_truth_file)\n\ngraph_id_to_warning = {}\nwith open('meteor_app/private/original_graphs/' + warning_type + '_graph_id_mapping.txt', 'r') as file:\n    for line in file:\n        graph_id = line.split(',')[1]\n        example_id = line.split(',')[2].split(' - ')[0]\n        graph_id_to_warning[graph_id] = example_id\n\n# Load code data from JSON\nwith open('meteor_app/private/original_graphs/' + warning_type + '_elementpositions.json', 'r') as file:\n    code_content_data = json.load(file)\n\ncode_data = {}\n\nfor graph_id_str, another_json_str in code_content_data.items():\n    warning_data = json.loads(another_json_str)\n\n    # Code length\n    raw_code = warning_data.get(\"rawCode\", \"\")\n    raw_code_length = len(raw_code.splitlines())\n    try:\n        warning_id = int(graph_id_to_warning[graph_id_str])\n    except:\n        continue\n\n    code_data[warning_id] = {}\n\n    code_data[warning_id]['linesOfCode'] = raw_code_length\n\n    # Find all code expressions that look like function calls\n    function_calls = [expression for expression in warning_data['expressionStart'].keys() if '()' in expression and '->' not in expression]\n\n    code_data[warning_id]['functionCalls'] = function_calls\n\n# Scenarios: 1 = Heuristic 1, 2 = Heuristic 2, 3 = Heuristic 3, 4 = All Heuristics\nscenarios = {\n    'Heuristic 1 Only': [1]\n    #'Heuristic 2 Only': [2],\n    #'Heuristic 3 Only': [3],\n    #'All Heuristics': [4]\n}\n\n# Store the accuracy, rule percentage, and conciseness results for each scenario\naccuracy_results = {key: {'p=0': [], 'p=0.5': [], 'p=1': []} for key in scenarios.keys()}\nrule_percentage_results = {key: {'p=0': [], 'p=0.5': [], 'p=1': []} for key in scenarios.keys()}\nconciseness_results = {key: {'p=0': [], 'p=0.5': [], 'p=1': []} for key in scenarios.keys()}\n\n\n# Run simulations for each scenario\nfor scenario_name, heuristics in scenarios.items():\n    rule_percentage = 0\n    conciseness = 0\n    accuracy = 0\n    for p_value in [1, 0.5, 0]:\n        print(f\"Running scenario: {scenario_name} with p={p_value}\")\n\n        warnings_state = initialize_warnings_state(ground_truth)\n        num_warnings = len(ground_truth)\n\n\n        # get the first warning\n        selected_pos, selected_neg = sample_labels_randomized_then_sorted(ground_truth, 1, 1, code_data, initialize_warnings_state(ground_truth), apply_heuristics=heuristics)\n        for pos in selected_pos:\n            warnings_state[pos] = 'positive'\n        for neg in selected_neg:\n            warnings_state[neg] = 'negative'\n        \n        pos_labels = [k for k, v in warnings_state.items() if v == 'positive']\n        neg_labels = [k for k, v in warnings_state.items() if v == 'negative']\n\n        write_labels_to_clingo_input(pos_labels, neg_labels)\n        output = run_clingo()\n    \n        # Run simulation for # of warnings iterations\n        for iteration in range(num_warnings - 1):\n            if all([v != 'uninspected' for v in warnings_state.values()]):\n                # fill in the rest of the warnings with the last accuracy, rule percentage, and conciseness\n                for i in range(iteration, num_warnings):\n                    accuracy_results[scenario_name][f'p={p_value}'].append(accuracy)\n                    rule_percentage_results[scenario_name][f'p={p_value}'].append(rule_percentage)\n                    conciseness_results[scenario_name][f'p={p_value}'].append(conciseness)\n                break\n            \n            print(f'Simulation Iteration {iteration} for {scenario_name} with p={p_value}')\n\n            if p_value == 1:\n                # Use the rules to select positive/negative warnings\n                if output:\n                    model = parse_clingo_output(output)\n                    rule_numbers = list(extract_summary_rules(model).keys())\n                    if rule_numbers:\n                        selected_pos = get_positive_predictions_of_rule(model, random.choice(rule_numbers))\n                        selected_neg = []  # Handle negative case similarly if needed\n\n                        # 0.1 probability to mark all matching warnings as positive/negative\n                        if random.random() > 0.05:\n                            selected_pos, selected_neg = sample_labels_randomized_then_sorted(ground_truth, 1, 1, code_data, warnings_state, apply_heuristics=heuristics)\n                        for pos in selected_pos:\n                            warnings_state[pos] = 'positive'\n                        for neg in selected_neg:\n                            warnings_state[neg] = 'negative'\n            elif p_value == 0.5:\n                # 50% chance to use the rules or the original heuristic-based sampling\n                if random.random() < 0.5:\n                    if output:\n                        model = parse_clingo_output(output)\n                        rule_numbers = list(extract_summary_rules(model).keys())\n                        if rule_numbers:\n                            selected_pos = get_positive_predictions_of_rule(model, random.choice(rule_numbers))\n                            selected_neg = []  # Handle negative case similarly if needed\n\n                            # 0.1 probability to mark all matching warnings as positive/negative\n                            if random.random() > 0.05:\n                                selected_pos, selected_neg = sample_labels_randomized_then_sorted(ground_truth, 1, 1, code_data, warnings_state, apply_heuristics=heuristics)\n                            for pos in selected_pos:\n                                warnings_state[pos] = 'positive'\n                            for neg in selected_neg:\n                                warnings_state[neg] = 'negative'                                \n                else:\n                    selected_pos, selected_neg = sample_labels_randomized_then_sorted(ground_truth, 1, 1, code_data, warnings_state, apply_heuristics=heuristics)\n            elif p_value == 0:\n                # p=0, just use the original heuristic-based sampling\n                selected_pos, selected_neg = sample_labels_randomized_then_sorted(ground_truth, 1, 1, code_data, warnings_state, apply_heuristics=heuristics)\n\n            # Write labels to Clingo input and run Clingo\n            pos_labels = [k for k, v in warnings_state.items() if v == 'positive']\n            neg_labels = [k for k, v in warnings_state.items() if v == 'negative']\n\n            write_labels_to_clingo_input(pos_labels, neg_labels)\n            output = run_clingo()\n\n            if output:\n                model = parse_clingo_output(output)\n                inferred_rules = extract_summary_rules(model)\n                percentages = calculate_rule_percentage(model, pos_labels)\n                num_rules_over_threshold = number_of_rules_over_percentage(percentages)\n                num_rules = len(inferred_rules)\n                number_of_positive_predictions = get_number_of_positive_predictions(model)\n\n                if num_rules_over_threshold > 0:\n                    conciseness = number_of_positive_predictions / num_rules_over_threshold\n                else:\n                    conciseness = 0\n\n                # Calculate the percentage of rules over the threshold\n                if num_rules > 0:\n                    rule_percentage = (num_rules_over_threshold / num_rules) * 100\n                else:\n                    rule_percentage = 0\n\n                rule_percentage_results[scenario_name][f'p={p_value}'].append(rule_percentage)\n                conciseness_results[scenario_name][f'p={p_value}'].append(conciseness)\n\n            # Calculate accuracy after each iteration\n            accuracy = calculate_accuracy(warnings_state, ground_truth)\n            accuracy_results[scenario_name][f'p={p_value}'].append(accuracy)\n            print(f'Accuracy after iteration {iteration}: {accuracy:.2f}%')\n            print(f'Percentage of rules over threshold after iteration {iteration}: {rule_percentage:.2f}%')\n            print(f'Conciseness after iteration {iteration}: {conciseness:.2f}')\n\n# Save the results to a csv file\nwith open(warning_type + '_simulation_results.csv', 'w') as f:\n    f.write('Scenario,Probability,Iteration,Accuracy,Rule Percentage,Conciseness\\n')\n    for scenario_name, p_results in accuracy_results.items():\n        for p_value, accuracy_list in p_results.items():\n            rule_percentage_list = rule_percentage_results[scenario_name][p_value]\n            conciseness_list = conciseness_results[scenario_name][p_value]\n            for i in range(len(accuracy_list)):\n                if i < len(rule_percentage_list) and i < len(conciseness_list):\n                    f.write(f'{scenario_name},{p_value},{i},{accuracy_list[i]},{rule_percentage_list[i]},{conciseness_list[i]}\\n')\n                else:\n                    f.write(f'{scenario_name},{p_value},{i},{accuracy_list[i]},0,0\\n')"],time:'2024-09-08T07:39:31.544Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['416','0','443','86','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:31.544Z'},{src:'onDidChangeTextDocument',msg:'%s:%s to %s:%s in [%s] replaced with: %s`',prm:['0','0','443','86','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"# the idea is to try different combinations \n# IMPORTANT: prequisites for running this script : run `meteor` in the `meteor_app` directory \n# Run one of \n# e.g., WARNING_TYPE=apache_lucene-solr__NULL_ WARNING_JSON_NAME=spotbugs_warnings_apache_lucene-solr__NULL_ meteor  \n# e.g., WARNING_JSON_NAME=infer_warnings_alibaba_nacos_NULL_DEREFERENCE meteor \n# e.g,, WARNING_TYPE=RESOURCE_LEAK__presto WARNING_JSON_NAME=infer_warnings_prestodb_presto_RESOURCE_LEAK meteor \n# and generate the background.lp file \n\nimport random\nimport subprocess\nimport sys\nimport os\nfrom collections import defaultdict\nimport json\nimport time\nimport matplotlib.pyplot as plt\n\ndef read_ground_truth(ground_truth_file):\n    ground_truth = {}\n    with open(ground_truth_file) as f:\n        for line in f:\n            line = line.strip().split()\n            ground_truth[line[0]] = line[1]\n    return ground_truth\n\ndef write_labels_to_clingo_input(poss, negs):\n    with open('lp/simulation_labels.lp', 'w+') as f:\n        for p in poss:\n            f.write(f'pos({p}).\\n')\n        for n in negs:\n            f.write(f'neg({n}).\\n')\n\ndef read_containment(containment_file='lp/background.lp'):\n    containment = {}\n    last_checked_id = -1  # Initialize last_checked_id to keep track of the last ID we processed\n\n    with open(containment_file) as f:\n        for line in f:\n            line = line.strip().split()\n\n            # If line contains 'containment', extract the warning ID\n            if 'containment' in line[0]:\n                id = int(line[0].split('containment(')[1].split(',')[0])\n\n                # Only process the first occurrence of each ID\n                if id != last_checked_id:\n                    loc = line[1].split(\")\")[0]\n                    loc = loc.replace('__', '.').replace('_', '.')\n                    last_checked_id = id  # Update last_checked_id to prevent re-checking this ID\n                    containment[id] = loc  # Store the location for this ID\n    return containment\n\ndef heuristic_shorter_code_first(warnings):\n    \"\"\"Sort the warnings by lines of code (ascending).\"\"\"\n    return sorted(warnings, key=lambda x: x[1])\n\ndef heuristic_shared_function_calls(warnings):\n    \"\"\"Sort the warnings by the number of shared function calls (descending).\"\"\"\n    def shared_function_calls(warning, other_warnings):\n        return sum(len(set(warning[2]).intersection(set(other[2]))) for other in other_warnings)\n    #print(sorted(warnings, key=lambda x: shared_function_calls(x, warnings), reverse=True))\n    return sorted(warnings, key=lambda x: shared_function_calls(x, warnings), reverse=True)\n\ndef heuristic_neighbor_classes(warnings, containment):\n    \"\"\"Sort the warnings by neighbor classes (contained in the same package or directory).\"\"\"\n    sorted_warnings = []\n    processed_locs = set()\n    \n    for i in range(len(warnings)):\n        loc = containment.get(int(warnings[i][0]))\n        if loc not in processed_locs:\n            # Find all warnings with the same location\n            same_loc_warnings = [warnings[j] for j in range(i, len(warnings)) if containment.get(int(warnings[j][0])) == loc]\n            sorted_warnings.extend(same_loc_warnings)\n            processed_locs.add(loc)\n    \n    return sorted_warnings\n\ndef initialize_warnings_state(ground_truth):\n    \"\"\"Initialize all warnings with the state 'uninspected'.\"\"\"\n    return {k: 'uninspected' for k in ground_truth.keys()}\n\ndef calculate_accuracy(warnings_state, ground_truth):\n    \"\"\"Calculate the accuracy by comparing the current state of warnings with the ground truth.\"\"\"\n    correct_labels = sum(1 for k, v in warnings_state.items() if v == ground_truth[k])\n    return correct_labels / len(ground_truth) * 100\n\ndef sample_pos_with_heuristic(selected_warnings, code_data, warnings_state, apply_heuristics=None):\n    # create the second dim for every item in selected_warnings\n    selected_warnings = [(warning, 0, 0, 'uninspected') for warning in selected_warnings]\n    # sort by code length to identify shortest and longest warnings. selected_warnings do not contain the code length find it from warnings\n    for i, warning in enumerate(selected_warnings):\n        warning_id = warning[0]\n        selected_warnings[i] = list(warning)\n        selected_warnings[i][1] = code_data.get(int(warning_id), {}).get('linesOfCode', 0)\n        selected_warnings[i][2] = code_data.get(int(warning_id), {}).get('functionCalls', [])\n        selected_warnings[i] = tuple(selected_warnings[i])\n    \n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            selected_warnings = heuristic_shorter_code_first(selected_warnings)\n        elif heuristic == 2:\n            selected_warnings = heuristic_shared_function_calls(selected_warnings)\n        elif heuristic == 3:\n            selected_warnings = heuristic_neighbor_classes(selected_warnings)\n        elif heuristic == 4:\n            # choose a random heuristic\n            selected_warnings = random.choice([heuristic_shorter_code_first(selected_warnings), heuristic_shared_function_calls(selected_warnings), heuristic_neighbor_classes(selected_warnings)])\n    \n    sorted_warnings_by_length = sorted(selected_warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(selected_warnings)):\n        if selected_warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'positive'\n            selected_warnings[i] = tuple(selected_warnings[i])\n        else:\n            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'negative'\n            selected_warnings[i] = tuple(selected_warnings[i])\n\n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n\n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [selected_warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [selected_warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n\n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n\n    return selected_positive_warnings, selected_negative_warnings\n\n\ndef sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings\n\n\ndef run_clingo():\n    files = [\n        f'lp/simulation_labels.lp',  \n        'lp/background.lp',              \n        'lp/frozen_rules.lp',            \n        'lp/rules2.lp'                   \n    ]\n    \n    command = ['clingo'] + files + ['--outf=2'] + ['--time-limit=30'] \n    print(' '.join(command))\n    result = subprocess.run(command, capture_output=True, text=True)\n\n    return result.stdout\n\ndef parse_clingo_output(data):\n    # Load the data using json.loads if 'data' is a string,\n    # otherwise assume it's already a dictionary\n    if isinstance(data, str):\n        #print(data)\n        data = json.loads(data.replace(\"'\", '\"'))\n    # Navigate through the JSON structure\n    # Assuming 'Call' is always present and has at least one element\n    calls = data.get(\"Call\", [])\n    if calls:\n        # Assuming 'Witnesses' is always present in the last element of 'Call' and has at least one element\n        last_call = calls[-1]\n        witnesses = last_call.get(\"Witnesses\", [])\n        if witnesses:\n            # Get the last 'Witnesses' entry\n            last_witness = witnesses[-1]\n            # Return the 'Value' list from the last 'Witnesses' entry\n            return last_witness.get(\"Value\", [])\n    return []\n\ndef extract_summary_rules(clingo_output):\n    # a summary rule is one prefixed by rule_contains(number)\n    summary_rules_by_prefix = defaultdict(list)\n    for line in clingo_output:\n        if line.startswith('rule_contains'):\n\n            number_str = line.split('(')[0].split('rule_contains')[1]\n            number = int(number_str) if number_str.isdigit() else 0\n\n            rule = line.split('(')[1].split(')')[0]\n            summary_rules_by_prefix[number].append(rule)\n    return summary_rules_by_prefix\n\ndef calculate_rule_percentage(clingo_output, positive_predictions):\n    summary_rules_by_prefix = defaultdict(list)\n    rule_percentages = {}\n    for line in clingo_output:\n        if line.startswith('rule_predict_pos'):\n            number_str = line.split('(')[0].split('rule_predict_pos')[1]\n            if number_str == '':\n                number_str = '0'\n            number = int(number_str)\n            warning_number = line.split('(')[1].split(')')[0]\n            summary_rules_by_prefix[number].append(warning_number)\n    for rule_number, matched_warnings in summary_rules_by_prefix.items():\n        rule_percentages[rule_number] = len(set(matched_warnings) & set(positive_predictions)) / len(set(matched_warnings))\n    return rule_percentages\n\ndef number_of_rules_over_percentage(percentages, percentage_threshold=0.8):\n    return sum(1 for p in percentages.values() if p >= percentage_threshold)\n\ndef get_number_of_positive_predictions(clingo_output):\n    positive_predictions = set()\n    for line in clingo_output:\n        if line.startswith('rule_predict_pos'):\n            warning_number = line.split('(')[1].split(')')[0]\n            positive_predictions.add(warning_number)\n    return len(positive_predictions)\n\n\ndef get_positive_predictions(clingo_output, rule_numbers):\n    # rule_predict_pos<number>(<warning>)\n    positive_predictions = []\n    for line in clingo_output:\n        if line.startswith('rule_predict_pos'):\n            number_str = line.split('(')[0].split('rule_predict_pos')[1]\n            number = int(number_str) if number_str.isdigit() else 0\n            if number not in rule_numbers:\n                continue\n            # extract warning from parenthesis\n            warning = line.split('(')[1].split(')')[0]\n            if warning not in ground_truth:\n                continue\n            positive_predictions.append(warning)\n    return positive_predictions\n\ndef get_positive_predictions_of_rule(clingo_output, rule_number):\n    # rule_predict_pos<number>(<warning>)\n    positive_predictions = []\n    for line in clingo_output:\n        matches_rule = line.startswith(f'rule_predict_pos{rule_number}') if rule_number != 0 else line.startswith('rule_predict_pos')\n        if matches_rule:\n            # extract warning from parenthesis\n            warning = line.split('(')[1].split(')')[0]\n            if warning not in ground_truth:\n                continue\n            positive_predictions.append(warning)\n    return positive_predictions    \n\n# Simulation driver code\n\n# Parameters for the simulation\nwarning_type = sys.argv[1]\nground_truth_file = sys.argv[2]\n\n# Read ground_truth data\nground_truth = read_ground_truth(ground_truth_file)\n\ngraph_id_to_warning = {}\nwith open('meteor_app/private/original_graphs/' + warning_type + '_graph_id_mapping.txt', 'r') as file:\n    for line in file:\n        graph_id = line.split(',')[1]\n        example_id = line.split(',')[2].split(' - ')[0]\n        graph_id_to_warning[graph_id] = example_id\n\n# Load code data from JSON\nwith open('meteor_app/private/original_graphs/' + warning_type + '_elementpositions.json', 'r') as file:\n    code_content_data = json.load(file)\n\ncode_data = {}\n\nfor graph_id_str, another_json_str in code_content_data.items():\n    warning_data = json.loads(another_json_str)\n\n    # Code length\n    raw_code = warning_data.get(\"rawCode\", \"\")\n    raw_code_length = len(raw_code.splitlines())\n    try:\n        warning_id = int(graph_id_to_warning[graph_id_str])\n    except:\n        continue\n\n    code_data[warning_id] = {}\n\n    code_data[warning_id]['linesOfCode'] = raw_code_length\n\n    # Find all code expressions that look like function calls\n    function_calls = [expression for expression in warning_data['expressionStart'].keys() if '()' in expression and '->' not in expression]\n\n    code_data[warning_id]['functionCalls'] = function_calls\n\n# Scenarios: 1 = Heuristic 1, 2 = Heuristic 2, 3 = Heuristic 3, 4 = All Heuristics\nscenarios = {\n    'Heuristic 1 Only': [1]\n    #'Heuristic 2 Only': [2]\n    #'Heuristic 3 Only': [3],\n    #'All Heuristics': [4]\n}\n\n# Store the accuracy, rule percentage, and conciseness results for each scenario\naccuracy_results = {key: {'p=0': [], 'p=0.5': [], 'p=1': []} for key in scenarios.keys()}\nrule_percentage_results = {key: {'p=0': [], 'p=0.5': [], 'p=1': []} for key in scenarios.keys()}\nconciseness_results = {key: {'p=0': [], 'p=0.5': [], 'p=1': []} for key in scenarios.keys()}\n\n\n# Run simulations for each scenario\nfor scenario_name, heuristics in scenarios.items():\n    rule_percentage = 0\n    conciseness = 0\n    accuracy = 0\n    for p_value in [1, 0.5, 0]:\n        print(f\"Running scenario: {scenario_name} with p={p_value}\")\n\n        warnings_state = initialize_warnings_state(ground_truth)\n        num_warnings = len(ground_truth)\n\n\n        # get the first warning\n        selected_pos, selected_neg = sample_labels_randomized_then_sorted(ground_truth, 1, 1, code_data, initialize_warnings_state(ground_truth), apply_heuristics=heuristics)\n        for pos in selected_pos:\n            warnings_state[pos] = 'positive'\n        for neg in selected_neg:\n            warnings_state[neg] = 'negative'\n        \n        pos_labels = [k for k, v in warnings_state.items() if v == 'positive']\n        neg_labels = [k for k, v in warnings_state.items() if v == 'negative']\n\n        write_labels_to_clingo_input(pos_labels, neg_labels)\n        output = run_clingo()\n    \n        # Run simulation for # of warnings iterations\n        for iteration in range(num_warnings - 1):\n            if all([v != 'uninspected' for v in warnings_state.values()]):\n                # fill in the rest of the warnings with the last accuracy, rule percentage, and conciseness\n                for i in range(iteration, num_warnings):\n                    accuracy_results[scenario_name][f'p={p_value}'].append(accuracy)\n                    rule_percentage_results[scenario_name][f'p={p_value}'].append(rule_percentage)\n                    conciseness_results[scenario_name][f'p={p_value}'].append(conciseness)\n                break\n            \n            print(f'Simulation Iteration {iteration} for {scenario_name} with p={p_value}')\n\n            if p_value == 1:\n                print('Using rules to select positive/negative warnings')\n                # Use the rules to select positive/negative warnings\n                if output:\n                    model = parse_clingo_output(output)\n                    rule_numbers = list(extract_summary_rules(model).keys())\n                    if rule_numbers:\n                        selected_all_pos = get_positive_predictions_of_rule(model, random.choice(rule_numbers))\n                        selected_pos, selected_neg = sample_pos_with_heuristic(selected_all_pos, code_data, warnings_state, apply_heuristics=heuristics)\n\n                        for pos in selected_pos:\n                            warnings_state[pos] = 'positive'\n                        for neg in selected_neg:\n                            warnings_state[neg] = 'negative'\n\n                        # 0.05 probability to mark all matching warnings as positive/negative\n                        if random.random() <= 0.05 and iteration > num_warnings // 2:\n                            for pos in selected_all_pos:\n                                warnings_state[pos] = 'positive'\n\n            elif p_value == 0.5:\n                # 50% chance to use the rules or the original heuristic-based sampling\n                if random.random() < 0.5:\n                    if output:\n                        model = parse_clingo_output(output)\n                        rule_numbers = list(extract_summary_rules(model).keys())\n                        if rule_numbers:\n                            selected_all_pos = get_positive_predictions_of_rule(model, random.choice(rule_numbers))\n                            selected_pos, selected_neg = sample_pos_with_heuristic(selected_all_pos, code_data, warnings_state, apply_heuristics=heuristics)\n\n\n                            for pos in selected_pos:\n                                warnings_state[pos] = 'positive'\n                            for neg in selected_neg:\n                                warnings_state[neg] = 'negative'\n\n                            # 0.05 probability to mark all matching warnings as positive/negative\n                            if random.random() <= 0.05 and iteration > num_warnings // 2:\n                                for pos in selected_all_pos:\n                                    warnings_state[pos] = 'positive'\n                else:\n                    selected_pos, selected_neg = sample_labels_randomized_then_sorted(ground_truth, 1, 1, code_data, warnings_state, apply_heuristics=heuristics)\n                    for pos in selected_pos:\n                        warnings_state[pos] = 'positive'\n                    for neg in selected_neg:\n                        warnings_state[neg] = 'negative'\n            elif p_value == 0:\n                # p=0, just use the original heuristic-based sampling\n                selected_pos, selected_neg = sample_labels_randomized_then_sorted(ground_truth, 1, 1, code_data, warnings_state, apply_heuristics=heuristics)\n                for pos in selected_pos:\n                    warnings_state[pos] = 'positive'\n                for neg in selected_neg:\n                    warnings_state[neg] = 'negative'\n\n            # Write labels to Clingo input and run Clingo\n            pos_labels = [k for k, v in warnings_state.items() if v == 'positive']\n            neg_labels = [k for k, v in warnings_state.items() if v == 'negative']\n\n            print('Positive labels:', pos_labels)\n            print('Negative labels:', neg_labels)\n            write_labels_to_clingo_input(pos_labels, neg_labels)\n            output = run_clingo()\n            #print('Output:', output)\n\n            if output:\n                model = parse_clingo_output(output)\n                inferred_rules = extract_summary_rules(model)\n                percentages = calculate_rule_percentage(model, pos_labels)\n                num_rules_over_threshold = number_of_rules_over_percentage(percentages)\n                num_rules = len(inferred_rules)\n                number_of_positive_predictions = get_number_of_positive_predictions(model)\n\n                if num_rules_over_threshold > 0:\n                    conciseness = number_of_positive_predictions / num_rules_over_threshold\n                else:\n                    conciseness = 0\n\n                # Calculate the percentage of rules over the threshold\n                if num_rules > 0:\n                    rule_percentage = (num_rules_over_threshold / num_rules) * 100\n                else:\n                    rule_percentage = 0\n\n                rule_percentage_results[scenario_name][f'p={p_value}'].append(rule_percentage)\n                conciseness_results[scenario_name][f'p={p_value}'].append(conciseness)\n\n            # Calculate accuracy after each iteration\n            accuracy = calculate_accuracy(warnings_state, ground_truth)\n            accuracy_results[scenario_name][f'p={p_value}'].append(accuracy)\n            print(f'Accuracy after iteration {iteration}: {accuracy:.2f}%')\n            print(f'Percentage of rules over threshold after iteration {iteration}: {rule_percentage:.2f}%')\n            print(f'Conciseness after iteration {iteration}: {conciseness:.2f}')\n\n# Save the results to a csv file\nif scenario_name == 'Heuristic 1 Only':\n    scenario_name = 'h=1'\nelif scenario_name == 'Heuristic 2 Only':\n    scenario_name = 'h=2'\nelif scenario_name == 'Heuristic 3 Only':\n    scenario_name = 'h=3'\nelif scenario_name == 'All Heuristics':\n    scenario_name = 'h=4'\n\nif warning_type == 'apache_lucene-solr__NULL_':\n    warning_type = 'apache_lucene_' + scenario_name\nelif warning_type == 'NULL_DEREFERENCE__nacos':\n    warning_type = 'alibaba_nacos_' + scenario_name\nelif warning_type == 'RESOURCE_LEAK__presto':\n    warning_type = 'presto_' + scenario_name\nelif warning_type == 'dubbo_external':\n    warning_type = 'apache_dubbo_' + scenario_name\n\nwith open(warning_type + '.csv', 'w') as f:\n    f.write('Scenario,Probability,Iteration,Accuracy,Rule Percentage,Conciseness\\n')\n    for scenario_name, p_results in accuracy_results.items():\n        for p_value, accuracy_list in p_results.items():\n            rule_percentage_list = rule_percentage_results[scenario_name][p_value]\n            conciseness_list = conciseness_results[scenario_name][p_value]\n            for i in range(len(accuracy_list)):\n                if i < len(rule_percentage_list) and i < len(conciseness_list):\n                    f.write(f'{scenario_name},{p_value},{i},{accuracy_list[i]},{rule_percentage_list[i]},{conciseness_list[i]}\\n')\n                else:\n                    f.write(f'{scenario_name},{p_value},{i},{accuracy_list[i]},0,0\\n')"],time:'2024-09-08T07:39:32.633Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['0','0','536','86','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"# the idea is to try different combinations \n# IMPORTANT: prequisites for running this script : run `meteor` in the `meteor_app` directory \n# Run one of \n# e.g., WARNING_TYPE=apache_lucene-solr__NULL_ WARNING_JSON_NAME=spotbugs_warnings_apache_lucene-solr__NULL_ meteor  \n# e.g., WARNING_JSON_NAME=infer_warnings_alibaba_nacos_NULL_DEREFERENCE meteor \n# e.g,, WARNING_TYPE=RESOURCE_LEAK__presto WARNING_JSON_NAME=infer_warnings_prestodb_presto_RESOURCE_LEAK meteor \n# and generate the background.lp file \n\nimport random\nimport subprocess\nimport sys\nimport os\nfrom collections import defaultdict\nimport json\nimport time\nimport matplotlib.pyplot as plt\n\ndef read_ground_truth(ground_truth_file):\n    ground_truth = {}\n    with open(ground_truth_file) as f:\n        for line in f:\n            line = line.strip().split()\n            ground_truth[line[0]] = line[1]\n    return ground_truth\n\ndef write_labels_to_clingo_input(poss, negs):\n    with open('lp/simulation_labels.lp', 'w+') as f:\n        for p in poss:\n            f.write(f'pos({p}).\\n')\n        for n in negs:\n            f.write(f'neg({n}).\\n')\n\ndef read_containment(containment_file='lp/background.lp'):\n    containment = {}\n    last_checked_id = -1  # Initialize last_checked_id to keep track of the last ID we processed\n\n    with open(containment_file) as f:\n        for line in f:\n            line = line.strip().split()\n\n            # If line contains 'containment', extract the warning ID\n            if 'containment' in line[0]:\n                id = int(line[0].split('containment(')[1].split(',')[0])\n\n                # Only process the first occurrence of each ID\n                if id != last_checked_id:\n                    loc = line[1].split(\")\")[0]\n                    loc = loc.replace('__', '.').replace('_', '.')\n                    last_checked_id = id  # Update last_checked_id to prevent re-checking this ID\n                    containment[id] = loc  # Store the location for this ID\n    return containment\n\ndef heuristic_shorter_code_first(warnings):\n    \"\"\"Sort the warnings by lines of code (ascending).\"\"\"\n    return sorted(warnings, key=lambda x: x[1])\n\ndef heuristic_shared_function_calls(warnings):\n    \"\"\"Sort the warnings by the number of shared function calls (descending).\"\"\"\n    def shared_function_calls(warning, other_warnings):\n        return sum(len(set(warning[2]).intersection(set(other[2]))) for other in other_warnings)\n    #print(sorted(warnings, key=lambda x: shared_function_calls(x, warnings), reverse=True))\n    return sorted(warnings, key=lambda x: shared_function_calls(x, warnings), reverse=True)\n\ndef heuristic_neighbor_classes(warnings, containment):\n    \"\"\"Sort the warnings by neighbor classes (contained in the same package or directory).\"\"\"\n    sorted_warnings = []\n    processed_locs = set()\n    \n    for i in range(len(warnings)):\n        loc = containment.get(int(warnings[i][0]))\n        if loc not in processed_locs:\n            # Find all warnings with the same location\n            same_loc_warnings = [warnings[j] for j in range(i, len(warnings)) if containment.get(int(warnings[j][0])) == loc]\n            sorted_warnings.extend(same_loc_warnings)\n            processed_locs.add(loc)\n    \n    return sorted_warnings\n\ndef initialize_warnings_state(ground_truth):\n    \"\"\"Initialize all warnings with the state 'uninspected'.\"\"\"\n    return {k: 'uninspected' for k in ground_truth.keys()}\n\ndef calculate_accuracy(warnings_state, ground_truth):\n    \"\"\"Calculate the accuracy by comparing the current state of warnings with the ground truth.\"\"\"\n    correct_labels = sum(1 for k, v in warnings_state.items() if v == ground_truth[k])\n    return correct_labels / len(ground_truth) * 100\n\ndef sample_pos_with_heuristic(selected_warnings, code_data, warnings_state, apply_heuristics=None):\n    # create the second dim for every item in selected_warnings\n    selected_warnings = [(warning, 0, 0, 'uninspected') for warning in selected_warnings]\n    # sort by code length to identify shortest and longest warnings. selected_warnings do not contain the code length find it from warnings\n    for i, warning in enumerate(selected_warnings):\n        warning_id = warning[0]\n        selected_warnings[i] = list(warning)\n        selected_warnings[i][1] = code_data.get(int(warning_id), {}).get('linesOfCode', 0)\n        selected_warnings[i][2] = code_data.get(int(warning_id), {}).get('functionCalls', [])\n        selected_warnings[i] = tuple(selected_warnings[i])\n    \n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            selected_warnings = heuristic_shorter_code_first(selected_warnings)\n        elif heuristic == 2:\n            selected_warnings = heuristic_shared_function_calls(selected_warnings)\n        elif heuristic == 3:\n            selected_warnings = heuristic_neighbor_classes(selected_warnings)\n        elif heuristic == 4:\n            # choose a random heuristic\n            selected_warnings = random.choice([heuristic_shorter_code_first(selected_warnings), heuristic_shared_function_calls(selected_warnings), heuristic_neighbor_classes(selected_warnings)])\n    \n    sorted_warnings_by_length = sorted(selected_warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(selected_warnings)):\n        if selected_warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'positive'\n            selected_warnings[i] = tuple(selected_warnings[i])\n        else:\n            selected_warnings[i] = list(selected_warnings[i])\n            selected_warnings[i][3] = 'negative'\n            selected_warnings[i] = tuple(selected_warnings[i])\n\n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n\n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [selected_warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [selected_warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n\n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n\n    return selected_positive_warnings, selected_negative_warnings\n\n\ndef sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings\n\n\ndef run_clingo():\n    files = [\n        f'lp/simulation_labels.lp',  \n        'lp/background.lp',              \n        'lp/frozen_rules.lp',            \n        'lp/rules2.lp'                   \n    ]\n    \n    command = ['clingo'] + files + ['--outf=2'] + ['--time-limit=30'] \n    print(' '.join(command))\n    result = subprocess.run(command, capture_output=True, text=True)\n\n    return result.stdout\n\ndef parse_clingo_output(data):\n    # Load the data using json.loads if 'data' is a string,\n    # otherwise assume it's already a dictionary\n    if isinstance(data, str):\n        #print(data)\n        data = json.loads(data.replace(\"'\", '\"'))\n    # Navigate through the JSON structure\n    # Assuming 'Call' is always present and has at least one element\n    calls = data.get(\"Call\", [])\n    if calls:\n        # Assuming 'Witnesses' is always present in the last element of 'Call' and has at least one element\n        last_call = calls[-1]\n        witnesses = last_call.get(\"Witnesses\", [])\n        if witnesses:\n            # Get the last 'Witnesses' entry\n            last_witness = witnesses[-1]\n            # Return the 'Value' list from the last 'Witnesses' entry\n            return last_witness.get(\"Value\", [])\n    return []\n\ndef extract_summary_rules(clingo_output):\n    # a summary rule is one prefixed by rule_contains(number)\n    summary_rules_by_prefix = defaultdict(list)\n    for line in clingo_output:\n        if line.startswith('rule_contains'):\n\n            number_str = line.split('(')[0].split('rule_contains')[1]\n            number = int(number_str) if number_str.isdigit() else 0\n\n            rule = line.split('(')[1].split(')')[0]\n            summary_rules_by_prefix[number].append(rule)\n    return summary_rules_by_prefix\n\ndef calculate_rule_percentage(clingo_output, positive_predictions):\n    summary_rules_by_prefix = defaultdict(list)\n    rule_percentages = {}\n    for line in clingo_output:\n        if line.startswith('rule_predict_pos'):\n            number_str = line.split('(')[0].split('rule_predict_pos')[1]\n            if number_str == '':\n                number_str = '0'\n            number = int(number_str)\n            warning_number = line.split('(')[1].split(')')[0]\n            summary_rules_by_prefix[number].append(warning_number)\n    for rule_number, matched_warnings in summary_rules_by_prefix.items():\n        rule_percentages[rule_number] = len(set(matched_warnings) & set(positive_predictions)) / len(set(matched_warnings))\n    return rule_percentages\n\ndef number_of_rules_over_percentage(percentages, percentage_threshold=0.8):\n    return sum(1 for p in percentages.values() if p >= percentage_threshold)\n\ndef get_number_of_positive_predictions(clingo_output):\n    positive_predictions = set()\n    for line in clingo_output:\n        if line.startswith('rule_predict_pos'):\n            warning_number = line.split('(')[1].split(')')[0]\n            positive_predictions.add(warning_number)\n    return len(positive_predictions)\n\n\ndef get_positive_predictions(clingo_output, rule_numbers):\n    # rule_predict_pos<number>(<warning>)\n    positive_predictions = []\n    for line in clingo_output:\n        if line.startswith('rule_predict_pos'):\n            number_str = line.split('(')[0].split('rule_predict_pos')[1]\n            number = int(number_str) if number_str.isdigit() else 0\n            if number not in rule_numbers:\n                continue\n            # extract warning from parenthesis\n            warning = line.split('(')[1].split(')')[0]\n            if warning not in ground_truth:\n                continue\n            positive_predictions.append(warning)\n    return positive_predictions\n\ndef get_positive_predictions_of_rule(clingo_output, rule_number):\n    # rule_predict_pos<number>(<warning>)\n    positive_predictions = []\n    for line in clingo_output:\n        matches_rule = line.startswith(f'rule_predict_pos{rule_number}') if rule_number != 0 else line.startswith('rule_predict_pos')\n        if matches_rule:\n            # extract warning from parenthesis\n            warning = line.split('(')[1].split(')')[0]\n            if warning not in ground_truth:\n                continue\n            positive_predictions.append(warning)\n    return positive_predictions    \n\n# Simulation driver code\n\n# Parameters for the simulation\nwarning_type = sys.argv[1]\nground_truth_file = sys.argv[2]\n\n# Read ground_truth data\nground_truth = read_ground_truth(ground_truth_file)\n\ngraph_id_to_warning = {}\nwith open('meteor_app/private/original_graphs/' + warning_type + '_graph_id_mapping.txt', 'r') as file:\n    for line in file:\n        graph_id = line.split(',')[1]\n        example_id = line.split(',')[2].split(' - ')[0]\n        graph_id_to_warning[graph_id] = example_id\n\n# Load code data from JSON\nwith open('meteor_app/private/original_graphs/' + warning_type + '_elementpositions.json', 'r') as file:\n    code_content_data = json.load(file)\n\ncode_data = {}\n\nfor graph_id_str, another_json_str in code_content_data.items():\n    warning_data = json.loads(another_json_str)\n\n    # Code length\n    raw_code = warning_data.get(\"rawCode\", \"\")\n    raw_code_length = len(raw_code.splitlines())\n    try:\n        warning_id = int(graph_id_to_warning[graph_id_str])\n    except:\n        continue\n\n    code_data[warning_id] = {}\n\n    code_data[warning_id]['linesOfCode'] = raw_code_length\n\n    # Find all code expressions that look like function calls\n    function_calls = [expression for expression in warning_data['expressionStart'].keys() if '()' in expression and '->' not in expression]\n\n    code_data[warning_id]['functionCalls'] = function_calls\n\n# Scenarios: 1 = Heuristic 1, 2 = Heuristic 2, 3 = Heuristic 3, 4 = All Heuristics\nscenarios = {\n    'Heuristic 1 Only': [1]\n    #'Heuristic 2 Only': [2]\n    #'Heuristic 3 Only': [3],\n    #'All Heuristics': [4]\n}\n\n# Store the accuracy, rule percentage, and conciseness results for each scenario\naccuracy_results = {key: {'p=0': [], 'p=0.5': [], 'p=1': []} for key in scenarios.keys()}\nrule_percentage_results = {key: {'p=0': [], 'p=0.5': [], 'p=1': []} for key in scenarios.keys()}\nconciseness_results = {key: {'p=0': [], 'p=0.5': [], 'p=1': []} for key in scenarios.keys()}\n\n\n# Run simulations for each scenario\nfor scenario_name, heuristics in scenarios.items():\n    rule_percentage = 0\n    conciseness = 0\n    accuracy = 0\n    for p_value in [1, 0.5, 0]:\n        print(f\"Running scenario: {scenario_name} with p={p_value}\")\n\n        warnings_state = initialize_warnings_state(ground_truth)\n        num_warnings = len(ground_truth)\n\n\n        # get the first warning\n        selected_pos, selected_neg = sample_labels_randomized_then_sorted(ground_truth, 1, 1, code_data, initialize_warnings_state(ground_truth), apply_heuristics=heuristics)\n        for pos in selected_pos:\n            warnings_state[pos] = 'positive'\n        for neg in selected_neg:\n            warnings_state[neg] = 'negative'\n        \n        pos_labels = [k for k, v in warnings_state.items() if v == 'positive']\n        neg_labels = [k for k, v in warnings_state.items() if v == 'negative']\n\n        write_labels_to_clingo_input(pos_labels, neg_labels)\n        output = run_clingo()\n    \n        # Run simulation for # of warnings iterations\n        for iteration in range(num_warnings - 1):\n            if all([v != 'uninspected' for v in warnings_state.values()]):\n                # fill in the rest of the warnings with the last accuracy, rule percentage, and conciseness\n                for i in range(iteration, num_warnings):\n                    accuracy_results[scenario_name][f'p={p_value}'].append(accuracy)\n                    rule_percentage_results[scenario_name][f'p={p_value}'].append(rule_percentage)\n                    conciseness_results[scenario_name][f'p={p_value}'].append(conciseness)\n                break\n            \n            print(f'Simulation Iteration {iteration} for {scenario_name} with p={p_value}')\n\n            if p_value == 1:\n                print('Using rules to select positive/negative warnings')\n                # Use the rules to select positive/negative warnings\n                if output:\n                    model = parse_clingo_output(output)\n                    rule_numbers = list(extract_summary_rules(model).keys())\n                    if rule_numbers:\n                        selected_all_pos = get_positive_predictions_of_rule(model, random.choice(rule_numbers))\n                        selected_pos, selected_neg = sample_pos_with_heuristic(selected_all_pos, code_data, warnings_state, apply_heuristics=heuristics)\n\n                        for pos in selected_pos:\n                            warnings_state[pos] = 'positive'\n                        for neg in selected_neg:\n                            warnings_state[neg] = 'negative'\n\n                        # 0.05 probability to mark all matching warnings as positive/negative\n                        if random.random() <= 0.05 and iteration > num_warnings // 2:\n                            for pos in selected_all_pos:\n                                warnings_state[pos] = 'positive'\n\n            elif p_value == 0.5:\n                # 50% chance to use the rules or the original heuristic-based sampling\n                if random.random() < 0.5:\n                    if output:\n                        model = parse_clingo_output(output)\n                        rule_numbers = list(extract_summary_rules(model).keys())\n                        if rule_numbers:\n                            selected_all_pos = get_positive_predictions_of_rule(model, random.choice(rule_numbers))\n                            selected_pos, selected_neg = sample_pos_with_heuristic(selected_all_pos, code_data, warnings_state, apply_heuristics=heuristics)\n\n\n                            for pos in selected_pos:\n                                warnings_state[pos] = 'positive'\n                            for neg in selected_neg:\n                                warnings_state[neg] = 'negative'\n\n                            # 0.05 probability to mark all matching warnings as positive/negative\n                            if random.random() <= 0.05 and iteration > num_warnings // 2:\n                                for pos in selected_all_pos:\n                                    warnings_state[pos] = 'positive'\n                else:\n                    selected_pos, selected_neg = sample_labels_randomized_then_sorted(ground_truth, 1, 1, code_data, warnings_state, apply_heuristics=heuristics)\n                    for pos in selected_pos:\n                        warnings_state[pos] = 'positive'\n                    for neg in selected_neg:\n                        warnings_state[neg] = 'negative'\n            elif p_value == 0:\n                # p=0, just use the original heuristic-based sampling\n                selected_pos, selected_neg = sample_labels_randomized_then_sorted(ground_truth, 1, 1, code_data, warnings_state, apply_heuristics=heuristics)\n                for pos in selected_pos:\n                    warnings_state[pos] = 'positive'\n                for neg in selected_neg:\n                    warnings_state[neg] = 'negative'\n\n            # Write labels to Clingo input and run Clingo\n            pos_labels = [k for k, v in warnings_state.items() if v == 'positive']\n            neg_labels = [k for k, v in warnings_state.items() if v == 'negative']\n\n            print('Positive labels:', pos_labels)\n            print('Negative labels:', neg_labels)\n            write_labels_to_clingo_input(pos_labels, neg_labels)\n            output = run_clingo()\n            #print('Output:', output)\n\n            if output:\n                model = parse_clingo_output(output)\n                inferred_rules = extract_summary_rules(model)\n                percentages = calculate_rule_percentage(model, pos_labels)\n                num_rules_over_threshold = number_of_rules_over_percentage(percentages)\n                num_rules = len(inferred_rules)\n                number_of_positive_predictions = get_number_of_positive_predictions(model)\n\n                if num_rules_over_threshold > 0:\n                    conciseness = number_of_positive_predictions / num_rules_over_threshold\n                else:\n                    conciseness = 0\n\n                # Calculate the percentage of rules over the threshold\n                if num_rules > 0:\n                    rule_percentage = (num_rules_over_threshold / num_rules) * 100\n                else:\n                    rule_percentage = 0\n\n                rule_percentage_results[scenario_name][f'p={p_value}'].append(rule_percentage)\n                conciseness_results[scenario_name][f'p={p_value}'].append(conciseness)\n\n            # Calculate accuracy after each iteration\n            accuracy = calculate_accuracy(warnings_state, ground_truth)\n            accuracy_results[scenario_name][f'p={p_value}'].append(accuracy)\n            print(f'Accuracy after iteration {iteration}: {accuracy:.2f}%')\n            print(f'Percentage of rules over threshold after iteration {iteration}: {rule_percentage:.2f}%')\n            print(f'Conciseness after iteration {iteration}: {conciseness:.2f}')\n\n# Save the results to a csv file\nif scenario_name == 'Heuristic 1 Only':\n    scenario_name = 'h=1'\nelif scenario_name == 'Heuristic 2 Only':\n    scenario_name = 'h=2'\nelif scenario_name == 'Heuristic 3 Only':\n    scenario_name = 'h=3'\nelif scenario_name == 'All Heuristics':\n    scenario_name = 'h=4'\n\nif warning_type == 'apache_lucene-solr__NULL_':\n    warning_type = 'apache_lucene_' + scenario_name\nelif warning_type == 'NULL_DEREFERENCE__nacos':\n    warning_type = 'alibaba_nacos_' + scenario_name\nelif warning_type == 'RESOURCE_LEAK__presto':\n    warning_type = 'presto_' + scenario_name\nelif warning_type == 'dubbo_external':\n    warning_type = 'apache_dubbo_' + scenario_name\n\nwith open(warning_type + '.csv', 'w') as f:\n    f.write('Scenario,Probability,Iteration,Accuracy,Rule Percentage,Conciseness\\n')\n    for scenario_name, p_results in accuracy_results.items():\n        for p_value, accuracy_list in p_results.items():\n            rule_percentage_list = rule_percentage_results[scenario_name][p_value]\n            conciseness_list = conciseness_results[scenario_name][p_value]\n            for i in range(len(accuracy_list)):\n                if i < len(rule_percentage_list) and i < len(conciseness_list):\n                    f.write(f'{scenario_name},{p_value},{i},{accuracy_list[i]},{rule_percentage_list[i]},{conciseness_list[i]}\\n')\n                else:\n                    f.write(f'{scenario_name},{p_value},{i},{accuracy_list[i]},0,0\\n')"],time:'2024-09-08T07:39:32.641Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['509','0','536','86','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:32.641Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['510','0','536','86','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:33.695Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['511','0','536','86','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:33.779Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['510','0','536','86','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:33.795Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['509','0','536','86','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:33.829Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['508','0','536','86','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:33.845Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['506','0','534','130','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:33.862Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['505','0','533','79','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:33.878Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['503','0','531','74','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:33.895Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['501','0','529','56','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:33.928Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['500','0','528','61','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:33.945Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['498','0','526','43','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:33.961Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['496','0','524','50','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:33.978Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['495','0','523','38','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:33.995Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['493','0','521','45','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:34.012Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['491','0','519','47','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:34.028Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['490','0','518','51','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:34.045Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['488','0','516','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:34.062Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['487','0','515','25','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:34.078Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['485','0','513','25','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:34.095Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['484','0','512','41','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:34.162Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['482','0','510','41','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:34.178Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['477','0','505','80','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:34.195Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['472','0','500','53','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:34.212Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['467','0','495','39','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:34.228Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['463','0','491','70','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:34.245Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['457','0','485','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:34.262Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['450','0','478','22','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:34.278Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['442','0','470','82','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:34.294Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['435','0','463','40','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:34.312Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['429','0','457','56','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:34.328Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['422','0','450','97','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:34.345Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['416','0','444','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:34.362Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['410','0','438','59','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:34.381Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['404','0','432','64','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:34.399Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['403','0','431','56','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:34.463Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['402','0','430','85','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:34.483Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['398','0','426','48','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:34.495Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['385','0','413','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:34.512Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['368','0','396','78','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:34.528Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['357','0','385','64','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:34.545Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['339','0','367','29','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:34.562Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['322','0','350','59','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:34.577Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['307','0','335','50','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:34.595Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['292','0','320','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:34.612Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['279','0','307','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:34.628Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['266','0','294','29','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:34.645Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['255','0','283','54','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:34.662Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['244','0','272','32','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:34.678Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['234','0','262','56','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:34.695Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['224','0','252','41','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:34.712Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['214','0','242','107','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:34.728Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['205','0','233','59','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:34.745Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['196','0','224','5','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:34.762Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['188','0','216','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:34.778Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['187','0','215','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:34.828Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['186','0','214','4','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:34.845Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['181','0','209','66','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:34.878Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['169','0','197','55','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:34.895Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['156','0','184','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:34.912Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['148','0','176','28','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:34.928Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['134','0','162','37','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:34.945Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['120','0','148','41','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:34.962Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['107','0','135','66','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:34.978Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['95','0','123','55','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:34.995Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['83','0','111','169','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:35.012Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['72','0','100','79','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:35.028Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['62','0','90','139','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:35.046Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['53','0','81','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:35.062Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['44','0','72','125','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:35.078Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['35','0','63','54','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:35.094Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['27','0','55','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:35.112Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['19','0','47','66','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:35.128Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['12','0','40','68','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:35.144Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['4','0','32','58','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:35.162Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['0','0','27','22','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:35.178Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['0','0','28','35','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:35.612Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['2','0','30','35','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:35.629Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['5','0','33','20','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:35.662Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['8','0','36','37','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:35.678Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['11','0','39','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:35.695Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['13','0','41','40','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:35.712Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['15','0','43','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:35.728Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['16','0','44','62','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:35.745Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['17','0','45','41','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:35.762Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['18','0','46','47','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:35.778Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['19','0','47','66','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:35.812Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['21','0','49','75','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:35.828Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['22','0','50','22','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:35.845Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['23','0','51','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:35.862Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['25','0','53','57','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:35.878Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['26','0','54','47','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:35.895Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['27','0','55','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:35.912Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['28','0','56','46','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:36.028Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['29','0','57','80','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:36.062Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['30','0','58','55','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:36.112Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['42','46','42','46','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',''],time:'2024-09-08T07:39:36.509Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['31','0','59','96','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:36.829Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['32','0','60','92','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:36.879Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['33','0','61','91','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:36.895Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['34','0','62','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:36.928Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['35','0','63','54','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:36.962Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['36','0','64','93','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:36.995Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['37','0','65','24','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:37.028Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['38','0','66','26','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:37.078Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['39','0','67','4','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:37.144Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['40','0','68','34','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:37.195Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['41','0','69','50','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:37.228Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['42','0','70','37','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:37.278Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['43','0','71','54','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:37.312Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['44','0','72','125','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:37.361Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['45','0','73','53','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:37.428Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['46','0','74','35','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:37.528Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['47','0','75','4','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:37.678Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['48','0','76','26','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:39:37.962Z'}]
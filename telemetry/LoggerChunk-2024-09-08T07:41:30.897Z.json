[{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['123','0','151','105','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:41:30.913Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['125','0','153','32','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:41:30.931Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['127','0','155','4','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:41:30.946Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['128','0','156','78','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:41:31.063Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['129','0','157','16','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:41:31.096Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['130','0','158','127','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:41:31.112Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['131','0','159','78','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:41:31.130Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['132','0','160','5','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:41:31.196Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['133','0','161','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:41:31.230Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['144','1','144','1','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',''],time:'2024-09-08T07:41:35.912Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['144','0','144','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',''],time:'2024-09-08T07:41:36.634Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['144','0','144','1','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py','d'],time:'2024-09-08T07:41:36.801Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['144','0','144','4','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py','def '],time:'2024-09-08T07:41:36.825Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['144','0','144','9','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py','def sampl'],time:'2024-09-08T07:41:36.841Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['144','0','145','7','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py','def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    """'],time:'2024-09-08T07:41:36.852Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['144','0','147','28','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py','def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    """\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A li'],time:'2024-09-08T07:41:36.881Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['144','0','147','33','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py','def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    """\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list co'],time:'2024-09-08T07:41:36.898Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['144','0','148','36','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py','def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    """\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code f'],time:'2024-09-08T07:41:36.914Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['144','0','148','38','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py','def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    """\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code fir'],time:'2024-09-08T07:41:36.931Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['144','0','149','41','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py','def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    """\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared '],time:'2024-09-08T07:41:36.948Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['144','0','149','42','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py','def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    """\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared A'],time:'2024-09-08T07:41:36.964Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['144','0','150','43','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py','def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    """\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (conta'],time:'2024-09-08T07:41:36.980Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['144','0','150','44','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py','def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    """\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contai'],time:'2024-09-08T07:41:36.998Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['144','0','151','45','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py','def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    """\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select eithe'],time:'2024-09-08T07:41:37.014Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['144','0','151','46','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py','def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    """\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either'],time:'2024-09-08T07:41:37.029Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['144','0','152','7','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py','def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    """\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    """'],time:'2024-09-08T07:41:37.047Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['144','0','153','32','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py','def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    """\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    """\n    if apply_heuristics is None:'],time:'2024-09-08T07:41:37.063Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['144','0','154','48','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py','def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    """\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    """\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default '],time:'2024-09-08T07:41:37.097Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['144','0','155','4','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py','def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    """\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    """\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    '],time:'2024-09-08T07:41:37.181Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['144','0','156','48','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py','def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    """\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    """\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their li'],time:'2024-09-08T07:41:37.230Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['144','0','157','16','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py','def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    """\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    """\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = ['],time:'2024-09-08T07:41:37.265Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['144','0','158','48','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py','def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    """\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    """\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get(\'lines'],time:'2024-09-08T07:41:37.280Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['144','0','159','48','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py','def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    """\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    """\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get(\'linesOfCode\', 0), code_data.get(int(k), {}).get(\'functionCalls\', []), \'uninspected\')\n        for k, v in ground_truth.items() if warn'],time:'2024-09-08T07:41:37.297Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['144','0','160','5','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]"],time:'2024-09-08T07:41:37.330Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['144','0','161','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n"],time:'2024-09-08T07:41:37.580Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['144','0','162','37','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample"],time:'2024-09-08T07:41:37.663Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['134','0','162','37','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:41:37.664Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['144','0','163','28','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)"],time:'2024-09-08T07:41:37.836Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['135','0','163','28','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:41:37.847Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['144','0','164','61','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]"],time:'2024-09-08T07:41:37.852Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['144','0','164','48','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sam"],time:'2024-09-08T07:41:37.866Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['136','0','164','61','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:41:37.880Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['144','0','165','4','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    "],time:'2024-09-08T07:41:37.884Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['137','0','165','4','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:41:37.897Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['144','0','166','79','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists"],time:'2024-09-08T07:41:37.901Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['138','0','166','79','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:41:37.916Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['144','0','167','21','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []"],time:'2024-09-08T07:41:37.921Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['139','0','167','21','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:41:37.933Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['144','0','168','4','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    "],time:'2024-09-08T07:41:37.939Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['140','0','168','4','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:41:37.948Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['144','0','169','45','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order"],time:'2024-09-08T07:41:37.955Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['141','0','169','45','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:41:37.970Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['144','0','170','36','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()"],time:'2024-09-08T07:41:37.973Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['142','0','170','36','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:41:37.981Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['143','0','171','38','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:41:37.997Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['144','0','171','38','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:"],time:'2024-09-08T07:41:38.001Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['144','0','172','26','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:41:38.014Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['144','0','173','61','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)"],time:'2024-09-08T07:41:38.019Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['145','0','173','61','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:41:38.038Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['144','0','174','28','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:"],time:'2024-09-08T07:41:38.042Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['146','0','174','28','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:41:38.050Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['144','0','175','64','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)"],time:'2024-09-08T07:41:38.054Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['147','0','175','64','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:41:38.066Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['144','0','176','28','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:"],time:'2024-09-08T07:41:38.069Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['148','0','176','28','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:41:38.080Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['144','0','177','72','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)"],time:'2024-09-08T07:41:38.083Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['149','0','177','72','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:41:38.096Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['144','0','178','28','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:"],time:'2024-09-08T07:41:38.100Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['150','0','178','28','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:41:38.113Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['144','0','179','39','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic"],time:'2024-09-08T07:41:38.117Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['151','0','179','39','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:41:38.130Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['144','0','180','172','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])"],time:'2024-09-08T07:41:38.133Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['152','0','180','172','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:41:38.146Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['144','0','181','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n"],time:'2024-09-08T07:41:38.149Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['153','0','181','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:41:38.163Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['144','0','182','67','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings"],time:'2024-09-08T07:41:38.167Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['154','0','182','67','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:41:38.180Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['144','0','183','68','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])"],time:'2024-09-08T07:41:38.183Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['155','0','183','68','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:41:38.196Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['144','0','184','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n"],time:'2024-09-08T07:41:38.199Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['156','0','184','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:41:38.213Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['144','0','185','169','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning"],time:'2024-09-08T07:41:38.216Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['157','0','185','169','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:41:38.230Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['144','0','186','34','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):"],time:'2024-09-08T07:41:38.233Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['158','0','186','34','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:41:38.246Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['144','0','187','88','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:"],time:'2024-09-08T07:41:38.250Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['159','0','187','88','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:41:38.264Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['144','0','188','43','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])"],time:'2024-09-08T07:41:38.271Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['160','0','188','43','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:41:38.280Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['144','0','189','39','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'"],time:'2024-09-08T07:41:38.283Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['161','0','189','39','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:41:38.296Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['144','0','190','44','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])"],time:'2024-09-08T07:41:38.300Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['162','0','190','44','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:41:38.313Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['144','0','191','13','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:"],time:'2024-09-08T07:41:38.316Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['163','0','191','13','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:41:38.330Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['144','0','192','43','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])"],time:'2024-09-08T07:41:38.333Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['164','0','192','43','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:41:38.346Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['144','0','193','39','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'"],time:'2024-09-08T07:41:38.349Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['165','0','193','39','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:41:38.363Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['144','0','194','47','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])   "],time:'2024-09-08T07:41:38.366Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['166','0','194','48','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:41:38.380Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['144','0','195','4','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    "],time:'2024-09-08T07:41:38.383Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['167','0','195','4','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:41:38.396Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['144','0','196','47','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a pos"],time:'2024-09-08T07:41:38.399Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['168','0','196','72','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:41:38.413Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['144','0','197','47','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'neg"],time:'2024-09-08T07:41:38.416Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['169','0','197','55','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:41:38.430Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['144','0','198','4','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    "],time:'2024-09-08T07:41:38.432Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['171','0','199','31','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:41:38.446Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['144','0','199','31','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':"],time:'2024-09-08T07:41:38.450Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['172','0','200','50','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:41:38.463Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['144','0','201','53','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]"],time:'2024-09-08T07:41:38.466Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['173','0','201','53','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:41:38.480Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['144','0','202','39','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []"],time:'2024-09-08T07:41:38.483Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['174','0','202','39','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:41:38.496Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['144','0','203','66','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'"],time:'2024-09-08T07:41:38.499Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['175','0','203','66','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:41:38.513Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['144','0','204','53','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')"],time:'2024-09-08T07:41:38.516Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['176','0','204','53','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:41:38.530Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['144','0','205','9','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:"],time:'2024-09-08T07:41:38.533Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['177','0','205','9','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:41:38.546Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['144','0','206','49','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative"],time:'2024-09-08T07:41:38.549Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['178','0','206','49','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:41:38.563Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['144','0','207','39','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []"],time:'2024-09-08T07:41:38.566Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['179','0','207','39','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:41:38.580Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['144','0','208','54','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]"],time:'2024-09-08T07:41:38.583Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['180','0','208','54','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:41:38.596Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['144','0','209','66','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'"],time:'2024-09-08T07:41:38.600Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['181','0','209','66','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:41:38.613Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['144','0','210','53','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')"],time:'2024-09-08T07:41:38.616Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['182','0','210','53','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:41:38.630Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['144','0','211','4','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    "],time:'2024-09-08T07:41:38.633Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['183','0','211','4','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:41:38.646Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['144','0','212','67','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)"],time:'2024-09-08T07:41:38.649Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['184','0','212','67','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:41:38.663Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['144','0','213','67','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)"],time:'2024-09-08T07:41:38.666Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['185','0','213','67','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:41:38.680Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['144','0','214','4','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    "],time:'2024-09-08T07:41:38.683Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['186','0','214','4','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:41:38.696Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['144','0','215','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings"],time:'2024-09-08T07:41:38.699Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['187','0','215','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:41:38.713Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['144','0','216','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings\n"],time:'2024-09-08T07:41:38.716Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['188','0','216','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:41:38.729Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['144','0','217','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings\n\n"],time:'2024-09-08T07:41:38.733Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['189','0','217','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:41:38.746Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['144','0','218','17','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings\n\n\ndef run_clingo():"],time:'2024-09-08T07:41:38.749Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['190','0','218','17','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:41:38.763Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['144','0','219','13','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings\n\n\ndef run_clingo():\n    files = ["],time:'2024-09-08T07:41:38.766Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['191','0','219','13','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:41:38.779Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['144','0','220','37','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings\n\n\ndef run_clingo():\n    files = [\n        f'lp/simulation_labels.lp',  "],time:'2024-09-08T07:41:38.783Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['192','0','220','37','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:41:38.797Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['144','0','221','41','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings\n\n\ndef run_clingo():\n    files = [\n        f'lp/simulation_labels.lp',  \n        'lp/background.lp',              "],time:'2024-09-08T07:41:38.799Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['193','0','221','41','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:41:38.813Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['144','0','222','41','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings\n\n\ndef run_clingo():\n    files = [\n        f'lp/simulation_labels.lp',  \n        'lp/background.lp',              \n        'lp/frozen_rules.lp',            "],time:'2024-09-08T07:41:38.816Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['194','0','222','41','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:41:38.830Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['144','0','223','41','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings\n\n\ndef run_clingo():\n    files = [\n        f'lp/simulation_labels.lp',  \n        'lp/background.lp',              \n        'lp/frozen_rules.lp',            \n        'lp/rules2.lp'                   "],time:'2024-09-08T07:41:38.833Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['195','0','223','41','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:41:38.847Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['144','0','224','5','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings\n\n\ndef run_clingo():\n    files = [\n        f'lp/simulation_labels.lp',  \n        'lp/background.lp',              \n        'lp/frozen_rules.lp',            \n        'lp/rules2.lp'                   \n    ]"],time:'2024-09-08T07:41:38.850Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['196','0','224','5','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:41:38.863Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['144','0','225','4','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings\n\n\ndef run_clingo():\n    files = [\n        f'lp/simulation_labels.lp',  \n        'lp/background.lp',              \n        'lp/frozen_rules.lp',            \n        'lp/rules2.lp'                   \n    ]\n    "],time:'2024-09-08T07:41:38.866Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['197','0','225','4','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:41:38.880Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['144','0','226','70','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings\n\n\ndef run_clingo():\n    files = [\n        f'lp/simulation_labels.lp',  \n        'lp/background.lp',              \n        'lp/frozen_rules.lp',            \n        'lp/rules2.lp'                   \n    ]\n    \n    command = ['clingo'] + files + ['--outf=2'] + ['--time-limit=30'] "],time:'2024-09-08T07:41:38.883Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['144','0','226','47','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings\n\n\ndef run_clingo():\n    files = [\n        f'lp/simulation_labels.lp',  \n        'lp/background.lp',              \n        'lp/frozen_rules.lp',            \n        'lp/rules2.lp'                   \n    ]\n    \n    command = ['clingo'] + files + ['--outf=2']"],time:'2024-09-08T07:41:38.899Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['144','0','226','70','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings\n\n\ndef run_clingo():\n    files = [\n        f'lp/simulation_labels.lp',  \n        'lp/background.lp',              \n        'lp/frozen_rules.lp',            \n        'lp/rules2.lp'                   \n    ]\n    \n    command = ['clingo'] + files + ['--outf=2'] + ['--time-limit=30'] "],time:'2024-09-08T07:41:38.913Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['198','0','226','70','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:41:38.913Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['144','0','226','48','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings\n\n\ndef run_clingo():\n    files = [\n        f'lp/simulation_labels.lp',  \n        'lp/background.lp',              \n        'lp/frozen_rules.lp',            \n        'lp/rules2.lp'                   \n    ]\n    \n    command = ['clingo'] + files + ['--outf=2'] "],time:'2024-09-08T07:41:39.348Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['144','0','226','70','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings\n\n\ndef run_clingo():\n    files = [\n        f'lp/simulation_labels.lp',  \n        'lp/background.lp',              \n        'lp/frozen_rules.lp',            \n        'lp/rules2.lp'                   \n    ]\n    \n    command = ['clingo'] + files + ['--outf=2'] + ['--time-limit=30'] "],time:'2024-09-08T07:41:39.443Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['144','0','226','48','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings\n\n\ndef run_clingo():\n    files = [\n        f'lp/simulation_labels.lp',  \n        'lp/background.lp',              \n        'lp/frozen_rules.lp',            \n        'lp/rules2.lp'                   \n    ]\n    \n    command = ['clingo'] + files + ['--outf=2'] "],time:'2024-09-08T07:41:39.615Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['144','0','227','28','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings\n\n\ndef run_clingo():\n    files = [\n        f'lp/simulation_labels.lp',  \n        'lp/background.lp',              \n        'lp/frozen_rules.lp',            \n        'lp/rules2.lp'                   \n    ]\n    \n    command = ['clingo'] + files + ['--outf=2'] + ['--time-limit=30'] \n    print(' '.join(command))"],time:'2024-09-08T07:41:39.634Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['199','0','227','28','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:41:39.663Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['144','0','228','68','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings\n\n\ndef run_clingo():\n    files = [\n        f'lp/simulation_labels.lp',  \n        'lp/background.lp',              \n        'lp/frozen_rules.lp',            \n        'lp/rules2.lp'                   \n    ]\n    \n    command = ['clingo'] + files + ['--outf=2'] + ['--time-limit=30'] \n    print(' '.join(command))\n    result = subprocess.run(command, capture_output=True, text=True)"],time:'2024-09-08T07:41:39.667Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['144','0','228','48','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings\n\n\ndef run_clingo():\n    files = [\n        f'lp/simulation_labels.lp',  \n        'lp/background.lp',              \n        'lp/frozen_rules.lp',            \n        'lp/rules2.lp'                   \n    ]\n    \n    command = ['clingo'] + files + ['--outf=2'] + ['--time-limit=30'] \n    print(' '.join(command))\n    result = subprocess.run(command, capture_out"],time:'2024-09-08T07:41:39.682Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['200','0','228','68','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:41:39.696Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['144','0','229','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings\n\n\ndef run_clingo():\n    files = [\n        f'lp/simulation_labels.lp',  \n        'lp/background.lp',              \n        'lp/frozen_rules.lp',            \n        'lp/rules2.lp'                   \n    ]\n    \n    command = ['clingo'] + files + ['--outf=2'] + ['--time-limit=30'] \n    print(' '.join(command))\n    result = subprocess.run(command, capture_output=True, text=True)\n"],time:'2024-09-08T07:41:39.699Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['201','0','229','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:41:39.714Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['144','0','230','24','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings\n\n\ndef run_clingo():\n    files = [\n        f'lp/simulation_labels.lp',  \n        'lp/background.lp',              \n        'lp/frozen_rules.lp',            \n        'lp/rules2.lp'                   \n    ]\n    \n    command = ['clingo'] + files + ['--outf=2'] + ['--time-limit=30'] \n    print(' '.join(command))\n    result = subprocess.run(command, capture_output=True, text=True)\n\n    return result.stdout"],time:'2024-09-08T07:41:39.733Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['202','0','230','24','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:41:39.746Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['144','0','231','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings\n\n\ndef run_clingo():\n    files = [\n        f'lp/simulation_labels.lp',  \n        'lp/background.lp',              \n        'lp/frozen_rules.lp',            \n        'lp/rules2.lp'                   \n    ]\n    \n    command = ['clingo'] + files + ['--outf=2'] + ['--time-limit=30'] \n    print(' '.join(command))\n    result = subprocess.run(command, capture_output=True, text=True)\n\n    return result.stdout\n"],time:'2024-09-08T07:41:39.766Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['203','0','231','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:41:39.779Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['144','0','232','30','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings\n\n\ndef run_clingo():\n    files = [\n        f'lp/simulation_labels.lp',  \n        'lp/background.lp',              \n        'lp/frozen_rules.lp',            \n        'lp/rules2.lp'                   \n    ]\n    \n    command = ['clingo'] + files + ['--outf=2'] + ['--time-limit=30'] \n    print(' '.join(command))\n    result = subprocess.run(command, capture_output=True, text=True)\n\n    return result.stdout\n\ndef parse_clingo_output(data):"],time:'2024-09-08T07:41:39.782Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['204','0','232','30','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:41:39.813Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['144','0','233','59','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings\n\n\ndef run_clingo():\n    files = [\n        f'lp/simulation_labels.lp',  \n        'lp/background.lp',              \n        'lp/frozen_rules.lp',            \n        'lp/rules2.lp'                   \n    ]\n    \n    command = ['clingo'] + files + ['--outf=2'] + ['--time-limit=30'] \n    print(' '.join(command))\n    result = subprocess.run(command, capture_output=True, text=True)\n\n    return result.stdout\n\ndef parse_clingo_output(data):\n    # Load the data using json.loads if 'data' is a string,"],time:'2024-09-08T07:41:39.816Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['144','0','233','48','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings\n\n\ndef run_clingo():\n    files = [\n        f'lp/simulation_labels.lp',  \n        'lp/background.lp',              \n        'lp/frozen_rules.lp',            \n        'lp/rules2.lp'                   \n    ]\n    \n    command = ['clingo'] + files + ['--outf=2'] + ['--time-limit=30'] \n    print(' '.join(command))\n    result = subprocess.run(command, capture_output=True, text=True)\n\n    return result.stdout\n\ndef parse_clingo_output(data):\n    # Load the data using json.loads if 'data' i"],time:'2024-09-08T07:41:39.832Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['205','0','233','59','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:41:39.846Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['144','0','234','48','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings\n\n\ndef run_clingo():\n    files = [\n        f'lp/simulation_labels.lp',  \n        'lp/background.lp',              \n        'lp/frozen_rules.lp',            \n        'lp/rules2.lp'                   \n    ]\n    \n    command = ['clingo'] + files + ['--outf=2'] + ['--time-limit=30'] \n    print(' '.join(command))\n    result = subprocess.run(command, capture_output=True, text=True)\n\n    return result.stdout\n\ndef parse_clingo_output(data):\n    # Load the data using json.loads if 'data' is a string,\n    # otherwise assume it's already a dictionary"],time:'2024-09-08T07:41:39.849Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['206','0','234','48','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:41:39.880Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['144','0','235','29','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings\n\n\ndef run_clingo():\n    files = [\n        f'lp/simulation_labels.lp',  \n        'lp/background.lp',              \n        'lp/frozen_rules.lp',            \n        'lp/rules2.lp'                   \n    ]\n    \n    command = ['clingo'] + files + ['--outf=2'] + ['--time-limit=30'] \n    print(' '.join(command))\n    result = subprocess.run(command, capture_output=True, text=True)\n\n    return result.stdout\n\ndef parse_clingo_output(data):\n    # Load the data using json.loads if 'data' is a string,\n    # otherwise assume it's already a dictionary\n    if isinstance(data, str):"],time:'2024-09-08T07:41:39.883Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['144','0','234','47','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings\n\n\ndef run_clingo():\n    files = [\n        f'lp/simulation_labels.lp',  \n        'lp/background.lp',              \n        'lp/frozen_rules.lp',            \n        'lp/rules2.lp'                   \n    ]\n    \n    command = ['clingo'] + files + ['--outf=2'] + ['--time-limit=30'] \n    print(' '.join(command))\n    result = subprocess.run(command, capture_output=True, text=True)\n\n    return result.stdout\n\ndef parse_clingo_output(data):\n    # Load the data using json.loads if 'data' is a string,\n    # otherwise assume it's already a dictionar"],time:'2024-09-08T07:41:39.914Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['144','0','233','47','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings\n\n\ndef run_clingo():\n    files = [\n        f'lp/simulation_labels.lp',  \n        'lp/background.lp',              \n        'lp/frozen_rules.lp',            \n        'lp/rules2.lp'                   \n    ]\n    \n    command = ['clingo'] + files + ['--outf=2'] + ['--time-limit=30'] \n    print(' '.join(command))\n    result = subprocess.run(command, capture_output=True, text=True)\n\n    return result.stdout\n\ndef parse_clingo_output(data):\n    # Load the data using json.loads if 'data' "],time:'2024-09-08T07:41:39.947Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['144','0','232','30','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings\n\n\ndef run_clingo():\n    files = [\n        f'lp/simulation_labels.lp',  \n        'lp/background.lp',              \n        'lp/frozen_rules.lp',            \n        'lp/rules2.lp'                   \n    ]\n    \n    command = ['clingo'] + files + ['--outf=2'] + ['--time-limit=30'] \n    print(' '.join(command))\n    result = subprocess.run(command, capture_output=True, text=True)\n\n    return result.stdout\n\ndef parse_clingo_output(data):"],time:'2024-09-08T07:41:39.963Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['144','0','230','24','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings\n\n\ndef run_clingo():\n    files = [\n        f'lp/simulation_labels.lp',  \n        'lp/background.lp',              \n        'lp/frozen_rules.lp',            \n        'lp/rules2.lp'                   \n    ]\n    \n    command = ['clingo'] + files + ['--outf=2'] + ['--time-limit=30'] \n    print(' '.join(command))\n    result = subprocess.run(command, capture_output=True, text=True)\n\n    return result.stdout"],time:'2024-09-08T07:41:39.980Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['144','0','229','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings\n\n\ndef run_clingo():\n    files = [\n        f'lp/simulation_labels.lp',  \n        'lp/background.lp',              \n        'lp/frozen_rules.lp',            \n        'lp/rules2.lp'                   \n    ]\n    \n    command = ['clingo'] + files + ['--outf=2'] + ['--time-limit=30'] \n    print(' '.join(command))\n    result = subprocess.run(command, capture_output=True, text=True)\n"],time:'2024-09-08T07:41:39.997Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['144','0','228','47','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings\n\n\ndef run_clingo():\n    files = [\n        f'lp/simulation_labels.lp',  \n        'lp/background.lp',              \n        'lp/frozen_rules.lp',            \n        'lp/rules2.lp'                   \n    ]\n    \n    command = ['clingo'] + files + ['--outf=2'] + ['--time-limit=30'] \n    print(' '.join(command))\n    result = subprocess.run(command, capture_ou"],time:'2024-09-08T07:41:40.014Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['144','0','226','48','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings\n\n\ndef run_clingo():\n    files = [\n        f'lp/simulation_labels.lp',  \n        'lp/background.lp',              \n        'lp/frozen_rules.lp',            \n        'lp/rules2.lp'                   \n    ]\n    \n    command = ['clingo'] + files + ['--outf=2'] "],time:'2024-09-08T07:41:40.030Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['144','0','224','5','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings\n\n\ndef run_clingo():\n    files = [\n        f'lp/simulation_labels.lp',  \n        'lp/background.lp',              \n        'lp/frozen_rules.lp',            \n        'lp/rules2.lp'                   \n    ]"],time:'2024-09-08T07:41:40.047Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['144','0','223','41','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings\n\n\ndef run_clingo():\n    files = [\n        f'lp/simulation_labels.lp',  \n        'lp/background.lp',              \n        'lp/frozen_rules.lp',            \n        'lp/rules2.lp'                   "],time:'2024-09-08T07:41:40.064Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['144','0','221','41','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings\n\n\ndef run_clingo():\n    files = [\n        f'lp/simulation_labels.lp',  \n        'lp/background.lp',              "],time:'2024-09-08T07:41:40.080Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['144','0','220','37','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings\n\n\ndef run_clingo():\n    files = [\n        f'lp/simulation_labels.lp',  "],time:'2024-09-08T07:41:40.113Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['144','0','219','13','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings\n\n\ndef run_clingo():\n    files = ["],time:'2024-09-08T07:41:40.130Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['144','0','218','17','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings\n\n\ndef run_clingo():"],time:'2024-09-08T07:41:40.163Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['144','0','217','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings\n\n"],time:'2024-09-08T07:41:40.180Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['144','0','216','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings\n"],time:'2024-09-08T07:41:40.213Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['144','0','215','57','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_"],time:'2024-09-08T07:41:40.263Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['144','0','215','59','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_wa"],time:'2024-09-08T07:41:40.280Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['144','0','215','60','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_war"],time:'2024-09-08T07:41:40.297Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['144','0','215','62','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warni"],time:'2024-09-08T07:41:40.313Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['144','0','214','4','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    "],time:'2024-09-08T07:41:40.330Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['144','0','215','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n    \n    # Get all uninspected warnings with their lines of code and function calls\n    warnings = [\n        (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n        for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n    ]\n\n    # shuffle the warnings and sample\n    random.shuffle(warnings)\n    warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), heuristic_shared_function_calls(warnings), heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # if a given warning in warnings are in the first half of the sorted list sorted_warnings_by_length, then it is a positive warning otherwise it is a negative warning\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n        #print('Coin toss result: Positive selected')\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n        #print('Coin toss result: Negative selected')\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings"],time:'2024-09-08T07:41:40.447Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['205','0','233','59','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-08T07:45:23.649Z'}]
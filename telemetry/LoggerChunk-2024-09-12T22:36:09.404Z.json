[{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['112','0','112','1','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py','d'],time:'2024-09-12T22:36:09.515Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['112','0','113','1','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py','def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5, warning_ids=None):\n '],time:'2024-09-12T22:36:09.536Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['112','0','113','2','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py','def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5, warning_ids=None):\n  '],time:'2024-09-12T22:36:09.549Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['112','0','113','3','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py','def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5, warning_ids=None):\n   '],time:'2024-09-12T22:36:09.563Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['112','0','114','4','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py','def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5, warning_ids=None):\n    """\n    '],time:'2024-09-12T22:36:09.579Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['112','0','114','5','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py','def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5, warning_ids=None):\n    """\n    A'],time:'2024-09-12T22:36:09.596Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['112','0','115','5','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py','def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5, warning_ids=None):\n    """\n    Apply specified heuristics to the warnings before sampling:\n    -'],time:'2024-09-12T22:36:09.612Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['112','0','115','6','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py','def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5, warning_ids=None):\n    """\n    Apply specified heuristics to the warnings before sampling:\n    - '],time:'2024-09-12T22:36:09.645Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['112','0','116','6','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py','def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5, warning_ids=None):\n    """\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n      '],time:'2024-09-12T22:36:09.661Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['112','0','117','6','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py','def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5, warning_ids=None):\n    """\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n      '],time:'2024-09-12T22:36:09.679Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['112','0','118','6','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py','def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5, warning_ids=None):\n    """\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n      '],time:'2024-09-12T22:36:09.712Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['112','0','120','6','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py','def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5, warning_ids=None):\n    """\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - If warning_ids is provided, apply the heuristics to only those warnings.\n    - '],time:'2024-09-12T22:36:09.728Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['112','0','123','8','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py','def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5, warning_ids=None):\n    """\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - If warning_ids is provided, apply the heuristics to only those warnings.\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    """\n    if apply_heuristics is None:\n        '],time:'2024-09-12T22:36:09.745Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['112','0','127','8','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py','def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5, warning_ids=None):\n    """\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - If warning_ids is provided, apply the heuristics to only those warnings.\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    """\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n\n    # Determine which warnings to operate on: either from ground_truth or passed warning_ids\n    if warning_ids:\n        '],time:'2024-09-12T22:36:09.764Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['112','0','129','8','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py','def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5, warning_ids=None):\n    """\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - If warning_ids is provided, apply the heuristics to only those warnings.\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    """\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n\n    # Determine which warnings to operate on: either from ground_truth or passed warning_ids\n    if warning_ids:\n        warnings = [\n            (k, code_data.get(int(k), {}).get(\'linesOfCode\', 0), code_data.get(int(k), {}).get(\'functionCalls\', []), \'uninspected\')\n        '],time:'2024-09-12T22:36:09.778Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['112','0','131','8','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5, warning_ids=None):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - If warning_ids is provided, apply the heuristics to only those warnings.\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n\n    # Determine which warnings to operate on: either from ground_truth or passed warning_ids\n    if warning_ids:\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k in warning_ids if warnings_state.get(k) == 'uninspected'\n        ]\n        "],time:'2024-09-12T22:36:09.795Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['112','0','133','9','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5, warning_ids=None):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - If warning_ids is provided, apply the heuristics to only those warnings.\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n\n    # Determine which warnings to operate on: either from ground_truth or passed warning_ids\n    if warning_ids:\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k in warning_ids if warnings_state.get(k) == 'uninspected'\n        ]\n        #here print(warning_ids)\n        #here print(' warnings:', warnings)\n    else:"],time:'2024-09-12T22:36:09.828Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['112','0','134','10','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5, warning_ids=None):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - If warning_ids is provided, apply the heuristics to only those warnings.\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n\n    # Determine which warnings to operate on: either from ground_truth or passed warning_ids\n    if warning_ids:\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k in warning_ids if warnings_state.get(k) == 'uninspected'\n        ]\n        #here print(warning_ids)\n        #here print(' warnings:', warnings)\n    else:\n        # "],time:'2024-09-12T22:36:09.862Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['112','0','136','10','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5, warning_ids=None):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - If warning_ids is provided, apply the heuristics to only those warnings.\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n\n    # Determine which warnings to operate on: either from ground_truth or passed warning_ids\n    if warning_ids:\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k in warning_ids if warnings_state.get(k) == 'uninspected'\n        ]\n        #here print(warning_ids)\n        #here print(' warnings:', warnings)\n    else:\n        # Get all uninspected warnings with their lines of code and function calls\n        warnings = [\n          "],time:'2024-09-12T22:36:09.880Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['112','0','137','10','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5, warning_ids=None):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - If warning_ids is provided, apply the heuristics to only those warnings.\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n\n    # Determine which warnings to operate on: either from ground_truth or passed warning_ids\n    if warning_ids:\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k in warning_ids if warnings_state.get(k) == 'uninspected'\n        ]\n        #here print(warning_ids)\n        #here print(' warnings:', warnings)\n    else:\n        # Get all uninspected warnings with their lines of code and function calls\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n          "],time:'2024-09-12T22:36:09.898Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['112','0','138','9','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5, warning_ids=None):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - If warning_ids is provided, apply the heuristics to only those warnings.\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n\n    # Determine which warnings to operate on: either from ground_truth or passed warning_ids\n    if warning_ids:\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k in warning_ids if warnings_state.get(k) == 'uninspected'\n        ]\n        #here print(warning_ids)\n        #here print(' warnings:', warnings)\n    else:\n        # Get all uninspected warnings with their lines of code and function calls\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n        ]"],time:'2024-09-12T22:36:09.921Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['112','0','139','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5, warning_ids=None):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - If warning_ids is provided, apply the heuristics to only those warnings.\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n\n    # Determine which warnings to operate on: either from ground_truth or passed warning_ids\n    if warning_ids:\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k in warning_ids if warnings_state.get(k) == 'uninspected'\n        ]\n        #here print(warning_ids)\n        #here print(' warnings:', warnings)\n    else:\n        # Get all uninspected warnings with their lines of code and function calls\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n        ]\n"],time:'2024-09-12T22:36:09.946Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['112','0','140','10','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5, warning_ids=None):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - If warning_ids is provided, apply the heuristics to only those warnings.\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n\n    # Determine which warnings to operate on: either from ground_truth or passed warning_ids\n    if warning_ids:\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k in warning_ids if warnings_state.get(k) == 'uninspected'\n        ]\n        #here print(warning_ids)\n        #here print(' warnings:', warnings)\n    else:\n        # Get all uninspected warnings with their lines of code and function calls\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n        ]\n\n    # Shuf"],time:'2024-09-12T22:36:09.971Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['112','0','141','10','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5, warning_ids=None):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - If warning_ids is provided, apply the heuristics to only those warnings.\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n\n    # Determine which warnings to operate on: either from ground_truth or passed warning_ids\n    if warning_ids:\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k in warning_ids if warnings_state.get(k) == 'uninspected'\n        ]\n        #here print(warning_ids)\n        #here print(' warnings:', warnings)\n    else:\n        # Get all uninspected warnings with their lines of code and function calls\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n        ]\n\n    # Shuffle the warnings and sample based on the sampling ratio\n    random"],time:'2024-09-12T22:36:09.994Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['112','0','142','9','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5, warning_ids=None):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - If warning_ids is provided, apply the heuristics to only those warnings.\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n\n    # Determine which warnings to operate on: either from ground_truth or passed warning_ids\n    if warning_ids:\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k in warning_ids if warnings_state.get(k) == 'uninspected'\n        ]\n        #here print(warning_ids)\n        #here print(' warnings:', warnings)\n    else:\n        # Get all uninspected warnings with their lines of code and function calls\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n        ]\n\n    # Shuffle the warnings and sample based on the sampling ratio\n    random.shuffle(warnings)\n    if le"],time:'2024-09-12T22:36:10.044Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['101','0','142','25','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-12T22:36:10.045Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['112','0','142','25','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5, warning_ids=None):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - If warning_ids is provided, apply the heuristics to only those warnings.\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n\n    # Determine which warnings to operate on: either from ground_truth or passed warning_ids\n    if warning_ids:\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k in warning_ids if warnings_state.get(k) == 'uninspected'\n        ]\n        #here print(warning_ids)\n        #here print(' warnings:', warnings)\n    else:\n        # Get all uninspected warnings with their lines of code and function calls\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n        ]\n\n    # Shuffle the warnings and sample based on the sampling ratio\n    random.shuffle(warnings)\n    if len(warnings) > 1:"],time:'2024-09-12T22:36:10.061Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['112','0','142','9','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5, warning_ids=None):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - If warning_ids is provided, apply the heuristics to only those warnings.\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n\n    # Determine which warnings to operate on: either from ground_truth or passed warning_ids\n    if warning_ids:\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k in warning_ids if warnings_state.get(k) == 'uninspected'\n        ]\n        #here print(warning_ids)\n        #here print(' warnings:', warnings)\n    else:\n        # Get all uninspected warnings with their lines of code and function calls\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n        ]\n\n    # Shuffle the warnings and sample based on the sampling ratio\n    random.shuffle(warnings)\n    if le"],time:'2024-09-12T22:36:10.178Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['102','0','142','25','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-12T22:36:10.194Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['112','0','143','9','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5, warning_ids=None):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - If warning_ids is provided, apply the heuristics to only those warnings.\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n\n    # Determine which warnings to operate on: either from ground_truth or passed warning_ids\n    if warning_ids:\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k in warning_ids if warnings_state.get(k) == 'uninspected'\n        ]\n        #here print(warning_ids)\n        #here print(' warnings:', warnings)\n    else:\n        # Get all uninspected warnings with their lines of code and function calls\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n        ]\n\n    # Shuffle the warnings and sample based on the sampling ratio\n    random.shuffle(warnings)\n    if len(warnings) > 1:\n        w"],time:'2024-09-12T22:36:10.199Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['103','0','143','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-12T22:36:10.211Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['112','0','144','4','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5, warning_ids=None):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - If warning_ids is provided, apply the heuristics to only those warnings.\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n\n    # Determine which warnings to operate on: either from ground_truth or passed warning_ids\n    if warning_ids:\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k in warning_ids if warnings_state.get(k) == 'uninspected'\n        ]\n        #here print(warning_ids)\n        #here print(' warnings:', warnings)\n    else:\n        # Get all uninspected warnings with their lines of code and function calls\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n        ]\n\n    # Shuffle the warnings and sample based on the sampling ratio\n    random.shuffle(warnings)\n    if len(warnings) > 1:\n        warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    "],time:'2024-09-12T22:36:10.215Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['103','0','144','4','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-12T22:36:10.227Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['112','0','145','9','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5, warning_ids=None):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - If warning_ids is provided, apply the heuristics to only those warnings.\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n\n    # Determine which warnings to operate on: either from ground_truth or passed warning_ids\n    if warning_ids:\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k in warning_ids if warnings_state.get(k) == 'uninspected'\n        ]\n        #here print(warning_ids)\n        #here print(' warnings:', warnings)\n    else:\n        # Get all uninspected warnings with their lines of code and function calls\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n        ]\n\n    # Shuffle the warnings and sample based on the sampling ratio\n    random.shuffle(warnings)\n    if len(warnings) > 1:\n        warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if no"],time:'2024-09-12T22:36:10.230Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['104','0','145','94','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-12T22:36:10.244Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['112','0','146','9','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5, warning_ids=None):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - If warning_ids is provided, apply the heuristics to only those warnings.\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n\n    # Determine which warnings to operate on: either from ground_truth or passed warning_ids\n    if warning_ids:\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k in warning_ids if warnings_state.get(k) == 'uninspected'\n        ]\n        #here print(warning_ids)\n        #here print(' warnings:', warnings)\n    else:\n        # Get all uninspected warnings with their lines of code and function calls\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n        ]\n\n    # Shuffle the warnings and sample based on the sampling ratio\n    random.shuffle(warnings)\n    if len(warnings) > 1:\n        warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected or none passed, return empty lists\n        r"],time:'2024-09-12T22:36:10.247Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['105','0','146','21','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-12T22:36:10.260Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['112','0','147','4','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5, warning_ids=None):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - If warning_ids is provided, apply the heuristics to only those warnings.\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n\n    # Determine which warnings to operate on: either from ground_truth or passed warning_ids\n    if warning_ids:\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k in warning_ids if warnings_state.get(k) == 'uninspected'\n        ]\n        #here print(warning_ids)\n        #here print(' warnings:', warnings)\n    else:\n        # Get all uninspected warnings with their lines of code and function calls\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n        ]\n\n    # Shuffle the warnings and sample based on the sampling ratio\n    random.shuffle(warnings)\n    if len(warnings) > 1:\n        warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected or none passed, return empty lists\n        return [], []\n    "],time:'2024-09-12T22:36:10.263Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['106','0','147','4','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-12T22:36:10.277Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['112','0','148','9','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5, warning_ids=None):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - If warning_ids is provided, apply the heuristics to only those warnings.\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n\n    # Determine which warnings to operate on: either from ground_truth or passed warning_ids\n    if warning_ids:\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k in warning_ids if warnings_state.get(k) == 'uninspected'\n        ]\n        #here print(warning_ids)\n        #here print(' warnings:', warnings)\n    else:\n        # Get all uninspected warnings with their lines of code and function calls\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n        ]\n\n    # Shuffle the warnings and sample based on the sampling ratio\n    random.shuffle(warnings)\n    if len(warnings) > 1:\n        warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected or none passed, return empty lists\n        return [], []\n    \n    # App"],time:'2024-09-12T22:36:10.280Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['107','0','148','45','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-12T22:36:10.294Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['112','0','149','9','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5, warning_ids=None):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - If warning_ids is provided, apply the heuristics to only those warnings.\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n\n    # Determine which warnings to operate on: either from ground_truth or passed warning_ids\n    if warning_ids:\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k in warning_ids if warnings_state.get(k) == 'uninspected'\n        ]\n        #here print(warning_ids)\n        #here print(' warnings:', warnings)\n    else:\n        # Get all uninspected warnings with their lines of code and function calls\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n        ]\n\n    # Shuffle the warnings and sample based on the sampling ratio\n    random.shuffle(warnings)\n    if len(warnings) > 1:\n        warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected or none passed, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    conta"],time:'2024-09-12T22:36:10.297Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['108','0','149','36','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-12T22:36:10.311Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['112','0','150','9','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5, warning_ids=None):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - If warning_ids is provided, apply the heuristics to only those warnings.\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n\n    # Determine which warnings to operate on: either from ground_truth or passed warning_ids\n    if warning_ids:\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k in warning_ids if warnings_state.get(k) == 'uninspected'\n        ]\n        #here print(warning_ids)\n        #here print(' warnings:', warnings)\n    else:\n        # Get all uninspected warnings with their lines of code and function calls\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n        ]\n\n    # Shuffle the warnings and sample based on the sampling ratio\n    random.shuffle(warnings)\n    if len(warnings) > 1:\n        warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected or none passed, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    #prin"],time:'2024-09-12T22:36:10.314Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['110','0','150','23','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-12T22:36:10.328Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['112','0','151','9','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5, warning_ids=None):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - If warning_ids is provided, apply the heuristics to only those warnings.\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n\n    # Determine which warnings to operate on: either from ground_truth or passed warning_ids\n    if warning_ids:\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k in warning_ids if warnings_state.get(k) == 'uninspected'\n        ]\n        #here print(warning_ids)\n        #here print(' warnings:', warnings)\n    else:\n        # Get all uninspected warnings with their lines of code and function calls\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n        ]\n\n    # Shuffle the warnings and sample based on the sampling ratio\n    random.shuffle(warnings)\n    if len(warnings) > 1:\n        warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected or none passed, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    #print(containment)\n    for h"],time:'2024-09-12T22:36:10.331Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['111','0','152','26','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-12T22:36:10.344Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['112','0','153','61','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5, warning_ids=None):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - If warning_ids is provided, apply the heuristics to only those warnings.\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n\n    # Determine which warnings to operate on: either from ground_truth or passed warning_ids\n    if warning_ids:\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k in warning_ids if warnings_state.get(k) == 'uninspected'\n        ]\n        #here print(warning_ids)\n        #here print(' warnings:', warnings)\n    else:\n        # Get all uninspected warnings with their lines of code and function calls\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n        ]\n\n    # Shuffle the warnings and sample based on the sampling ratio\n    random.shuffle(warnings)\n    if len(warnings) > 1:\n        warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected or none passed, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    #print(containment)\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)"],time:'2024-09-12T22:36:10.348Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['112','0','153','61','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-12T22:36:10.361Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['112','0','154','28','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5, warning_ids=None):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - If warning_ids is provided, apply the heuristics to only those warnings.\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n\n    # Determine which warnings to operate on: either from ground_truth or passed warning_ids\n    if warning_ids:\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k in warning_ids if warnings_state.get(k) == 'uninspected'\n        ]\n        #here print(warning_ids)\n        #here print(' warnings:', warnings)\n    else:\n        # Get all uninspected warnings with their lines of code and function calls\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n        ]\n\n    # Shuffle the warnings and sample based on the sampling ratio\n    random.shuffle(warnings)\n    if len(warnings) > 1:\n        warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected or none passed, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    #print(containment)\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:"],time:'2024-09-12T22:36:10.364Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['113','0','154','28','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-12T22:36:10.378Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['112','0','155','64','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5, warning_ids=None):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - If warning_ids is provided, apply the heuristics to only those warnings.\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n\n    # Determine which warnings to operate on: either from ground_truth or passed warning_ids\n    if warning_ids:\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k in warning_ids if warnings_state.get(k) == 'uninspected'\n        ]\n        #here print(warning_ids)\n        #here print(' warnings:', warnings)\n    else:\n        # Get all uninspected warnings with their lines of code and function calls\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n        ]\n\n    # Shuffle the warnings and sample based on the sampling ratio\n    random.shuffle(warnings)\n    if len(warnings) > 1:\n        warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected or none passed, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    #print(containment)\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)"],time:'2024-09-12T22:36:10.381Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['115','0','155','64','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-12T22:36:10.394Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['112','0','156','9','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5, warning_ids=None):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - If warning_ids is provided, apply the heuristics to only those warnings.\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n\n    # Determine which warnings to operate on: either from ground_truth or passed warning_ids\n    if warning_ids:\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k in warning_ids if warnings_state.get(k) == 'uninspected'\n        ]\n        #here print(warning_ids)\n        #here print(' warnings:', warnings)\n    else:\n        # Get all uninspected warnings with their lines of code and function calls\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n        ]\n\n    # Shuffle the warnings and sample based on the sampling ratio\n    random.shuffle(warnings)\n    if len(warnings) > 1:\n        warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected or none passed, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    #print(containment)\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        e"],time:'2024-09-12T22:36:10.397Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['116','0','157','72','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-12T22:36:10.411Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['112','0','158','28','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5, warning_ids=None):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - If warning_ids is provided, apply the heuristics to only those warnings.\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n\n    # Determine which warnings to operate on: either from ground_truth or passed warning_ids\n    if warning_ids:\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k in warning_ids if warnings_state.get(k) == 'uninspected'\n        ]\n        #here print(warning_ids)\n        #here print(' warnings:', warnings)\n    else:\n        # Get all uninspected warnings with their lines of code and function calls\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n        ]\n\n    # Shuffle the warnings and sample based on the sampling ratio\n    random.shuffle(warnings)\n    if len(warnings) > 1:\n        warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected or none passed, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    #print(containment)\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:"],time:'2024-09-12T22:36:10.414Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['117','0','158','28','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-12T22:36:10.427Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['112','0','159','39','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5, warning_ids=None):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - If warning_ids is provided, apply the heuristics to only those warnings.\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n\n    # Determine which warnings to operate on: either from ground_truth or passed warning_ids\n    if warning_ids:\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k in warning_ids if warnings_state.get(k) == 'uninspected'\n        ]\n        #here print(warning_ids)\n        #here print(' warnings:', warnings)\n    else:\n        # Get all uninspected warnings with their lines of code and function calls\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n        ]\n\n    # Shuffle the warnings and sample based on the sampling ratio\n    random.shuffle(warnings)\n    if len(warnings) > 1:\n        warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected or none passed, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    #print(containment)\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic"],time:'2024-09-12T22:36:10.431Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['118','0','159','39','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-12T22:36:10.443Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['112','0','160','78','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5, warning_ids=None):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - If warning_ids is provided, apply the heuristics to only those warnings.\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n\n    # Determine which warnings to operate on: either from ground_truth or passed warning_ids\n    if warning_ids:\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k in warning_ids if warnings_state.get(k) == 'uninspected'\n        ]\n        #here print(warning_ids)\n        #here print(' warnings:', warnings)\n    else:\n        # Get all uninspected warnings with their lines of code and function calls\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n        ]\n\n    # Shuffle the warnings and sample based on the sampling ratio\n    random.shuffle(warnings)\n    if len(warnings) > 1:\n        warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected or none passed, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    #print(containment)\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), "],time:'2024-09-12T22:36:10.446Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['119','0','160','78','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-12T22:36:10.460Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['112','0','161','9','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5, warning_ids=None):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - If warning_ids is provided, apply the heuristics to only those warnings.\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n\n    # Determine which warnings to operate on: either from ground_truth or passed warning_ids\n    if warning_ids:\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k in warning_ids if warnings_state.get(k) == 'uninspected'\n        ]\n        #here print(warning_ids)\n        #here print(' warnings:', warnings)\n    else:\n        # Get all uninspected warnings with their lines of code and function calls\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n        ]\n\n    # Shuffle the warnings and sample based on the sampling ratio\n    random.shuffle(warnings)\n    if len(warnings) > 1:\n        warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected or none passed, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    #print(containment)\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), \n         "],time:'2024-09-12T22:36:10.464Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['121','0','162','89','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-12T22:36:10.477Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['112','0','163','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5, warning_ids=None):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - If warning_ids is provided, apply the heuristics to only those warnings.\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n\n    # Determine which warnings to operate on: either from ground_truth or passed warning_ids\n    if warning_ids:\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k in warning_ids if warnings_state.get(k) == 'uninspected'\n        ]\n        #here print(warning_ids)\n        #here print(' warnings:', warnings)\n    else:\n        # Get all uninspected warnings with their lines of code and function calls\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n        ]\n\n    # Shuffle the warnings and sample based on the sampling ratio\n    random.shuffle(warnings)\n    if len(warnings) > 1:\n        warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected or none passed, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    #print(containment)\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), \n                                      heuristic_shared_function_calls(warnings), \n                                      heuristic_neighbor_classes(warnings, containment)])\n"],time:'2024-09-12T22:36:10.481Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['122','0','163','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-12T22:36:10.496Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['112','0','164','67','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5, warning_ids=None):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - If warning_ids is provided, apply the heuristics to only those warnings.\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n\n    # Determine which warnings to operate on: either from ground_truth or passed warning_ids\n    if warning_ids:\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k in warning_ids if warnings_state.get(k) == 'uninspected'\n        ]\n        #here print(warning_ids)\n        #here print(' warnings:', warnings)\n    else:\n        # Get all uninspected warnings with their lines of code and function calls\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n        ]\n\n    # Shuffle the warnings and sample based on the sampling ratio\n    random.shuffle(warnings)\n    if len(warnings) > 1:\n        warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected or none passed, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    #print(containment)\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), \n                                      heuristic_shared_function_calls(warnings), \n                                      heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings"],time:'2024-09-12T22:36:10.501Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['123','0','164','67','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-12T22:36:10.512Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['112','0','165','68','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5, warning_ids=None):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - If warning_ids is provided, apply the heuristics to only those warnings.\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n\n    # Determine which warnings to operate on: either from ground_truth or passed warning_ids\n    if warning_ids:\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k in warning_ids if warnings_state.get(k) == 'uninspected'\n        ]\n        #here print(warning_ids)\n        #here print(' warnings:', warnings)\n    else:\n        # Get all uninspected warnings with their lines of code and function calls\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n        ]\n\n    # Shuffle the warnings and sample based on the sampling ratio\n    random.shuffle(warnings)\n    if len(warnings) > 1:\n        warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected or none passed, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    #print(containment)\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), \n                                      heuristic_shared_function_calls(warnings), \n                                      heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])"],time:'2024-09-12T22:36:10.517Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['125','0','165','68','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-12T22:36:10.530Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['112','0','166','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5, warning_ids=None):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - If warning_ids is provided, apply the heuristics to only those warnings.\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n\n    # Determine which warnings to operate on: either from ground_truth or passed warning_ids\n    if warning_ids:\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k in warning_ids if warnings_state.get(k) == 'uninspected'\n        ]\n        #here print(warning_ids)\n        #here print(' warnings:', warnings)\n    else:\n        # Get all uninspected warnings with their lines of code and function calls\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n        ]\n\n    # Shuffle the warnings and sample based on the sampling ratio\n    random.shuffle(warnings)\n    if len(warnings) > 1:\n        warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected or none passed, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    #print(containment)\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), \n                                      heuristic_shared_function_calls(warnings), \n                                      heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n"],time:'2024-09-12T22:36:10.534Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['126','0','167','90','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-12T22:36:10.555Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['112','0','167','10','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5, warning_ids=None):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - If warning_ids is provided, apply the heuristics to only those warnings.\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n\n    # Determine which warnings to operate on: either from ground_truth or passed warning_ids\n    if warning_ids:\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k in warning_ids if warnings_state.get(k) == 'uninspected'\n        ]\n        #here print(warning_ids)\n        #here print(' warnings:', warnings)\n    else:\n        # Get all uninspected warnings with their lines of code and function calls\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n        ]\n\n    # Shuffle the warnings and sample based on the sampling ratio\n    random.shuffle(warnings)\n    if len(warnings) > 1:\n        warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected or none passed, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    #print(containment)\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), \n                                      heuristic_shared_function_calls(warnings), \n                                      heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # Clas"],time:'2024-09-12T22:36:10.560Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['112','0','167','90','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5, warning_ids=None):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - If warning_ids is provided, apply the heuristics to only those warnings.\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n\n    # Determine which warnings to operate on: either from ground_truth or passed warning_ids\n    if warning_ids:\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k in warning_ids if warnings_state.get(k) == 'uninspected'\n        ]\n        #here print(warning_ids)\n        #here print(' warnings:', warnings)\n    else:\n        # Get all uninspected warnings with their lines of code and function calls\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n        ]\n\n    # Shuffle the warnings and sample based on the sampling ratio\n    random.shuffle(warnings)\n    if len(warnings) > 1:\n        warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected or none passed, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    #print(containment)\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), \n                                      heuristic_shared_function_calls(warnings), \n                                      heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # Classify warnings as positive or negative based on their position in the sorted list"],time:'2024-09-12T22:36:10.567Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['112','0','167','11','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5, warning_ids=None):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - If warning_ids is provided, apply the heuristics to only those warnings.\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n\n    # Determine which warnings to operate on: either from ground_truth or passed warning_ids\n    if warning_ids:\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k in warning_ids if warnings_state.get(k) == 'uninspected'\n        ]\n        #here print(warning_ids)\n        #here print(' warnings:', warnings)\n    else:\n        # Get all uninspected warnings with their lines of code and function calls\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n        ]\n\n    # Shuffle the warnings and sample based on the sampling ratio\n    random.shuffle(warnings)\n    if len(warnings) > 1:\n        warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected or none passed, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    #print(containment)\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), \n                                      heuristic_shared_function_calls(warnings), \n                                      heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # Class"],time:'2024-09-12T22:36:10.998Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['127','0','167','90','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-12T22:36:11.011Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['112','0','168','11','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5, warning_ids=None):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - If warning_ids is provided, apply the heuristics to only those warnings.\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n\n    # Determine which warnings to operate on: either from ground_truth or passed warning_ids\n    if warning_ids:\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k in warning_ids if warnings_state.get(k) == 'uninspected'\n        ]\n        #here print(warning_ids)\n        #here print(' warnings:', warnings)\n    else:\n        # Get all uninspected warnings with their lines of code and function calls\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n        ]\n\n    # Shuffle the warnings and sample based on the sampling ratio\n    random.shuffle(warnings)\n    if len(warnings) > 1:\n        warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected or none passed, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    #print(containment)\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), \n                                      heuristic_shared_function_calls(warnings), \n                                      heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # Classify warnings as positive or negative based on their position in the sorted list\n    for i i"],time:'2024-09-12T22:36:11.017Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['128','0','169','88','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-12T22:36:11.037Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['112','0','170','43','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5, warning_ids=None):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - If warning_ids is provided, apply the heuristics to only those warnings.\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n\n    # Determine which warnings to operate on: either from ground_truth or passed warning_ids\n    if warning_ids:\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k in warning_ids if warnings_state.get(k) == 'uninspected'\n        ]\n        #here print(warning_ids)\n        #here print(' warnings:', warnings)\n    else:\n        # Get all uninspected warnings with their lines of code and function calls\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n        ]\n\n    # Shuffle the warnings and sample based on the sampling ratio\n    random.shuffle(warnings)\n    if len(warnings) > 1:\n        warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected or none passed, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    #print(containment)\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), \n                                      heuristic_shared_function_calls(warnings), \n                                      heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # Classify warnings as positive or negative based on their position in the sorted list\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])"],time:'2024-09-12T22:36:11.042Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['129','0','170','43','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-12T22:36:11.052Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['112','0','171','39','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5, warning_ids=None):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - If warning_ids is provided, apply the heuristics to only those warnings.\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n\n    # Determine which warnings to operate on: either from ground_truth or passed warning_ids\n    if warning_ids:\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k in warning_ids if warnings_state.get(k) == 'uninspected'\n        ]\n        #here print(warning_ids)\n        #here print(' warnings:', warnings)\n    else:\n        # Get all uninspected warnings with their lines of code and function calls\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n        ]\n\n    # Shuffle the warnings and sample based on the sampling ratio\n    random.shuffle(warnings)\n    if len(warnings) > 1:\n        warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected or none passed, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    #print(containment)\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), \n                                      heuristic_shared_function_calls(warnings), \n                                      heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # Classify warnings as positive or negative based on their position in the sorted list\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'"],time:'2024-09-12T22:36:11.056Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['112','0','171','11','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5, warning_ids=None):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - If warning_ids is provided, apply the heuristics to only those warnings.\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n\n    # Determine which warnings to operate on: either from ground_truth or passed warning_ids\n    if warning_ids:\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k in warning_ids if warnings_state.get(k) == 'uninspected'\n        ]\n        #here print(warning_ids)\n        #here print(' warnings:', warnings)\n    else:\n        # Get all uninspected warnings with their lines of code and function calls\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n        ]\n\n    # Shuffle the warnings and sample based on the sampling ratio\n    random.shuffle(warnings)\n    if len(warnings) > 1:\n        warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected or none passed, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    #print(containment)\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), \n                                      heuristic_shared_function_calls(warnings), \n                                      heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # Classify warnings as positive or negative based on their position in the sorted list\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n           "],time:'2024-09-12T22:36:11.066Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['130','0','171','39','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-12T22:36:11.077Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['112','0','172','44','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5, warning_ids=None):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - If warning_ids is provided, apply the heuristics to only those warnings.\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n\n    # Determine which warnings to operate on: either from ground_truth or passed warning_ids\n    if warning_ids:\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k in warning_ids if warnings_state.get(k) == 'uninspected'\n        ]\n        #here print(warning_ids)\n        #here print(' warnings:', warnings)\n    else:\n        # Get all uninspected warnings with their lines of code and function calls\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n        ]\n\n    # Shuffle the warnings and sample based on the sampling ratio\n    random.shuffle(warnings)\n    if len(warnings) > 1:\n        warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected or none passed, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    #print(containment)\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), \n                                      heuristic_shared_function_calls(warnings), \n                                      heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # Classify warnings as positive or negative based on their position in the sorted list\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])"],time:'2024-09-12T22:36:11.081Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['131','0','172','44','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-12T22:36:11.094Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['112','0','173','13','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5, warning_ids=None):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - If warning_ids is provided, apply the heuristics to only those warnings.\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n\n    # Determine which warnings to operate on: either from ground_truth or passed warning_ids\n    if warning_ids:\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k in warning_ids if warnings_state.get(k) == 'uninspected'\n        ]\n        #here print(warning_ids)\n        #here print(' warnings:', warnings)\n    else:\n        # Get all uninspected warnings with their lines of code and function calls\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n        ]\n\n    # Shuffle the warnings and sample based on the sampling ratio\n    random.shuffle(warnings)\n    if len(warnings) > 1:\n        warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected or none passed, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    #print(containment)\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), \n                                      heuristic_shared_function_calls(warnings), \n                                      heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # Classify warnings as positive or negative based on their position in the sorted list\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:"],time:'2024-09-12T22:36:11.097Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['132','0','173','13','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-12T22:36:11.110Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['112','0','174','43','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5, warning_ids=None):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - If warning_ids is provided, apply the heuristics to only those warnings.\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n\n    # Determine which warnings to operate on: either from ground_truth or passed warning_ids\n    if warning_ids:\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k in warning_ids if warnings_state.get(k) == 'uninspected'\n        ]\n        #here print(warning_ids)\n        #here print(' warnings:', warnings)\n    else:\n        # Get all uninspected warnings with their lines of code and function calls\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n        ]\n\n    # Shuffle the warnings and sample based on the sampling ratio\n    random.shuffle(warnings)\n    if len(warnings) > 1:\n        warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected or none passed, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    #print(containment)\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), \n                                      heuristic_shared_function_calls(warnings), \n                                      heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # Classify warnings as positive or negative based on their position in the sorted list\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])"],time:'2024-09-12T22:36:11.114Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['133','0','174','43','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-12T22:36:11.127Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['112','0','175','39','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5, warning_ids=None):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - If warning_ids is provided, apply the heuristics to only those warnings.\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n\n    # Determine which warnings to operate on: either from ground_truth or passed warning_ids\n    if warning_ids:\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k in warning_ids if warnings_state.get(k) == 'uninspected'\n        ]\n        #here print(warning_ids)\n        #here print(' warnings:', warnings)\n    else:\n        # Get all uninspected warnings with their lines of code and function calls\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n        ]\n\n    # Shuffle the warnings and sample based on the sampling ratio\n    random.shuffle(warnings)\n    if len(warnings) > 1:\n        warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected or none passed, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    #print(containment)\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), \n                                      heuristic_shared_function_calls(warnings), \n                                      heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # Classify warnings as positive or negative based on their position in the sorted list\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'"],time:'2024-09-12T22:36:11.131Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['134','0','175','39','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-12T22:36:11.144Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['112','0','176','48','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5, warning_ids=None):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - If warning_ids is provided, apply the heuristics to only those warnings.\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n\n    # Determine which warnings to operate on: either from ground_truth or passed warning_ids\n    if warning_ids:\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k in warning_ids if warnings_state.get(k) == 'uninspected'\n        ]\n        #here print(warning_ids)\n        #here print(' warnings:', warnings)\n    else:\n        # Get all uninspected warnings with their lines of code and function calls\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n        ]\n\n    # Shuffle the warnings and sample based on the sampling ratio\n    random.shuffle(warnings)\n    if len(warnings) > 1:\n        warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected or none passed, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    #print(containment)\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), \n                                      heuristic_shared_function_calls(warnings), \n                                      heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # Classify warnings as positive or negative based on their position in the sorted list\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    "],time:'2024-09-12T22:36:11.147Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['135','0','176','48','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-12T22:36:11.161Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['112','0','177','4','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5, warning_ids=None):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - If warning_ids is provided, apply the heuristics to only those warnings.\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n\n    # Determine which warnings to operate on: either from ground_truth or passed warning_ids\n    if warning_ids:\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k in warning_ids if warnings_state.get(k) == 'uninspected'\n        ]\n        #here print(warning_ids)\n        #here print(' warnings:', warnings)\n    else:\n        # Get all uninspected warnings with their lines of code and function calls\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n        ]\n\n    # Shuffle the warnings and sample based on the sampling ratio\n    random.shuffle(warnings)\n    if len(warnings) > 1:\n        warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected or none passed, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    #print(containment)\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), \n                                      heuristic_shared_function_calls(warnings), \n                                      heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # Classify warnings as positive or negative based on their position in the sorted list\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    "],time:'2024-09-12T22:36:11.164Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['136','0','177','4','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-12T22:36:11.178Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['112','0','178','72','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5, warning_ids=None):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - If warning_ids is provided, apply the heuristics to only those warnings.\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n\n    # Determine which warnings to operate on: either from ground_truth or passed warning_ids\n    if warning_ids:\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k in warning_ids if warnings_state.get(k) == 'uninspected'\n        ]\n        #here print(warning_ids)\n        #here print(' warnings:', warnings)\n    else:\n        # Get all uninspected warnings with their lines of code and function calls\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n        ]\n\n    # Shuffle the warnings and sample based on the sampling ratio\n    random.shuffle(warnings)\n    if len(warnings) > 1:\n        warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected or none passed, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    #print(containment)\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), \n                                      heuristic_shared_function_calls(warnings), \n                                      heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # Classify warnings as positive or negative based on their position in the sorted list\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning"],time:'2024-09-12T22:36:11.181Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['137','0','178','72','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-12T22:36:11.194Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['112','0','179','55','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5, warning_ids=None):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - If warning_ids is provided, apply the heuristics to only those warnings.\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n\n    # Determine which warnings to operate on: either from ground_truth or passed warning_ids\n    if warning_ids:\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k in warning_ids if warnings_state.get(k) == 'uninspected'\n        ]\n        #here print(warning_ids)\n        #here print(' warnings:', warnings)\n    else:\n        # Get all uninspected warnings with their lines of code and function calls\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n        ]\n\n    # Shuffle the warnings and sample based on the sampling ratio\n    random.shuffle(warnings)\n    if len(warnings) > 1:\n        warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected or none passed, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    #print(containment)\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), \n                                      heuristic_shared_function_calls(warnings), \n                                      heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # Classify warnings as positive or negative based on their position in the sorted list\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])"],time:'2024-09-12T22:36:11.198Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['138','0','179','55','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-12T22:36:11.211Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['112','0','180','4','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5, warning_ids=None):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - If warning_ids is provided, apply the heuristics to only those warnings.\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n\n    # Determine which warnings to operate on: either from ground_truth or passed warning_ids\n    if warning_ids:\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k in warning_ids if warnings_state.get(k) == 'uninspected'\n        ]\n        #here print(warning_ids)\n        #here print(' warnings:', warnings)\n    else:\n        # Get all uninspected warnings with their lines of code and function calls\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n        ]\n\n    # Shuffle the warnings and sample based on the sampling ratio\n    random.shuffle(warnings)\n    if len(warnings) > 1:\n        warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected or none passed, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    #print(containment)\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), \n                                      heuristic_shared_function_calls(warnings), \n                                      heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # Classify warnings as positive or negative based on their position in the sorted list\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    "],time:'2024-09-12T22:36:11.215Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['139','0','180','4','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-12T22:36:11.227Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['112','0','181','31','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5, warning_ids=None):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - If warning_ids is provided, apply the heuristics to only those warnings.\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n\n    # Determine which warnings to operate on: either from ground_truth or passed warning_ids\n    if warning_ids:\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k in warning_ids if warnings_state.get(k) == 'uninspected'\n        ]\n        #here print(warning_ids)\n        #here print(' warnings:', warnings)\n    else:\n        # Get all uninspected warnings with their lines of code and function calls\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n        ]\n\n    # Shuffle the warnings and sample based on the sampling ratio\n    random.shuffle(warnings)\n    if len(warnings) > 1:\n        warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected or none passed, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    #print(containment)\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), \n                                      heuristic_shared_function_calls(warnings), \n                                      heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # Classify warnings as positive or negative based on their position in the sorted list\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':"],time:'2024-09-12T22:36:11.232Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['140','0','181','31','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-12T22:36:11.247Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['112','0','182','50','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5, warning_ids=None):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - If warning_ids is provided, apply the heuristics to only those warnings.\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n\n    # Determine which warnings to operate on: either from ground_truth or passed warning_ids\n    if warning_ids:\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k in warning_ids if warnings_state.get(k) == 'uninspected'\n        ]\n        #here print(warning_ids)\n        #here print(' warnings:', warnings)\n    else:\n        # Get all uninspected warnings with their lines of code and function calls\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n        ]\n\n    # Shuffle the warnings and sample based on the sampling ratio\n    random.shuffle(warnings)\n    if len(warnings) > 1:\n        warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected or none passed, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    #print(containment)\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), \n                                      heuristic_shared_function_calls(warnings), \n                                      heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # Classify warnings as positive or negative based on their position in the sorted list\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive"],time:'2024-09-12T22:36:11.251Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['141','0','182','50','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-12T22:36:11.260Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['112','0','183','53','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5, warning_ids=None):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - If warning_ids is provided, apply the heuristics to only those warnings.\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n\n    # Determine which warnings to operate on: either from ground_truth or passed warning_ids\n    if warning_ids:\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k in warning_ids if warnings_state.get(k) == 'uninspected'\n        ]\n        #here print(warning_ids)\n        #here print(' warnings:', warnings)\n    else:\n        # Get all uninspected warnings with their lines of code and function calls\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n        ]\n\n    # Shuffle the warnings and sample based on the sampling ratio\n    random.shuffle(warnings)\n    if len(warnings) > 1:\n        warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected or none passed, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    #print(containment)\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), \n                                      heuristic_shared_function_calls(warnings), \n                                      heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # Classify warnings as positive or negative based on their position in the sorted list\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]"],time:'2024-09-12T22:36:11.264Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['142','0','183','53','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-12T22:36:11.277Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['112','0','184','39','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5, warning_ids=None):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - If warning_ids is provided, apply the heuristics to only those warnings.\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n\n    # Determine which warnings to operate on: either from ground_truth or passed warning_ids\n    if warning_ids:\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k in warning_ids if warnings_state.get(k) == 'uninspected'\n        ]\n        #here print(warning_ids)\n        #here print(' warnings:', warnings)\n    else:\n        # Get all uninspected warnings with their lines of code and function calls\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n        ]\n\n    # Shuffle the warnings and sample based on the sampling ratio\n    random.shuffle(warnings)\n    if len(warnings) > 1:\n        warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected or none passed, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    #print(containment)\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), \n                                      heuristic_shared_function_calls(warnings), \n                                      heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # Classify warnings as positive or negative based on their position in the sorted list\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []"],time:'2024-09-12T22:36:11.281Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['143','0','184','39','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-12T22:36:11.294Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['112','0','185','11','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5, warning_ids=None):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - If warning_ids is provided, apply the heuristics to only those warnings.\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n\n    # Determine which warnings to operate on: either from ground_truth or passed warning_ids\n    if warning_ids:\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k in warning_ids if warnings_state.get(k) == 'uninspected'\n        ]\n        #here print(warning_ids)\n        #here print(' warnings:', warnings)\n    else:\n        # Get all uninspected warnings with their lines of code and function calls\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n        ]\n\n    # Shuffle the warnings and sample based on the sampling ratio\n    random.shuffle(warnings)\n    if len(warnings) > 1:\n        warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected or none passed, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    #print(containment)\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), \n                                      heuristic_shared_function_calls(warnings), \n                                      heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # Classify warnings as positive or negative based on their position in the sorted list\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        war"],time:'2024-09-12T22:36:11.298Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['145','0','185','66','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-12T22:36:11.311Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['112','0','186','9','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5, warning_ids=None):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - If warning_ids is provided, apply the heuristics to only those warnings.\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n\n    # Determine which warnings to operate on: either from ground_truth or passed warning_ids\n    if warning_ids:\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k in warning_ids if warnings_state.get(k) == 'uninspected'\n        ]\n        #here print(warning_ids)\n        #here print(' warnings:', warnings)\n    else:\n        # Get all uninspected warnings with their lines of code and function calls\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n        ]\n\n    # Shuffle the warnings and sample based on the sampling ratio\n    random.shuffle(warnings)\n    if len(warnings) > 1:\n        warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected or none passed, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    #print(containment)\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), \n                                      heuristic_shared_function_calls(warnings), \n                                      heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # Classify warnings as positive or negative based on their position in the sorted list\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n    else:"],time:'2024-09-12T22:36:11.314Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['146','0','186','9','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-12T22:36:11.327Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['112','0','187','11','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5, warning_ids=None):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - If warning_ids is provided, apply the heuristics to only those warnings.\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n\n    # Determine which warnings to operate on: either from ground_truth or passed warning_ids\n    if warning_ids:\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k in warning_ids if warnings_state.get(k) == 'uninspected'\n        ]\n        #here print(warning_ids)\n        #here print(' warnings:', warnings)\n    else:\n        # Get all uninspected warnings with their lines of code and function calls\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n        ]\n\n    # Shuffle the warnings and sample based on the sampling ratio\n    random.shuffle(warnings)\n    if len(warnings) > 1:\n        warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected or none passed, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    #print(containment)\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), \n                                      heuristic_shared_function_calls(warnings), \n                                      heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # Classify warnings as positive or negative based on their position in the sorted list\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n    else:\n        # S"],time:'2024-09-12T22:36:11.331Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['147','0','188','39','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-12T22:36:11.344Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['112','0','189','54','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5, warning_ids=None):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - If warning_ids is provided, apply the heuristics to only those warnings.\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n\n    # Determine which warnings to operate on: either from ground_truth or passed warning_ids\n    if warning_ids:\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k in warning_ids if warnings_state.get(k) == 'uninspected'\n        ]\n        #here print(warning_ids)\n        #here print(' warnings:', warnings)\n    else:\n        # Get all uninspected warnings with their lines of code and function calls\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n        ]\n\n    # Shuffle the warnings and sample based on the sampling ratio\n    random.shuffle(warnings)\n    if len(warnings) > 1:\n        warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected or none passed, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    #print(containment)\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), \n                                      heuristic_shared_function_calls(warnings), \n                                      heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # Classify warnings as positive or negative based on their position in the sorted list\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]"],time:'2024-09-12T22:36:11.348Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['148','0','189','54','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-12T22:36:11.361Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['112','0','190','66','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5, warning_ids=None):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - If warning_ids is provided, apply the heuristics to only those warnings.\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n\n    # Determine which warnings to operate on: either from ground_truth or passed warning_ids\n    if warning_ids:\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k in warning_ids if warnings_state.get(k) == 'uninspected'\n        ]\n        #here print(warning_ids)\n        #here print(' warnings:', warnings)\n    else:\n        # Get all uninspected warnings with their lines of code and function calls\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n        ]\n\n    # Shuffle the warnings and sample based on the sampling ratio\n    random.shuffle(warnings)\n    if len(warnings) > 1:\n        warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected or none passed, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    #print(containment)\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), \n                                      heuristic_shared_function_calls(warnings), \n                                      heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # Classify warnings as positive or negative based on their position in the sorted list\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'"],time:'2024-09-12T22:36:11.364Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['149','0','190','66','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-12T22:36:11.378Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['112','0','191','4','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5, warning_ids=None):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - If warning_ids is provided, apply the heuristics to only those warnings.\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n\n    # Determine which warnings to operate on: either from ground_truth or passed warning_ids\n    if warning_ids:\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k in warning_ids if warnings_state.get(k) == 'uninspected'\n        ]\n        #here print(warning_ids)\n        #here print(' warnings:', warnings)\n    else:\n        # Get all uninspected warnings with their lines of code and function calls\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n        ]\n\n    # Shuffle the warnings and sample based on the sampling ratio\n    random.shuffle(warnings)\n    if len(warnings) > 1:\n        warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected or none passed, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    #print(containment)\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), \n                                      heuristic_shared_function_calls(warnings), \n                                      heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # Classify warnings as positive or negative based on their position in the sorted list\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n    "],time:'2024-09-12T22:36:11.381Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['150','0','191','4','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-12T22:36:11.394Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['112','0','192','67','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5, warning_ids=None):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - If warning_ids is provided, apply the heuristics to only those warnings.\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n\n    # Determine which warnings to operate on: either from ground_truth or passed warning_ids\n    if warning_ids:\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k in warning_ids if warnings_state.get(k) == 'uninspected'\n        ]\n        #here print(warning_ids)\n        #here print(' warnings:', warnings)\n    else:\n        # Get all uninspected warnings with their lines of code and function calls\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n        ]\n\n    # Shuffle the warnings and sample based on the sampling ratio\n    random.shuffle(warnings)\n    if len(warnings) > 1:\n        warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected or none passed, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    #print(containment)\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), \n                                      heuristic_shared_function_calls(warnings), \n                                      heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # Classify warnings as positive or negative based on their position in the sorted list\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n    \n    print('Selected positive warning:', selected_positive_warnings)"],time:'2024-09-12T22:36:11.398Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['151','0','192','67','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-12T22:36:11.411Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['112','0','193','67','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5, warning_ids=None):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - If warning_ids is provided, apply the heuristics to only those warnings.\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n\n    # Determine which warnings to operate on: either from ground_truth or passed warning_ids\n    if warning_ids:\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k in warning_ids if warnings_state.get(k) == 'uninspected'\n        ]\n        #here print(warning_ids)\n        #here print(' warnings:', warnings)\n    else:\n        # Get all uninspected warnings with their lines of code and function calls\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n        ]\n\n    # Shuffle the warnings and sample based on the sampling ratio\n    random.shuffle(warnings)\n    if len(warnings) > 1:\n        warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected or none passed, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    #print(containment)\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), \n                                      heuristic_shared_function_calls(warnings), \n                                      heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # Classify warnings as positive or negative based on their position in the sorted list\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)"],time:'2024-09-12T22:36:11.414Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['152','0','193','67','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-12T22:36:11.427Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['112','0','193','11','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5, warning_ids=None):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - If warning_ids is provided, apply the heuristics to only those warnings.\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n\n    # Determine which warnings to operate on: either from ground_truth or passed warning_ids\n    if warning_ids:\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k in warning_ids if warnings_state.get(k) == 'uninspected'\n        ]\n        #here print(warning_ids)\n        #here print(' warnings:', warnings)\n    else:\n        # Get all uninspected warnings with their lines of code and function calls\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n        ]\n\n    # Shuffle the warnings and sample based on the sampling ratio\n    random.shuffle(warnings)\n    if len(warnings) > 1:\n        warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected or none passed, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    #print(containment)\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), \n                                      heuristic_shared_function_calls(warnings), \n                                      heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # Classify warnings as positive or negative based on their position in the sorted list\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('"],time:'2024-09-12T22:36:11.430Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['153','0','193','67','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-12T22:36:11.444Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['112','0','194','4','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5, warning_ids=None):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - If warning_ids is provided, apply the heuristics to only those warnings.\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n\n    # Determine which warnings to operate on: either from ground_truth or passed warning_ids\n    if warning_ids:\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k in warning_ids if warnings_state.get(k) == 'uninspected'\n        ]\n        #here print(warning_ids)\n        #here print(' warnings:', warnings)\n    else:\n        # Get all uninspected warnings with their lines of code and function calls\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n        ]\n\n    # Shuffle the warnings and sample based on the sampling ratio\n    random.shuffle(warnings)\n    if len(warnings) > 1:\n        warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected or none passed, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    #print(containment)\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), \n                                      heuristic_shared_function_calls(warnings), \n                                      heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # Classify warnings as positive or negative based on their position in the sorted list\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    "],time:'2024-09-12T22:36:11.448Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['154','0','194','4','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-12T22:36:11.461Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['112','0','195','11','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5, warning_ids=None):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - If warning_ids is provided, apply the heuristics to only those warnings.\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n\n    # Determine which warnings to operate on: either from ground_truth or passed warning_ids\n    if warning_ids:\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k in warning_ids if warnings_state.get(k) == 'uninspected'\n        ]\n        #here print(warning_ids)\n        #here print(' warnings:', warnings)\n    else:\n        # Get all uninspected warnings with their lines of code and function calls\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n        ]\n\n    # Shuffle the warnings and sample based on the sampling ratio\n    random.shuffle(warnings)\n    if len(warnings) > 1:\n        warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected or none passed, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    #print(containment)\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), \n                                      heuristic_shared_function_calls(warnings), \n                                      heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # Classify warnings as positive or negative based on their position in the sorted list\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return "],time:'2024-09-12T22:36:11.465Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['154','0','195','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-12T22:36:11.480Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['112','0','196','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5, warning_ids=None):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - If warning_ids is provided, apply the heuristics to only those warnings.\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n\n    # Determine which warnings to operate on: either from ground_truth or passed warning_ids\n    if warning_ids:\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k in warning_ids if warnings_state.get(k) == 'uninspected'\n        ]\n        #here print(warning_ids)\n        #here print(' warnings:', warnings)\n    else:\n        # Get all uninspected warnings with their lines of code and function calls\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n        ]\n\n    # Shuffle the warnings and sample based on the sampling ratio\n    random.shuffle(warnings)\n    if len(warnings) > 1:\n        warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected or none passed, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    #print(containment)\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), \n                                      heuristic_shared_function_calls(warnings), \n                                      heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # Classify warnings as positive or negative based on their position in the sorted list\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings\n"],time:'2024-09-12T22:36:11.484Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['112','0','195','12','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5, warning_ids=None):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - If warning_ids is provided, apply the heuristics to only those warnings.\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n\n    # Determine which warnings to operate on: either from ground_truth or passed warning_ids\n    if warning_ids:\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k in warning_ids if warnings_state.get(k) == 'uninspected'\n        ]\n        #here print(warning_ids)\n        #here print(' warnings:', warnings)\n    else:\n        # Get all uninspected warnings with their lines of code and function calls\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n        ]\n\n    # Shuffle the warnings and sample based on the sampling ratio\n    random.shuffle(warnings)\n    if len(warnings) > 1:\n        warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected or none passed, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    #print(containment)\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), \n                                      heuristic_shared_function_calls(warnings), \n                                      heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # Classify warnings as positive or negative based on their position in the sorted list\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return s"],time:'2024-09-12T22:36:11.528Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['112','0','195','13','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5, warning_ids=None):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - If warning_ids is provided, apply the heuristics to only those warnings.\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n\n    # Determine which warnings to operate on: either from ground_truth or passed warning_ids\n    if warning_ids:\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k in warning_ids if warnings_state.get(k) == 'uninspected'\n        ]\n        #here print(warning_ids)\n        #here print(' warnings:', warnings)\n    else:\n        # Get all uninspected warnings with their lines of code and function calls\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n        ]\n\n    # Shuffle the warnings and sample based on the sampling ratio\n    random.shuffle(warnings)\n    if len(warnings) > 1:\n        warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected or none passed, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    #print(containment)\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), \n                                      heuristic_shared_function_calls(warnings), \n                                      heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # Classify warnings as positive or negative based on their position in the sorted list\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return se"],time:'2024-09-12T22:36:11.694Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['112','0','194','4','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5, warning_ids=None):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - If warning_ids is provided, apply the heuristics to only those warnings.\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n\n    # Determine which warnings to operate on: either from ground_truth or passed warning_ids\n    if warning_ids:\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k in warning_ids if warnings_state.get(k) == 'uninspected'\n        ]\n        #here print(warning_ids)\n        #here print(' warnings:', warnings)\n    else:\n        # Get all uninspected warnings with their lines of code and function calls\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n        ]\n\n    # Shuffle the warnings and sample based on the sampling ratio\n    random.shuffle(warnings)\n    if len(warnings) > 1:\n        warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected or none passed, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    #print(containment)\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), \n                                      heuristic_shared_function_calls(warnings), \n                                      heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # Classify warnings as positive or negative based on their position in the sorted list\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    "],time:'2024-09-12T22:36:11.745Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['112','0','195','13','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5, warning_ids=None):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - If warning_ids is provided, apply the heuristics to only those warnings.\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n\n    # Determine which warnings to operate on: either from ground_truth or passed warning_ids\n    if warning_ids:\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k in warning_ids if warnings_state.get(k) == 'uninspected'\n        ]\n        #here print(warning_ids)\n        #here print(' warnings:', warnings)\n    else:\n        # Get all uninspected warnings with their lines of code and function calls\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n        ]\n\n    # Shuffle the warnings and sample based on the sampling ratio\n    random.shuffle(warnings)\n    if len(warnings) > 1:\n        warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected or none passed, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    #print(containment)\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), \n                                      heuristic_shared_function_calls(warnings), \n                                      heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # Classify warnings as positive or negative based on their position in the sorted list\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return se"],time:'2024-09-12T22:36:12.195Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['112','0','195','12','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5, warning_ids=None):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - If warning_ids is provided, apply the heuristics to only those warnings.\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n\n    # Determine which warnings to operate on: either from ground_truth or passed warning_ids\n    if warning_ids:\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k in warning_ids if warnings_state.get(k) == 'uninspected'\n        ]\n        #here print(warning_ids)\n        #here print(' warnings:', warnings)\n    else:\n        # Get all uninspected warnings with their lines of code and function calls\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n        ]\n\n    # Shuffle the warnings and sample based on the sampling ratio\n    random.shuffle(warnings)\n    if len(warnings) > 1:\n        warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected or none passed, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    #print(containment)\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), \n                                      heuristic_shared_function_calls(warnings), \n                                      heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # Classify warnings as positive or negative based on their position in the sorted list\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return s"],time:'2024-09-12T22:36:12.245Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['112','0','196','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5, warning_ids=None):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - If warning_ids is provided, apply the heuristics to only those warnings.\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n\n    # Determine which warnings to operate on: either from ground_truth or passed warning_ids\n    if warning_ids:\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k in warning_ids if warnings_state.get(k) == 'uninspected'\n        ]\n        #here print(warning_ids)\n        #here print(' warnings:', warnings)\n    else:\n        # Get all uninspected warnings with their lines of code and function calls\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n        ]\n\n    # Shuffle the warnings and sample based on the sampling ratio\n    random.shuffle(warnings)\n    if len(warnings) > 1:\n        warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected or none passed, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    #print(containment)\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), \n                                      heuristic_shared_function_calls(warnings), \n                                      heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # Classify warnings as positive or negative based on their position in the sorted list\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings\n"],time:'2024-09-12T22:36:12.311Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['155','0','196','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-12T22:36:12.312Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['156','0','196','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-12T22:36:13.178Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['112','0','197','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5, warning_ids=None):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - If warning_ids is provided, apply the heuristics to only those warnings.\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n\n    # Determine which warnings to operate on: either from ground_truth or passed warning_ids\n    if warning_ids:\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k in warning_ids if warnings_state.get(k) == 'uninspected'\n        ]\n        #here print(warning_ids)\n        #here print(' warnings:', warnings)\n    else:\n        # Get all uninspected warnings with their lines of code and function calls\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n        ]\n\n    # Shuffle the warnings and sample based on the sampling ratio\n    random.shuffle(warnings)\n    if len(warnings) > 1:\n        warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected or none passed, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    #print(containment)\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), \n                                      heuristic_shared_function_calls(warnings), \n                                      heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # Classify warnings as positive or negative based on their position in the sorted list\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings\n\n"],time:'2024-09-12T22:36:13.183Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['157','0','198','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-12T22:36:13.209Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['112','0','199','17','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5, warning_ids=None):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - If warning_ids is provided, apply the heuristics to only those warnings.\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n\n    # Determine which warnings to operate on: either from ground_truth or passed warning_ids\n    if warning_ids:\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k in warning_ids if warnings_state.get(k) == 'uninspected'\n        ]\n        #here print(warning_ids)\n        #here print(' warnings:', warnings)\n    else:\n        # Get all uninspected warnings with their lines of code and function calls\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n        ]\n\n    # Shuffle the warnings and sample based on the sampling ratio\n    random.shuffle(warnings)\n    if len(warnings) > 1:\n        warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected or none passed, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    #print(containment)\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), \n                                      heuristic_shared_function_calls(warnings), \n                                      heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # Classify warnings as positive or negative based on their position in the sorted list\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings\n\n\n\ndef run_clingo():"],time:'2024-09-12T22:36:13.213Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['158','0','199','17','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-12T22:36:13.220Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['112','0','200','13','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5, warning_ids=None):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - If warning_ids is provided, apply the heuristics to only those warnings.\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n\n    # Determine which warnings to operate on: either from ground_truth or passed warning_ids\n    if warning_ids:\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k in warning_ids if warnings_state.get(k) == 'uninspected'\n        ]\n        #here print(warning_ids)\n        #here print(' warnings:', warnings)\n    else:\n        # Get all uninspected warnings with their lines of code and function calls\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n        ]\n\n    # Shuffle the warnings and sample based on the sampling ratio\n    random.shuffle(warnings)\n    if len(warnings) > 1:\n        warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected or none passed, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    #print(containment)\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), \n                                      heuristic_shared_function_calls(warnings), \n                                      heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # Classify warnings as positive or negative based on their position in the sorted list\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings\n\n\n\ndef run_clingo():\n    files = ["],time:'2024-09-12T22:36:13.225Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['159','0','200','13','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-12T22:36:13.244Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['112','0','201','37','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5, warning_ids=None):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - If warning_ids is provided, apply the heuristics to only those warnings.\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n\n    # Determine which warnings to operate on: either from ground_truth or passed warning_ids\n    if warning_ids:\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k in warning_ids if warnings_state.get(k) == 'uninspected'\n        ]\n        #here print(warning_ids)\n        #here print(' warnings:', warnings)\n    else:\n        # Get all uninspected warnings with their lines of code and function calls\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n        ]\n\n    # Shuffle the warnings and sample based on the sampling ratio\n    random.shuffle(warnings)\n    if len(warnings) > 1:\n        warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected or none passed, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    #print(containment)\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), \n                                      heuristic_shared_function_calls(warnings), \n                                      heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # Classify warnings as positive or negative based on their position in the sorted list\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings\n\n\n\ndef run_clingo():\n    files = [\n        f'lp/simulation_labels.lp',  "],time:'2024-09-12T22:36:13.249Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['160','0','201','37','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-12T22:36:13.261Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['112','0','202','41','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5, warning_ids=None):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - If warning_ids is provided, apply the heuristics to only those warnings.\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n\n    # Determine which warnings to operate on: either from ground_truth or passed warning_ids\n    if warning_ids:\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k in warning_ids if warnings_state.get(k) == 'uninspected'\n        ]\n        #here print(warning_ids)\n        #here print(' warnings:', warnings)\n    else:\n        # Get all uninspected warnings with their lines of code and function calls\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n        ]\n\n    # Shuffle the warnings and sample based on the sampling ratio\n    random.shuffle(warnings)\n    if len(warnings) > 1:\n        warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected or none passed, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    #print(containment)\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), \n                                      heuristic_shared_function_calls(warnings), \n                                      heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # Classify warnings as positive or negative based on their position in the sorted list\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings\n\n\n\ndef run_clingo():\n    files = [\n        f'lp/simulation_labels.lp',  \n        'lp/background.lp',              "],time:'2024-09-12T22:36:13.265Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['161','0','202','41','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-12T22:36:13.278Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['112','0','203','41','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5, warning_ids=None):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - If warning_ids is provided, apply the heuristics to only those warnings.\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n\n    # Determine which warnings to operate on: either from ground_truth or passed warning_ids\n    if warning_ids:\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k in warning_ids if warnings_state.get(k) == 'uninspected'\n        ]\n        #here print(warning_ids)\n        #here print(' warnings:', warnings)\n    else:\n        # Get all uninspected warnings with their lines of code and function calls\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n        ]\n\n    # Shuffle the warnings and sample based on the sampling ratio\n    random.shuffle(warnings)\n    if len(warnings) > 1:\n        warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected or none passed, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    #print(containment)\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), \n                                      heuristic_shared_function_calls(warnings), \n                                      heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # Classify warnings as positive or negative based on their position in the sorted list\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings\n\n\n\ndef run_clingo():\n    files = [\n        f'lp/simulation_labels.lp',  \n        'lp/background.lp',              \n        'lp/frozen_rules.lp',            "],time:'2024-09-12T22:36:13.282Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['162','0','202','41','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-12T22:36:13.295Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['163','0','203','41','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-12T22:36:13.311Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['112','0','204','41','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5, warning_ids=None):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - If warning_ids is provided, apply the heuristics to only those warnings.\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n\n    # Determine which warnings to operate on: either from ground_truth or passed warning_ids\n    if warning_ids:\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k in warning_ids if warnings_state.get(k) == 'uninspected'\n        ]\n        #here print(warning_ids)\n        #here print(' warnings:', warnings)\n    else:\n        # Get all uninspected warnings with their lines of code and function calls\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n        ]\n\n    # Shuffle the warnings and sample based on the sampling ratio\n    random.shuffle(warnings)\n    if len(warnings) > 1:\n        warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected or none passed, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    #print(containment)\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), \n                                      heuristic_shared_function_calls(warnings), \n                                      heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # Classify warnings as positive or negative based on their position in the sorted list\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings\n\n\n\ndef run_clingo():\n    files = [\n        f'lp/simulation_labels.lp',  \n        'lp/background.lp',              \n        'lp/frozen_rules.lp',            \n        'lp/rules2.lp'                   "],time:'2024-09-12T22:36:13.315Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['164','0','204','41','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-12T22:36:13.328Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['112','0','205','5','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5, warning_ids=None):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - If warning_ids is provided, apply the heuristics to only those warnings.\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n\n    # Determine which warnings to operate on: either from ground_truth or passed warning_ids\n    if warning_ids:\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k in warning_ids if warnings_state.get(k) == 'uninspected'\n        ]\n        #here print(warning_ids)\n        #here print(' warnings:', warnings)\n    else:\n        # Get all uninspected warnings with their lines of code and function calls\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n        ]\n\n    # Shuffle the warnings and sample based on the sampling ratio\n    random.shuffle(warnings)\n    if len(warnings) > 1:\n        warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected or none passed, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    #print(containment)\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), \n                                      heuristic_shared_function_calls(warnings), \n                                      heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # Classify warnings as positive or negative based on their position in the sorted list\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings\n\n\n\ndef run_clingo():\n    files = [\n        f'lp/simulation_labels.lp',  \n        'lp/background.lp',              \n        'lp/frozen_rules.lp',            \n        'lp/rules2.lp'                   \n    ]"],time:'2024-09-12T22:36:13.331Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['165','0','205','5','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-12T22:36:13.344Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['112','0','206','4','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5, warning_ids=None):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - If warning_ids is provided, apply the heuristics to only those warnings.\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n\n    # Determine which warnings to operate on: either from ground_truth or passed warning_ids\n    if warning_ids:\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k in warning_ids if warnings_state.get(k) == 'uninspected'\n        ]\n        #here print(warning_ids)\n        #here print(' warnings:', warnings)\n    else:\n        # Get all uninspected warnings with their lines of code and function calls\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n        ]\n\n    # Shuffle the warnings and sample based on the sampling ratio\n    random.shuffle(warnings)\n    if len(warnings) > 1:\n        warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected or none passed, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    #print(containment)\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), \n                                      heuristic_shared_function_calls(warnings), \n                                      heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # Classify warnings as positive or negative based on their position in the sorted list\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings\n\n\n\ndef run_clingo():\n    files = [\n        f'lp/simulation_labels.lp',  \n        'lp/background.lp',              \n        'lp/frozen_rules.lp',            \n        'lp/rules2.lp'                   \n    ]\n    "],time:'2024-09-12T22:36:13.347Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['166','0','206','4','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-12T22:36:13.361Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['112','0','207','66','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5, warning_ids=None):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - If warning_ids is provided, apply the heuristics to only those warnings.\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n\n    # Determine which warnings to operate on: either from ground_truth or passed warning_ids\n    if warning_ids:\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k in warning_ids if warnings_state.get(k) == 'uninspected'\n        ]\n        #here print(warning_ids)\n        #here print(' warnings:', warnings)\n    else:\n        # Get all uninspected warnings with their lines of code and function calls\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n        ]\n\n    # Shuffle the warnings and sample based on the sampling ratio\n    random.shuffle(warnings)\n    if len(warnings) > 1:\n        warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected or none passed, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    #print(containment)\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), \n                                      heuristic_shared_function_calls(warnings), \n                                      heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # Classify warnings as positive or negative based on their position in the sorted list\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings\n\n\n\ndef run_clingo():\n    files = [\n        f'lp/simulation_labels.lp',  \n        'lp/background.lp',              \n        'lp/frozen_rules.lp',            \n        'lp/rules2.lp'                   \n    ]\n    \n    command = ['clingo'] + files + ['--outf=2'] + ['--time-limit=3"],time:'2024-09-12T22:36:13.364Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['167','0','207','70','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-12T22:36:13.377Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['112','0','208','28','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5, warning_ids=None):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - If warning_ids is provided, apply the heuristics to only those warnings.\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n\n    # Determine which warnings to operate on: either from ground_truth or passed warning_ids\n    if warning_ids:\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k in warning_ids if warnings_state.get(k) == 'uninspected'\n        ]\n        #here print(warning_ids)\n        #here print(' warnings:', warnings)\n    else:\n        # Get all uninspected warnings with their lines of code and function calls\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n        ]\n\n    # Shuffle the warnings and sample based on the sampling ratio\n    random.shuffle(warnings)\n    if len(warnings) > 1:\n        warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected or none passed, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    #print(containment)\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), \n                                      heuristic_shared_function_calls(warnings), \n                                      heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # Classify warnings as positive or negative based on their position in the sorted list\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings\n\n\n\ndef run_clingo():\n    files = [\n        f'lp/simulation_labels.lp',  \n        'lp/background.lp',              \n        'lp/frozen_rules.lp',            \n        'lp/rules2.lp'                   \n    ]\n    \n    command = ['clingo'] + files + ['--outf=2'] + ['--time-limit=30'] \n    print(' '.join(command))"],time:'2024-09-12T22:36:13.381Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['168','0','208','28','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-12T22:36:13.394Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['112','0','209','66','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5, warning_ids=None):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - If warning_ids is provided, apply the heuristics to only those warnings.\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n\n    # Determine which warnings to operate on: either from ground_truth or passed warning_ids\n    if warning_ids:\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k in warning_ids if warnings_state.get(k) == 'uninspected'\n        ]\n        #here print(warning_ids)\n        #here print(' warnings:', warnings)\n    else:\n        # Get all uninspected warnings with their lines of code and function calls\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n        ]\n\n    # Shuffle the warnings and sample based on the sampling ratio\n    random.shuffle(warnings)\n    if len(warnings) > 1:\n        warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected or none passed, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    #print(containment)\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), \n                                      heuristic_shared_function_calls(warnings), \n                                      heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # Classify warnings as positive or negative based on their position in the sorted list\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings\n\n\n\ndef run_clingo():\n    files = [\n        f'lp/simulation_labels.lp',  \n        'lp/background.lp',              \n        'lp/frozen_rules.lp',            \n        'lp/rules2.lp'                   \n    ]\n    \n    command = ['clingo'] + files + ['--outf=2'] + ['--time-limit=30'] \n    print(' '.join(command))\n    result = subprocess.run(command, capture_output=True, text=Tru"],time:'2024-09-12T22:36:13.397Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['169','0','210','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-12T22:36:13.411Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['112','0','211','24','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5, warning_ids=None):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - If warning_ids is provided, apply the heuristics to only those warnings.\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n\n    # Determine which warnings to operate on: either from ground_truth or passed warning_ids\n    if warning_ids:\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k in warning_ids if warnings_state.get(k) == 'uninspected'\n        ]\n        #here print(warning_ids)\n        #here print(' warnings:', warnings)\n    else:\n        # Get all uninspected warnings with their lines of code and function calls\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n        ]\n\n    # Shuffle the warnings and sample based on the sampling ratio\n    random.shuffle(warnings)\n    if len(warnings) > 1:\n        warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected or none passed, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    #print(containment)\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), \n                                      heuristic_shared_function_calls(warnings), \n                                      heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # Classify warnings as positive or negative based on their position in the sorted list\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings\n\n\n\ndef run_clingo():\n    files = [\n        f'lp/simulation_labels.lp',  \n        'lp/background.lp',              \n        'lp/frozen_rules.lp',            \n        'lp/rules2.lp'                   \n    ]\n    \n    command = ['clingo'] + files + ['--outf=2'] + ['--time-limit=30'] \n    print(' '.join(command))\n    result = subprocess.run(command, capture_output=True, text=True)\n\n    return result.stdout"],time:'2024-09-12T22:36:13.415Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['170','0','210','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-12T22:36:13.428Z'},{src:'onDidChangeTextEditorVisibleRanges',msg:'%s:%s to %s:%s [%s]',prm:['170','0','211','24','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py'],time:'2024-09-12T22:36:13.444Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['112','0','212','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5, warning_ids=None):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - If warning_ids is provided, apply the heuristics to only those warnings.\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n\n    # Determine which warnings to operate on: either from ground_truth or passed warning_ids\n    if warning_ids:\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k in warning_ids if warnings_state.get(k) == 'uninspected'\n        ]\n        #here print(warning_ids)\n        #here print(' warnings:', warnings)\n    else:\n        # Get all uninspected warnings with their lines of code and function calls\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n        ]\n\n    # Shuffle the warnings and sample based on the sampling ratio\n    random.shuffle(warnings)\n    if len(warnings) > 1:\n        warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected or none passed, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    #print(containment)\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), \n                                      heuristic_shared_function_calls(warnings), \n                                      heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # Classify warnings as positive or negative based on their position in the sorted list\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings\n\n\n\ndef run_clingo():\n    files = [\n        f'lp/simulation_labels.lp',  \n        'lp/background.lp',              \n        'lp/frozen_rules.lp',            \n        'lp/rules2.lp'                   \n    ]\n    \n    command = ['clingo'] + files + ['--outf=2'] + ['--time-limit=30'] \n    print(' '.join(command))\n    result = subprocess.run(command, capture_output=True, text=True)\n\n    return result.stdout\n"],time:'2024-09-12T22:36:13.447Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['112','0','211','24','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5, warning_ids=None):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - If warning_ids is provided, apply the heuristics to only those warnings.\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n\n    # Determine which warnings to operate on: either from ground_truth or passed warning_ids\n    if warning_ids:\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k in warning_ids if warnings_state.get(k) == 'uninspected'\n        ]\n        #here print(warning_ids)\n        #here print(' warnings:', warnings)\n    else:\n        # Get all uninspected warnings with their lines of code and function calls\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n        ]\n\n    # Shuffle the warnings and sample based on the sampling ratio\n    random.shuffle(warnings)\n    if len(warnings) > 1:\n        warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected or none passed, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    #print(containment)\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), \n                                      heuristic_shared_function_calls(warnings), \n                                      heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # Classify warnings as positive or negative based on their position in the sorted list\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings\n\n\n\ndef run_clingo():\n    files = [\n        f'lp/simulation_labels.lp',  \n        'lp/background.lp',              \n        'lp/frozen_rules.lp',            \n        'lp/rules2.lp'                   \n    ]\n    \n    command = ['clingo'] + files + ['--outf=2'] + ['--time-limit=30'] \n    print(' '.join(command))\n    result = subprocess.run(command, capture_output=True, text=True)\n\n    return result.stdout"],time:'2024-09-12T22:36:13.495Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['112','0','210','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5, warning_ids=None):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - If warning_ids is provided, apply the heuristics to only those warnings.\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n\n    # Determine which warnings to operate on: either from ground_truth or passed warning_ids\n    if warning_ids:\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k in warning_ids if warnings_state.get(k) == 'uninspected'\n        ]\n        #here print(warning_ids)\n        #here print(' warnings:', warnings)\n    else:\n        # Get all uninspected warnings with their lines of code and function calls\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n        ]\n\n    # Shuffle the warnings and sample based on the sampling ratio\n    random.shuffle(warnings)\n    if len(warnings) > 1:\n        warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected or none passed, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    #print(containment)\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), \n                                      heuristic_shared_function_calls(warnings), \n                                      heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # Classify warnings as positive or negative based on their position in the sorted list\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings\n\n\n\ndef run_clingo():\n    files = [\n        f'lp/simulation_labels.lp',  \n        'lp/background.lp',              \n        'lp/frozen_rules.lp',            \n        'lp/rules2.lp'                   \n    ]\n    \n    command = ['clingo'] + files + ['--outf=2'] + ['--time-limit=30'] \n    print(' '.join(command))\n    result = subprocess.run(command, capture_output=True, text=True)\n"],time:'2024-09-12T22:36:13.511Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['112','0','208','28','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5, warning_ids=None):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - If warning_ids is provided, apply the heuristics to only those warnings.\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n\n    # Determine which warnings to operate on: either from ground_truth or passed warning_ids\n    if warning_ids:\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k in warning_ids if warnings_state.get(k) == 'uninspected'\n        ]\n        #here print(warning_ids)\n        #here print(' warnings:', warnings)\n    else:\n        # Get all uninspected warnings with their lines of code and function calls\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n        ]\n\n    # Shuffle the warnings and sample based on the sampling ratio\n    random.shuffle(warnings)\n    if len(warnings) > 1:\n        warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected or none passed, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    #print(containment)\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), \n                                      heuristic_shared_function_calls(warnings), \n                                      heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # Classify warnings as positive or negative based on their position in the sorted list\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings\n\n\n\ndef run_clingo():\n    files = [\n        f'lp/simulation_labels.lp',  \n        'lp/background.lp',              \n        'lp/frozen_rules.lp',            \n        'lp/rules2.lp'                   \n    ]\n    \n    command = ['clingo'] + files + ['--outf=2'] + ['--time-limit=30'] \n    print(' '.join(command))"],time:'2024-09-12T22:36:13.528Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['112','0','207','70','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5, warning_ids=None):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - If warning_ids is provided, apply the heuristics to only those warnings.\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n\n    # Determine which warnings to operate on: either from ground_truth or passed warning_ids\n    if warning_ids:\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k in warning_ids if warnings_state.get(k) == 'uninspected'\n        ]\n        #here print(warning_ids)\n        #here print(' warnings:', warnings)\n    else:\n        # Get all uninspected warnings with their lines of code and function calls\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n        ]\n\n    # Shuffle the warnings and sample based on the sampling ratio\n    random.shuffle(warnings)\n    if len(warnings) > 1:\n        warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected or none passed, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    #print(containment)\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), \n                                      heuristic_shared_function_calls(warnings), \n                                      heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # Classify warnings as positive or negative based on their position in the sorted list\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings\n\n\n\ndef run_clingo():\n    files = [\n        f'lp/simulation_labels.lp',  \n        'lp/background.lp',              \n        'lp/frozen_rules.lp',            \n        'lp/rules2.lp'                   \n    ]\n    \n    command = ['clingo'] + files + ['--outf=2'] + ['--time-limit=30'] "],time:'2024-09-12T22:36:13.544Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['112','0','205','5','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5, warning_ids=None):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - If warning_ids is provided, apply the heuristics to only those warnings.\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n\n    # Determine which warnings to operate on: either from ground_truth or passed warning_ids\n    if warning_ids:\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k in warning_ids if warnings_state.get(k) == 'uninspected'\n        ]\n        #here print(warning_ids)\n        #here print(' warnings:', warnings)\n    else:\n        # Get all uninspected warnings with their lines of code and function calls\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n        ]\n\n    # Shuffle the warnings and sample based on the sampling ratio\n    random.shuffle(warnings)\n    if len(warnings) > 1:\n        warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected or none passed, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    #print(containment)\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), \n                                      heuristic_shared_function_calls(warnings), \n                                      heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # Classify warnings as positive or negative based on their position in the sorted list\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings\n\n\n\ndef run_clingo():\n    files = [\n        f'lp/simulation_labels.lp',  \n        'lp/background.lp',              \n        'lp/frozen_rules.lp',            \n        'lp/rules2.lp'                   \n    ]"],time:'2024-09-12T22:36:13.561Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['112','0','204','41','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5, warning_ids=None):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - If warning_ids is provided, apply the heuristics to only those warnings.\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n\n    # Determine which warnings to operate on: either from ground_truth or passed warning_ids\n    if warning_ids:\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k in warning_ids if warnings_state.get(k) == 'uninspected'\n        ]\n        #here print(warning_ids)\n        #here print(' warnings:', warnings)\n    else:\n        # Get all uninspected warnings with their lines of code and function calls\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n        ]\n\n    # Shuffle the warnings and sample based on the sampling ratio\n    random.shuffle(warnings)\n    if len(warnings) > 1:\n        warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected or none passed, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    #print(containment)\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), \n                                      heuristic_shared_function_calls(warnings), \n                                      heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # Classify warnings as positive or negative based on their position in the sorted list\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings\n\n\n\ndef run_clingo():\n    files = [\n        f'lp/simulation_labels.lp',  \n        'lp/background.lp',              \n        'lp/frozen_rules.lp',            \n        'lp/rules2.lp'                   "],time:'2024-09-12T22:36:13.578Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['112','0','203','41','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5, warning_ids=None):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - If warning_ids is provided, apply the heuristics to only those warnings.\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n\n    # Determine which warnings to operate on: either from ground_truth or passed warning_ids\n    if warning_ids:\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k in warning_ids if warnings_state.get(k) == 'uninspected'\n        ]\n        #here print(warning_ids)\n        #here print(' warnings:', warnings)\n    else:\n        # Get all uninspected warnings with their lines of code and function calls\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n        ]\n\n    # Shuffle the warnings and sample based on the sampling ratio\n    random.shuffle(warnings)\n    if len(warnings) > 1:\n        warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected or none passed, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    #print(containment)\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), \n                                      heuristic_shared_function_calls(warnings), \n                                      heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # Classify warnings as positive or negative based on their position in the sorted list\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings\n\n\n\ndef run_clingo():\n    files = [\n        f'lp/simulation_labels.lp',  \n        'lp/background.lp',              \n        'lp/frozen_rules.lp',            "],time:'2024-09-12T22:36:13.594Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['112','0','202','41','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5, warning_ids=None):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - If warning_ids is provided, apply the heuristics to only those warnings.\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n\n    # Determine which warnings to operate on: either from ground_truth or passed warning_ids\n    if warning_ids:\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k in warning_ids if warnings_state.get(k) == 'uninspected'\n        ]\n        #here print(warning_ids)\n        #here print(' warnings:', warnings)\n    else:\n        # Get all uninspected warnings with their lines of code and function calls\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n        ]\n\n    # Shuffle the warnings and sample based on the sampling ratio\n    random.shuffle(warnings)\n    if len(warnings) > 1:\n        warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected or none passed, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    #print(containment)\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), \n                                      heuristic_shared_function_calls(warnings), \n                                      heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # Classify warnings as positive or negative based on their position in the sorted list\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings\n\n\n\ndef run_clingo():\n    files = [\n        f'lp/simulation_labels.lp',  \n        'lp/background.lp',              "],time:'2024-09-12T22:36:13.611Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['112','0','201','37','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5, warning_ids=None):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - If warning_ids is provided, apply the heuristics to only those warnings.\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n\n    # Determine which warnings to operate on: either from ground_truth or passed warning_ids\n    if warning_ids:\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k in warning_ids if warnings_state.get(k) == 'uninspected'\n        ]\n        #here print(warning_ids)\n        #here print(' warnings:', warnings)\n    else:\n        # Get all uninspected warnings with their lines of code and function calls\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n        ]\n\n    # Shuffle the warnings and sample based on the sampling ratio\n    random.shuffle(warnings)\n    if len(warnings) > 1:\n        warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected or none passed, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    #print(containment)\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), \n                                      heuristic_shared_function_calls(warnings), \n                                      heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # Classify warnings as positive or negative based on their position in the sorted list\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings\n\n\n\ndef run_clingo():\n    files = [\n        f'lp/simulation_labels.lp',  "],time:'2024-09-12T22:36:13.644Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['112','0','200','13','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5, warning_ids=None):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - If warning_ids is provided, apply the heuristics to only those warnings.\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n\n    # Determine which warnings to operate on: either from ground_truth or passed warning_ids\n    if warning_ids:\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k in warning_ids if warnings_state.get(k) == 'uninspected'\n        ]\n        #here print(warning_ids)\n        #here print(' warnings:', warnings)\n    else:\n        # Get all uninspected warnings with their lines of code and function calls\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n        ]\n\n    # Shuffle the warnings and sample based on the sampling ratio\n    random.shuffle(warnings)\n    if len(warnings) > 1:\n        warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected or none passed, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    #print(containment)\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), \n                                      heuristic_shared_function_calls(warnings), \n                                      heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # Classify warnings as positive or negative based on their position in the sorted list\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings\n\n\n\ndef run_clingo():\n    files = ["],time:'2024-09-12T22:36:13.694Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['112','0','199','17','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5, warning_ids=None):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - If warning_ids is provided, apply the heuristics to only those warnings.\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n\n    # Determine which warnings to operate on: either from ground_truth or passed warning_ids\n    if warning_ids:\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k in warning_ids if warnings_state.get(k) == 'uninspected'\n        ]\n        #here print(warning_ids)\n        #here print(' warnings:', warnings)\n    else:\n        # Get all uninspected warnings with their lines of code and function calls\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n        ]\n\n    # Shuffle the warnings and sample based on the sampling ratio\n    random.shuffle(warnings)\n    if len(warnings) > 1:\n        warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected or none passed, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    #print(containment)\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), \n                                      heuristic_shared_function_calls(warnings), \n                                      heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # Classify warnings as positive or negative based on their position in the sorted list\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings\n\n\n\ndef run_clingo():"],time:'2024-09-12T22:36:13.744Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['112','0','198','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5, warning_ids=None):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - If warning_ids is provided, apply the heuristics to only those warnings.\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n\n    # Determine which warnings to operate on: either from ground_truth or passed warning_ids\n    if warning_ids:\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k in warning_ids if warnings_state.get(k) == 'uninspected'\n        ]\n        #here print(warning_ids)\n        #here print(' warnings:', warnings)\n    else:\n        # Get all uninspected warnings with their lines of code and function calls\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n        ]\n\n    # Shuffle the warnings and sample based on the sampling ratio\n    random.shuffle(warnings)\n    if len(warnings) > 1:\n        warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected or none passed, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    #print(containment)\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), \n                                      heuristic_shared_function_calls(warnings), \n                                      heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # Classify warnings as positive or negative based on their position in the sorted list\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings\n\n\n"],time:'2024-09-12T22:36:13.794Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['112','0','197','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5, warning_ids=None):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - If warning_ids is provided, apply the heuristics to only those warnings.\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n\n    # Determine which warnings to operate on: either from ground_truth or passed warning_ids\n    if warning_ids:\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k in warning_ids if warnings_state.get(k) == 'uninspected'\n        ]\n        #here print(warning_ids)\n        #here print(' warnings:', warnings)\n    else:\n        # Get all uninspected warnings with their lines of code and function calls\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n        ]\n\n    # Shuffle the warnings and sample based on the sampling ratio\n    random.shuffle(warnings)\n    if len(warnings) > 1:\n        warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected or none passed, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    #print(containment)\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), \n                                      heuristic_shared_function_calls(warnings), \n                                      heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # Classify warnings as positive or negative based on their position in the sorted list\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings\n\n"],time:'2024-09-12T22:36:13.828Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['112','0','196','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5, warning_ids=None):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - If warning_ids is provided, apply the heuristics to only those warnings.\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n\n    # Determine which warnings to operate on: either from ground_truth or passed warning_ids\n    if warning_ids:\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k in warning_ids if warnings_state.get(k) == 'uninspected'\n        ]\n        #here print(warning_ids)\n        #here print(' warnings:', warnings)\n    else:\n        # Get all uninspected warnings with their lines of code and function calls\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n        ]\n\n    # Shuffle the warnings and sample based on the sampling ratio\n    random.shuffle(warnings)\n    if len(warnings) > 1:\n        warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected or none passed, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    #print(containment)\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), \n                                      heuristic_shared_function_calls(warnings), \n                                      heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # Classify warnings as positive or negative based on their position in the sorted list\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings\n"],time:'2024-09-12T22:36:13.845Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['112','0','195','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5, warning_ids=None):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - If warning_ids is provided, apply the heuristics to only those warnings.\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n\n    # Determine which warnings to operate on: either from ground_truth or passed warning_ids\n    if warning_ids:\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k in warning_ids if warnings_state.get(k) == 'uninspected'\n        ]\n        #here print(warning_ids)\n        #here print(' warnings:', warnings)\n    else:\n        # Get all uninspected warnings with their lines of code and function calls\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n        ]\n\n    # Shuffle the warnings and sample based on the sampling ratio\n    random.shuffle(warnings)\n    if len(warnings) > 1:\n        warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected or none passed, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    #print(containment)\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), \n                                      heuristic_shared_function_calls(warnings), \n                                      heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # Classify warnings as positive or negative based on their position in the sorted list\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings"],time:'2024-09-12T22:36:13.861Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['112','0','194','4','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5, warning_ids=None):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - If warning_ids is provided, apply the heuristics to only those warnings.\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n\n    # Determine which warnings to operate on: either from ground_truth or passed warning_ids\n    if warning_ids:\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k in warning_ids if warnings_state.get(k) == 'uninspected'\n        ]\n        #here print(warning_ids)\n        #here print(' warnings:', warnings)\n    else:\n        # Get all uninspected warnings with their lines of code and function calls\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n        ]\n\n    # Shuffle the warnings and sample based on the sampling ratio\n    random.shuffle(warnings)\n    if len(warnings) > 1:\n        warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected or none passed, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    #print(containment)\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), \n                                      heuristic_shared_function_calls(warnings), \n                                      heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # Classify warnings as positive or negative based on their position in the sorted list\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    "],time:'2024-09-12T22:36:13.878Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['112','0','193','67','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5, warning_ids=None):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - If warning_ids is provided, apply the heuristics to only those warnings.\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n\n    # Determine which warnings to operate on: either from ground_truth or passed warning_ids\n    if warning_ids:\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k in warning_ids if warnings_state.get(k) == 'uninspected'\n        ]\n        #here print(warning_ids)\n        #here print(' warnings:', warnings)\n    else:\n        # Get all uninspected warnings with their lines of code and function calls\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n        ]\n\n    # Shuffle the warnings and sample based on the sampling ratio\n    random.shuffle(warnings)\n    if len(warnings) > 1:\n        warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected or none passed, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    #print(containment)\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), \n                                      heuristic_shared_function_calls(warnings), \n                                      heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # Classify warnings as positive or negative based on their position in the sorted list\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)"],time:'2024-09-12T22:36:13.911Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['112','0','194','4','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5, warning_ids=None):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - If warning_ids is provided, apply the heuristics to only those warnings.\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n\n    # Determine which warnings to operate on: either from ground_truth or passed warning_ids\n    if warning_ids:\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k in warning_ids if warnings_state.get(k) == 'uninspected'\n        ]\n        #here print(warning_ids)\n        #here print(' warnings:', warnings)\n    else:\n        # Get all uninspected warnings with their lines of code and function calls\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n        ]\n\n    # Shuffle the warnings and sample based on the sampling ratio\n    random.shuffle(warnings)\n    if len(warnings) > 1:\n        warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected or none passed, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    #print(containment)\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), \n                                      heuristic_shared_function_calls(warnings), \n                                      heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # Classify warnings as positive or negative based on their position in the sorted list\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    "],time:'2024-09-12T22:36:14.061Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['112','0','195','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5, warning_ids=None):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - If warning_ids is provided, apply the heuristics to only those warnings.\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n\n    # Determine which warnings to operate on: either from ground_truth or passed warning_ids\n    if warning_ids:\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k in warning_ids if warnings_state.get(k) == 'uninspected'\n        ]\n        #here print(warning_ids)\n        #here print(' warnings:', warnings)\n    else:\n        # Get all uninspected warnings with their lines of code and function calls\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n        ]\n\n    # Shuffle the warnings and sample based on the sampling ratio\n    random.shuffle(warnings)\n    if len(warnings) > 1:\n        warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected or none passed, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    #print(containment)\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), \n                                      heuristic_shared_function_calls(warnings), \n                                      heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # Classify warnings as positive or negative based on their position in the sorted list\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings"],time:'2024-09-12T22:36:14.078Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['112','0','196','0','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5, warning_ids=None):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - If warning_ids is provided, apply the heuristics to only those warnings.\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n\n    # Determine which warnings to operate on: either from ground_truth or passed warning_ids\n    if warning_ids:\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k in warning_ids if warnings_state.get(k) == 'uninspected'\n        ]\n        #here print(warning_ids)\n        #here print(' warnings:', warnings)\n    else:\n        # Get all uninspected warnings with their lines of code and function calls\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n        ]\n\n    # Shuffle the warnings and sample based on the sampling ratio\n    random.shuffle(warnings)\n    if len(warnings) > 1:\n        warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected or none passed, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    #print(containment)\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), \n                                      heuristic_shared_function_calls(warnings), \n                                      heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # Classify warnings as positive or negative based on their position in the sorted list\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings\n"],time:'2024-09-12T22:36:14.095Z'},{src:'onDidChangeTextEditorSelection',msg:'%s:%s to %s:%s in [%s] text: %s',prm:['112','0','195','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5, warning_ids=None):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - If warning_ids is provided, apply the heuristics to only those warnings.\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n\n    # Determine which warnings to operate on: either from ground_truth or passed warning_ids\n    if warning_ids:\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k in warning_ids if warnings_state.get(k) == 'uninspected'\n        ]\n        #here print(warning_ids)\n        #here print(' warnings:', warnings)\n    else:\n        # Get all uninspected warnings with their lines of code and function calls\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n        ]\n\n    # Shuffle the warnings and sample based on the sampling ratio\n    random.shuffle(warnings)\n    if len(warnings) > 1:\n        warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected or none passed, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    #print(containment)\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), \n                                      heuristic_shared_function_calls(warnings), \n                                      heuristic_neighbor_classes(warnings, containment)])\n\n    # Sort by code length to identify shortest and longest warnings\n    sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n    # Classify warnings as positive or negative based on their position in the sorted list\n    for i in range(len(warnings)):\n        if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'positive'\n            warnings[i] = tuple(warnings[i])\n        else:\n            warnings[i] = list(warnings[i])\n            warnings[i][3] = 'negative'\n            warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings"],time:'2024-09-12T22:36:14.395Z'},{src:'onDidChangeTextDocument',msg:'%s:%s to %s:%s in [%s] replaced with: %s`',prm:['112','0','195','65','/Users/burakyetistiren/Desktop/warning_suppression/code/simulate.py',"def sample_labels_randomized_then_sorted(ground_truth, num_pos, num_neg, code_data, warnings_state, apply_heuristics=None, sampling_ratio=0.5, warning_ids=None, use_ground_truth=False):\n    \"\"\"\n    Apply specified heuristics to the warnings before sampling:\n    - apply_heuristics: A list containing the numbers [1, 2, 3] corresponding to the heuristics to apply.\n        1: Review the shorter code first.\n        2: Look for similar code (shared API calls).\n        3: Look for neighbor classes (contained in the same package or directory).\n    - If warning_ids is provided, apply the heuristics to only those warnings.\n    - If use_ground_truth is True, classify warnings based on ground_truth instead of code length.\n    - After applying heuristics, select either one positive or one negative warning based on a coin toss.\n    \"\"\"\n    if apply_heuristics is None:\n        apply_heuristics = [1, 2, 3]  # Default to applying all heuristics\n\n    # Determine which warnings to operate on: either from ground_truth or passed warning_ids\n    if warning_ids:\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k in warning_ids if warnings_state.get(k) == 'uninspected'\n        ]\n    else:\n        # Get all uninspected warnings with their lines of code and function calls\n        warnings = [\n            (k, code_data.get(int(k), {}).get('linesOfCode', 0), code_data.get(int(k), {}).get('functionCalls', []), 'uninspected')\n            for k, v in ground_truth.items() if warnings_state[k] == 'uninspected'\n        ]\n\n    # Shuffle the warnings and sample based on the sampling ratio\n    random.shuffle(warnings)\n    if len(warnings) > 1:\n        warnings = warnings[:int(len(warnings) * sampling_ratio)]\n    \n    if not warnings:  # If all warnings have been inspected or none passed, return empty lists\n        return [], []\n    \n    # Apply heuristics in the specified order\n    containment = read_containment()\n    for heuristic in apply_heuristics:\n        if heuristic == 1:\n            warnings = heuristic_shorter_code_first(warnings)\n        elif heuristic == 2:\n            warnings = heuristic_shared_function_calls(warnings)\n        elif heuristic == 3:\n            warnings = heuristic_neighbor_classes(warnings, containment)\n        elif heuristic == 4:\n            # choose a random heuristic\n            warnings = random.choice([heuristic_shorter_code_first(warnings), \n                                      heuristic_shared_function_calls(warnings), \n                                      heuristic_neighbor_classes(warnings, containment)])\n\n    if use_ground_truth:\n        # Use ground truth labels instead of sorting by code length\n        for i in range(len(warnings)):\n            warning_id = warnings[i][0]\n            if ground_truth.get(warning_id) == 'positive':\n                warnings[i] = list(warnings[i])\n                warnings[i][3] = 'positive'\n                warnings[i] = tuple(warnings[i])\n            else:\n                warnings[i] = list(warnings[i])\n                warnings[i][3] = 'negative'\n                warnings[i] = tuple(warnings[i])\n    else:\n        # Sort by code length to identify shortest and longest warnings\n        sorted_warnings_by_length = sorted(warnings, key=lambda x: x[1])\n\n        # Classify warnings as positive or negative based on their position in the sorted list\n        for i in range(len(warnings)):\n            if warnings[i] in sorted_warnings_by_length[:len(sorted_warnings_by_length)//2]:\n                warnings[i] = list(warnings[i])\n                warnings[i][3] = 'positive'\n                warnings[i] = tuple(warnings[i])\n            else:\n                warnings[i] = list(warnings[i])\n                warnings[i][3] = 'negative'\n                warnings[i] = tuple(warnings[i])    \n    \n    # Coin toss to decide whether to pick a positive or negative warning\n    coin_toss = random.choice(['positive', 'negative'])\n    \n    if coin_toss == 'positive':\n        # Select the shortest warning for positive\n        selected_positive_warnings = [warnings[0][0]]\n        selected_negative_warnings = []\n        warnings_state[selected_positive_warnings[0]] = 'positive'\n    else:\n        # Select the longest warning for negative\n        selected_positive_warnings = []\n        selected_negative_warnings = [warnings[-1][0]]\n        warnings_state[selected_negative_warnings[0]] = 'negative'\n    \n    print('Selected positive warning:', selected_positive_warnings)\n    print('Selected negative warning:', selected_negative_warnings)\n    \n    return selected_positive_warnings, selected_negative_warnings\n"],time:'2024-09-12T22:39:14.495Z'}]